I file binari rtl8187l_orig/.DS_Store e rtl8187l/.DS_Store differiscono
diff -ruN rtl8187l_orig/ieee80211/aes.c rtl8187l/ieee80211/aes.c
--- rtl8187l_orig/ieee80211/aes.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/aes.c	2009-06-26 09:07:43.845356000 +0200
@@ -0,0 +1,468 @@
+/* 
+ * Cryptographic API.
+ *
+ * AES Cipher Algorithm.
+ *
+ * Based on Brian Gladman's code.
+ *
+ * Linux developers:
+ *  Alexander Kjeldaas <astor@fast.no>
+ *  Herbert Valerio Riedel <hvr@hvrlab.org>
+ *  Kyle McMartin <kyle@debian.org>
+ *  Adam J. Richter <adam@yggdrasil.com> (conversion to 2.5 API).
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * ---------------------------------------------------------------------------
+ * Copyright (c) 2002, Dr Brian Gladman <brg@gladman.me.uk>, Worcester, UK.
+ * All rights reserved.
+ *
+ * LICENSE TERMS
+ *
+ * The free distribution and use of this software in both source and binary
+ * form is allowed (with or without changes) provided that:
+ *
+ *   1. distributions of this source code include the above copyright
+ *      notice, this list of conditions and the following disclaimer;
+ *
+ *   2. distributions in binary form include the above copyright
+ *      notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other associated materials;
+ *
+ *   3. the copyright holder's name is not used to endorse products
+ *      built using this software without specific written permission.
+ *
+ * ALTERNATIVELY, provided that this notice is retained in full, this product
+ * may be distributed under the terms of the GNU General Public License (GPL),
+ * in which case the provisions of the GPL apply INSTEAD OF those given above.
+ *
+ * DISCLAIMER
+ *
+ * This software is provided 'as is' with no explicit or implied warranties
+ * in respect of its properties, including, but not limited to, correctness
+ * and/or fitness for purpose.
+ * ---------------------------------------------------------------------------
+ */
+
+/* Some changes from the Gladman version:
+    s/RIJNDAEL(e_key)/E_KEY/g
+    s/RIJNDAEL(d_key)/D_KEY/g
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include "rtl_crypto.h"
+#include <asm/byteorder.h>
+
+#define AES_MIN_KEY_SIZE	16
+#define AES_MAX_KEY_SIZE	32
+
+#define AES_BLOCK_SIZE		16
+
+static inline 
+u32 generic_rotr32 (const u32 x, const unsigned bits)
+{
+	const unsigned n = bits % 32;
+	return (x >> n) | (x << (32 - n));
+}
+
+static inline 
+u32 generic_rotl32 (const u32 x, const unsigned bits)
+{
+	const unsigned n = bits % 32;
+	return (x << n) | (x >> (32 - n));
+}
+
+#define rotl generic_rotl32
+#define rotr generic_rotr32
+
+/*
+ * #define byte(x, nr) ((unsigned char)((x) >> (nr*8))) 
+ */
+inline static u8
+byte(const u32 x, const unsigned n)
+{
+	return x >> (n << 3);
+}
+
+#define u32_in(x) le32_to_cpu(*(const u32 *)(x))
+#define u32_out(to, from) (*(u32 *)(to) = cpu_to_le32(from))
+
+struct aes_ctx {
+	int key_length;
+	u32 E[60];
+	u32 D[60];
+};
+
+#define E_KEY ctx->E
+#define D_KEY ctx->D
+
+static u8 pow_tab[256] __initdata;
+static u8 log_tab[256] __initdata;
+static u8 sbx_tab[256] __initdata;
+static u8 isb_tab[256] __initdata;
+static u32 rco_tab[10];
+static u32 ft_tab[4][256];
+static u32 it_tab[4][256];
+
+static u32 fl_tab[4][256];
+static u32 il_tab[4][256];
+
+static inline u8 __init
+f_mult (u8 a, u8 b)
+{
+	u8 aa = log_tab[a], cc = aa + log_tab[b];
+
+	return pow_tab[cc + (cc < aa ? 1 : 0)];
+}
+
+#define ff_mult(a,b)    (a && b ? f_mult(a, b) : 0)
+
+#define f_rn(bo, bi, n, k)					\
+    bo[n] =  ft_tab[0][byte(bi[n],0)] ^				\
+             ft_tab[1][byte(bi[(n + 1) & 3],1)] ^		\
+             ft_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+             ft_tab[3][byte(bi[(n + 3) & 3],3)] ^ *(k + n)
+
+#define i_rn(bo, bi, n, k)					\
+    bo[n] =  it_tab[0][byte(bi[n],0)] ^				\
+             it_tab[1][byte(bi[(n + 3) & 3],1)] ^		\
+             it_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+             it_tab[3][byte(bi[(n + 1) & 3],3)] ^ *(k + n)
+
+#define ls_box(x)				\
+    ( fl_tab[0][byte(x, 0)] ^			\
+      fl_tab[1][byte(x, 1)] ^			\
+      fl_tab[2][byte(x, 2)] ^			\
+      fl_tab[3][byte(x, 3)] )
+
+#define f_rl(bo, bi, n, k)					\
+    bo[n] =  fl_tab[0][byte(bi[n],0)] ^				\
+             fl_tab[1][byte(bi[(n + 1) & 3],1)] ^		\
+             fl_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+             fl_tab[3][byte(bi[(n + 3) & 3],3)] ^ *(k + n)
+
+#define i_rl(bo, bi, n, k)					\
+    bo[n] =  il_tab[0][byte(bi[n],0)] ^				\
+             il_tab[1][byte(bi[(n + 3) & 3],1)] ^		\
+             il_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+             il_tab[3][byte(bi[(n + 1) & 3],3)] ^ *(k + n)
+
+static void __init
+gen_tabs (void)
+{
+	u32 i, t;
+	u8 p, q;
+
+	/* log and power tables for GF(2**8) finite field with
+	   0x011b as modular polynomial - the simplest primitive
+	   root is 0x03, used here to generate the tables */
+
+	for (i = 0, p = 1; i < 256; ++i) {
+		pow_tab[i] = (u8) p;
+		log_tab[p] = (u8) i;
+
+		p ^= (p << 1) ^ (p & 0x80 ? 0x01b : 0);
+	}
+
+	log_tab[1] = 0;
+
+	for (i = 0, p = 1; i < 10; ++i) {
+		rco_tab[i] = p;
+
+		p = (p << 1) ^ (p & 0x80 ? 0x01b : 0);
+	}
+
+	for (i = 0; i < 256; ++i) {
+		p = (i ? pow_tab[255 - log_tab[i]] : 0);
+		q = ((p >> 7) | (p << 1)) ^ ((p >> 6) | (p << 2));
+		p ^= 0x63 ^ q ^ ((q >> 6) | (q << 2));
+		sbx_tab[i] = p;
+		isb_tab[p] = (u8) i;
+	}
+
+	for (i = 0; i < 256; ++i) {
+		p = sbx_tab[i];
+
+		t = p;
+		fl_tab[0][i] = t;
+		fl_tab[1][i] = rotl (t, 8);
+		fl_tab[2][i] = rotl (t, 16);
+		fl_tab[3][i] = rotl (t, 24);
+
+		t = ((u32) ff_mult (2, p)) |
+		    ((u32) p << 8) |
+		    ((u32) p << 16) | ((u32) ff_mult (3, p) << 24);
+
+		ft_tab[0][i] = t;
+		ft_tab[1][i] = rotl (t, 8);
+		ft_tab[2][i] = rotl (t, 16);
+		ft_tab[3][i] = rotl (t, 24);
+
+		p = isb_tab[i];
+
+		t = p;
+		il_tab[0][i] = t;
+		il_tab[1][i] = rotl (t, 8);
+		il_tab[2][i] = rotl (t, 16);
+		il_tab[3][i] = rotl (t, 24);
+
+		t = ((u32) ff_mult (14, p)) |
+		    ((u32) ff_mult (9, p) << 8) |
+		    ((u32) ff_mult (13, p) << 16) |
+		    ((u32) ff_mult (11, p) << 24);
+
+		it_tab[0][i] = t;
+		it_tab[1][i] = rotl (t, 8);
+		it_tab[2][i] = rotl (t, 16);
+		it_tab[3][i] = rotl (t, 24);
+	}
+}
+
+#define star_x(x) (((x) & 0x7f7f7f7f) << 1) ^ ((((x) & 0x80808080) >> 7) * 0x1b)
+
+#define imix_col(y,x)       \
+    u   = star_x(x);        \
+    v   = star_x(u);        \
+    w   = star_x(v);        \
+    t   = w ^ (x);          \
+   (y)  = u ^ v ^ w;        \
+   (y) ^= rotr(u ^ t,  8) ^ \
+          rotr(v ^ t, 16) ^ \
+          rotr(t,24)
+
+/* initialise the key schedule from the user supplied key */
+
+#define loop4(i)                                    \
+{   t = rotr(t,  8); t = ls_box(t) ^ rco_tab[i];    \
+    t ^= E_KEY[4 * i];     E_KEY[4 * i + 4] = t;    \
+    t ^= E_KEY[4 * i + 1]; E_KEY[4 * i + 5] = t;    \
+    t ^= E_KEY[4 * i + 2]; E_KEY[4 * i + 6] = t;    \
+    t ^= E_KEY[4 * i + 3]; E_KEY[4 * i + 7] = t;    \
+}
+
+#define loop6(i)                                    \
+{   t = rotr(t,  8); t = ls_box(t) ^ rco_tab[i];    \
+    t ^= E_KEY[6 * i];     E_KEY[6 * i + 6] = t;    \
+    t ^= E_KEY[6 * i + 1]; E_KEY[6 * i + 7] = t;    \
+    t ^= E_KEY[6 * i + 2]; E_KEY[6 * i + 8] = t;    \
+    t ^= E_KEY[6 * i + 3]; E_KEY[6 * i + 9] = t;    \
+    t ^= E_KEY[6 * i + 4]; E_KEY[6 * i + 10] = t;   \
+    t ^= E_KEY[6 * i + 5]; E_KEY[6 * i + 11] = t;   \
+}
+
+#define loop8(i)                                    \
+{   t = rotr(t,  8); ; t = ls_box(t) ^ rco_tab[i];  \
+    t ^= E_KEY[8 * i];     E_KEY[8 * i + 8] = t;    \
+    t ^= E_KEY[8 * i + 1]; E_KEY[8 * i + 9] = t;    \
+    t ^= E_KEY[8 * i + 2]; E_KEY[8 * i + 10] = t;   \
+    t ^= E_KEY[8 * i + 3]; E_KEY[8 * i + 11] = t;   \
+    t  = E_KEY[8 * i + 4] ^ ls_box(t);    \
+    E_KEY[8 * i + 12] = t;                \
+    t ^= E_KEY[8 * i + 5]; E_KEY[8 * i + 13] = t;   \
+    t ^= E_KEY[8 * i + 6]; E_KEY[8 * i + 14] = t;   \
+    t ^= E_KEY[8 * i + 7]; E_KEY[8 * i + 15] = t;   \
+}
+
+static int
+aes_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
+{
+	struct aes_ctx *ctx = ctx_arg;
+	u32 i, t, u, v, w;
+
+	if (key_len != 16 && key_len != 24 && key_len != 32) {
+		*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+
+	ctx->key_length = key_len;
+
+	E_KEY[0] = u32_in (in_key);
+	E_KEY[1] = u32_in (in_key + 4);
+	E_KEY[2] = u32_in (in_key + 8);
+	E_KEY[3] = u32_in (in_key + 12);
+
+	switch (key_len) {
+	case 16:
+		t = E_KEY[3];
+		for (i = 0; i < 10; ++i)
+			loop4 (i);
+		break;
+
+	case 24:
+		E_KEY[4] = u32_in (in_key + 16);
+		t = E_KEY[5] = u32_in (in_key + 20);
+		for (i = 0; i < 8; ++i)
+			loop6 (i);
+		break;
+
+	case 32:
+		E_KEY[4] = u32_in (in_key + 16);
+		E_KEY[5] = u32_in (in_key + 20);
+		E_KEY[6] = u32_in (in_key + 24);
+		t = E_KEY[7] = u32_in (in_key + 28);
+		for (i = 0; i < 7; ++i)
+			loop8 (i);
+		break;
+	}
+
+	D_KEY[0] = E_KEY[0];
+	D_KEY[1] = E_KEY[1];
+	D_KEY[2] = E_KEY[2];
+	D_KEY[3] = E_KEY[3];
+
+	for (i = 4; i < key_len + 24; ++i) {
+		imix_col (D_KEY[i], E_KEY[i]);
+	}
+
+	return 0;
+}
+
+/* encrypt a block of text */
+
+#define f_nround(bo, bi, k) \
+    f_rn(bo, bi, 0, k);     \
+    f_rn(bo, bi, 1, k);     \
+    f_rn(bo, bi, 2, k);     \
+    f_rn(bo, bi, 3, k);     \
+    k += 4
+
+#define f_lround(bo, bi, k) \
+    f_rl(bo, bi, 0, k);     \
+    f_rl(bo, bi, 1, k);     \
+    f_rl(bo, bi, 2, k);     \
+    f_rl(bo, bi, 3, k)
+
+static void aes_encrypt(void *ctx_arg, u8 *out, const u8 *in)
+{
+	const struct aes_ctx *ctx = ctx_arg;
+	u32 b0[4], b1[4];
+	const u32 *kp = E_KEY + 4;
+
+	b0[0] = u32_in (in) ^ E_KEY[0];
+	b0[1] = u32_in (in + 4) ^ E_KEY[1];
+	b0[2] = u32_in (in + 8) ^ E_KEY[2];
+	b0[3] = u32_in (in + 12) ^ E_KEY[3];
+
+	if (ctx->key_length > 24) {
+		f_nround (b1, b0, kp);
+		f_nround (b0, b1, kp);
+	}
+
+	if (ctx->key_length > 16) {
+		f_nround (b1, b0, kp);
+		f_nround (b0, b1, kp);
+	}
+
+	f_nround (b1, b0, kp);
+	f_nround (b0, b1, kp);
+	f_nround (b1, b0, kp);
+	f_nround (b0, b1, kp);
+	f_nround (b1, b0, kp);
+	f_nround (b0, b1, kp);
+	f_nround (b1, b0, kp);
+	f_nround (b0, b1, kp);
+	f_nround (b1, b0, kp);
+	f_lround (b0, b1, kp);
+
+	u32_out (out, b0[0]);
+	u32_out (out + 4, b0[1]);
+	u32_out (out + 8, b0[2]);
+	u32_out (out + 12, b0[3]);
+}
+
+/* decrypt a block of text */
+
+#define i_nround(bo, bi, k) \
+    i_rn(bo, bi, 0, k);     \
+    i_rn(bo, bi, 1, k);     \
+    i_rn(bo, bi, 2, k);     \
+    i_rn(bo, bi, 3, k);     \
+    k -= 4
+
+#define i_lround(bo, bi, k) \
+    i_rl(bo, bi, 0, k);     \
+    i_rl(bo, bi, 1, k);     \
+    i_rl(bo, bi, 2, k);     \
+    i_rl(bo, bi, 3, k)
+
+static void aes_decrypt(void *ctx_arg, u8 *out, const u8 *in)
+{
+	const struct aes_ctx *ctx = ctx_arg;
+	u32 b0[4], b1[4];
+	const int key_len = ctx->key_length;
+	const u32 *kp = D_KEY + key_len + 20;
+
+	b0[0] = u32_in (in) ^ E_KEY[key_len + 24];
+	b0[1] = u32_in (in + 4) ^ E_KEY[key_len + 25];
+	b0[2] = u32_in (in + 8) ^ E_KEY[key_len + 26];
+	b0[3] = u32_in (in + 12) ^ E_KEY[key_len + 27];
+
+	if (key_len > 24) {
+		i_nround (b1, b0, kp);
+		i_nround (b0, b1, kp);
+	}
+
+	if (key_len > 16) {
+		i_nround (b1, b0, kp);
+		i_nround (b0, b1, kp);
+	}
+
+	i_nround (b1, b0, kp);
+	i_nround (b0, b1, kp);
+	i_nround (b1, b0, kp);
+	i_nround (b0, b1, kp);
+	i_nround (b1, b0, kp);
+	i_nround (b0, b1, kp);
+	i_nround (b1, b0, kp);
+	i_nround (b0, b1, kp);
+	i_nround (b1, b0, kp);
+	i_lround (b0, b1, kp);
+
+	u32_out (out, b0[0]);
+	u32_out (out + 4, b0[1]);
+	u32_out (out + 8, b0[2]);
+	u32_out (out + 12, b0[3]);
+}
+
+
+static struct crypto_alg aes_alg = {
+	.cra_name		=	"aes",
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	AES_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct aes_ctx),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(aes_alg.cra_list),
+	.cra_u			=	{
+		.cipher = {
+			.cia_min_keysize	=	AES_MIN_KEY_SIZE,
+			.cia_max_keysize	=	AES_MAX_KEY_SIZE,
+			.cia_setkey	   	= 	aes_set_key,
+			.cia_encrypt	 	=	aes_encrypt,
+			.cia_decrypt	  	=	aes_decrypt
+		}
+	}
+};
+
+static int __init aes_init(void)
+{
+	gen_tabs();
+	return crypto_register_alg(&aes_alg);
+}
+
+static void __exit aes_fini(void)
+{
+	crypto_unregister_alg(&aes_alg);
+}
+
+module_init(aes_init);
+module_exit(aes_fini);
+
+MODULE_DESCRIPTION("Rijndael (AES) Cipher Algorithm");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff -ruN rtl8187l_orig/ieee80211/api.c rtl8187l/ieee80211/api.c
--- rtl8187l_orig/ieee80211/api.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/api.c	2009-06-26 09:07:43.849521000 +0200
@@ -0,0 +1,245 @@
+/*
+ * Scatterlist Cryptographic API.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * Copyright (c) 2002 David S. Miller (davem@redhat.com)
+ *
+ * Portions derived from Cryptoapi, by Alexander Kjeldaas <astor@fast.no>
+ * and Nettle, by Niels M鰈ler.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include "kmap_types.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include "rtl_crypto.h"
+#include <linux/errno.h>
+#include <linux/rwsem.h>
+#include <linux/slab.h>
+#include "internal.h"
+
+LIST_HEAD(crypto_alg_list);
+DECLARE_RWSEM(crypto_alg_sem);
+
+static inline int crypto_alg_get(struct crypto_alg *alg)
+{
+	return try_inc_mod_count(alg->cra_module);
+}
+
+static inline void crypto_alg_put(struct crypto_alg *alg)
+{
+	if (alg->cra_module)
+		__MOD_DEC_USE_COUNT(alg->cra_module);
+}
+
+struct crypto_alg *crypto_alg_lookup(const char *name)
+{
+	struct crypto_alg *q, *alg = NULL;
+
+	if (!name)
+		return NULL;
+	
+	down_read(&crypto_alg_sem);
+	
+	list_for_each_entry(q, &crypto_alg_list, cra_list) {
+		if (!(strcmp(q->cra_name, name))) {
+			if (crypto_alg_get(q))
+				alg = q;
+			break;
+		}
+	}
+	
+	up_read(&crypto_alg_sem);
+	return alg;
+}
+
+static int crypto_init_flags(struct crypto_tfm *tfm, u32 flags)
+{
+	tfm->crt_flags = 0;
+	
+	switch (crypto_tfm_alg_type(tfm)) {
+	case CRYPTO_ALG_TYPE_CIPHER:
+		return crypto_init_cipher_flags(tfm, flags);
+		
+	case CRYPTO_ALG_TYPE_DIGEST:
+		return crypto_init_digest_flags(tfm, flags);
+		
+	case CRYPTO_ALG_TYPE_COMPRESS:
+		return crypto_init_compress_flags(tfm, flags);
+	
+	default:
+		break;
+	}
+	
+	BUG();
+	return -EINVAL;
+}
+
+static int crypto_init_ops(struct crypto_tfm *tfm)
+{
+	switch (crypto_tfm_alg_type(tfm)) {
+	case CRYPTO_ALG_TYPE_CIPHER:
+		return crypto_init_cipher_ops(tfm);
+		
+	case CRYPTO_ALG_TYPE_DIGEST:
+		return crypto_init_digest_ops(tfm);
+		
+	case CRYPTO_ALG_TYPE_COMPRESS:
+		return crypto_init_compress_ops(tfm);
+	
+	default:
+		break;
+	}
+	
+	BUG();
+	return -EINVAL;
+}
+
+static void crypto_exit_ops(struct crypto_tfm *tfm)
+{
+	switch (crypto_tfm_alg_type(tfm)) {
+	case CRYPTO_ALG_TYPE_CIPHER:
+		crypto_exit_cipher_ops(tfm);
+		break;
+		
+	case CRYPTO_ALG_TYPE_DIGEST:
+		crypto_exit_digest_ops(tfm);
+		break;
+		
+	case CRYPTO_ALG_TYPE_COMPRESS:
+		crypto_exit_compress_ops(tfm);
+		break;
+	
+	default:
+		BUG();
+		
+	}
+}
+
+struct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)
+{
+	struct crypto_tfm *tfm = NULL;
+	struct crypto_alg *alg;
+
+	alg = crypto_alg_mod_lookup(name);
+	if (alg == NULL)
+		goto out;
+	
+	tfm = kmalloc(sizeof(*tfm) + alg->cra_ctxsize, GFP_KERNEL);
+	if (tfm == NULL)
+		goto out_put;
+
+	memset(tfm, 0, sizeof(*tfm) + alg->cra_ctxsize);
+	
+	tfm->__crt_alg = alg;
+	
+	if (crypto_init_flags(tfm, flags))
+		goto out_free_tfm;
+		
+	if (crypto_init_ops(tfm)) {
+		crypto_exit_ops(tfm);
+		goto out_free_tfm;
+	}
+
+	goto out;
+
+out_free_tfm:
+	kfree(tfm);
+	tfm = NULL;
+out_put:
+	crypto_alg_put(alg);
+out:
+	return tfm;
+}
+
+void crypto_free_tfm(struct crypto_tfm *tfm)
+{
+	struct crypto_alg *alg = tfm->__crt_alg;
+	int size = sizeof(*tfm) + alg->cra_ctxsize;
+
+	crypto_exit_ops(tfm);
+	crypto_alg_put(alg);
+	memset(tfm, 0, size);
+	kfree(tfm);
+}
+
+int crypto_register_alg(struct crypto_alg *alg)
+{
+	int ret = 0;
+	struct crypto_alg *q;
+	
+	down_write(&crypto_alg_sem);
+	
+	list_for_each_entry(q, &crypto_alg_list, cra_list) {
+		if (!(strcmp(q->cra_name, alg->cra_name))) {
+			ret = -EEXIST;
+			goto out;
+		}
+	}
+	
+	list_add_tail(&alg->cra_list, &crypto_alg_list);
+out:	
+	up_write(&crypto_alg_sem);
+	return ret;
+}
+
+int crypto_unregister_alg(struct crypto_alg *alg)
+{
+	int ret = -ENOENT;
+	struct crypto_alg *q;
+	
+	BUG_ON(!alg->cra_module);
+	
+	down_write(&crypto_alg_sem);
+	list_for_each_entry(q, &crypto_alg_list, cra_list) {
+		if (alg == q) {
+			list_del(&alg->cra_list);
+			ret = 0;
+			goto out;
+		}
+	}
+out:	
+	up_write(&crypto_alg_sem);
+	return ret;
+}
+
+int crypto_alg_available(const char *name, u32 flags)
+{
+	int ret = 0;
+	struct crypto_alg *alg = crypto_alg_mod_lookup(name);
+	
+	if (alg) {
+		crypto_alg_put(alg);
+		ret = 1;
+	}
+	
+	return ret;
+}
+
+static int __init init_crypto(void)
+{
+	printk(KERN_INFO "Initializing Cryptographic API\n");
+	crypto_init_proc();
+	return 0;
+}
+
+__initcall(init_crypto);
+
+/*
+EXPORT_SYMBOL_GPL(crypto_register_alg);
+EXPORT_SYMBOL_GPL(crypto_unregister_alg);
+EXPORT_SYMBOL_GPL(crypto_alloc_tfm);
+EXPORT_SYMBOL_GPL(crypto_free_tfm);
+EXPORT_SYMBOL_GPL(crypto_alg_available);
+*/
+
+EXPORT_SYMBOL_NOVERS(crypto_register_alg);
+EXPORT_SYMBOL_NOVERS(crypto_unregister_alg);
+EXPORT_SYMBOL_NOVERS(crypto_alloc_tfm);
+EXPORT_SYMBOL_NOVERS(crypto_free_tfm);
+EXPORT_SYMBOL_NOVERS(crypto_alg_available);
diff -ruN rtl8187l_orig/ieee80211/arc4.c rtl8187l/ieee80211/arc4.c
--- rtl8187l_orig/ieee80211/arc4.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/arc4.c	2009-06-26 09:07:43.849521000 +0200
@@ -0,0 +1,103 @@
+/* 
+ * Cryptographic API
+ *
+ * ARC4 Cipher Algorithm
+ *
+ * Jon Oberheide <jon@oberheide.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include "rtl_crypto.h"
+
+#define ARC4_MIN_KEY_SIZE	1
+#define ARC4_MAX_KEY_SIZE	256
+#define ARC4_BLOCK_SIZE		1
+
+struct arc4_ctx {
+	u8 S[256];
+	u8 x, y;
+};
+
+static int arc4_set_key(void *ctx_arg, const u8 *in_key, unsigned int key_len, u32 *flags)
+{
+	struct arc4_ctx *ctx = ctx_arg;
+	int i, j = 0, k = 0;
+
+	ctx->x = 1;
+	ctx->y = 0;
+
+	for(i = 0; i < 256; i++)
+		ctx->S[i] = i;
+
+	for(i = 0; i < 256; i++)
+	{
+		u8 a = ctx->S[i];
+		j = (j + in_key[k] + a) & 0xff;
+		ctx->S[i] = ctx->S[j];
+		ctx->S[j] = a;
+		if((unsigned int)++k >= key_len)
+			k = 0;
+	}
+
+	return 0;
+}
+
+static void arc4_crypt(void *ctx_arg, u8 *out, const u8 *in)
+{
+	struct arc4_ctx *ctx = ctx_arg;
+
+	u8 *const S = ctx->S;
+	u8 x = ctx->x;
+	u8 y = ctx->y;
+	u8 a, b;
+
+	a = S[x];
+	y = (y + a) & 0xff;
+	b = S[y];
+	S[x] = b;
+	S[y] = a;
+	x = (x + 1) & 0xff;
+	*out++ = *in ^ S[(a + b) & 0xff];
+
+	ctx->x = x;
+	ctx->y = y;
+}
+
+static struct crypto_alg arc4_alg = {
+	.cra_name		=	"arc4",
+	.cra_flags		=	CRYPTO_ALG_TYPE_CIPHER,
+	.cra_blocksize		=	ARC4_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct arc4_ctx),
+	.cra_module		=	THIS_MODULE,
+	.cra_list		=	LIST_HEAD_INIT(arc4_alg.cra_list),
+	.cra_u			=	{ .cipher = {
+	.cia_min_keysize	=	ARC4_MIN_KEY_SIZE,
+	.cia_max_keysize	=	ARC4_MAX_KEY_SIZE,
+	.cia_setkey	   	= 	arc4_set_key,
+	.cia_encrypt	 	=	arc4_crypt,
+	.cia_decrypt	  	=	arc4_crypt } }
+};
+
+static int __init arc4_init(void)
+{
+	return crypto_register_alg(&arc4_alg);
+}
+
+
+static void __exit arc4_exit(void)
+{
+	crypto_unregister_alg(&arc4_alg);
+}
+
+module_init(arc4_init);
+module_exit(arc4_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ARC4 Cipher Algorithm");
+MODULE_AUTHOR("Jon Oberheide <jon@oberheide.org>");
diff -ruN rtl8187l_orig/ieee80211/autoload.c rtl8187l/ieee80211/autoload.c
--- rtl8187l_orig/ieee80211/autoload.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/autoload.c	2009-06-26 09:07:43.849521000 +0200
@@ -0,0 +1,39 @@
+/*
+ * Cryptographic API.
+ *
+ * Algorithm autoloader.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include "kmap_types.h"
+
+#include <linux/kernel.h>
+#include "rtl_crypto.h"
+#include <linux/string.h>
+#include <linux/kmod.h>
+#include "internal.h"
+
+/*
+ * A far more intelligent version of this is planned.  For now, just
+ * try an exact match on the name of the algorithm.
+ */
+void crypto_alg_autoload(const char *name)
+{
+	request_module(name);
+}
+
+struct crypto_alg *crypto_alg_mod_lookup(const char *name)
+{
+	struct crypto_alg *alg = crypto_alg_lookup(name);
+	if (alg == NULL) {
+		crypto_alg_autoload(name);
+		alg = crypto_alg_lookup(name);
+	}
+	return alg;
+}
diff -ruN rtl8187l_orig/ieee80211/cipher.c rtl8187l/ieee80211/cipher.c
--- rtl8187l_orig/ieee80211/cipher.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/cipher.c	2009-06-26 09:07:43.849521000 +0200
@@ -0,0 +1,298 @@
+/*
+ * Cryptographic API.
+ *
+ * Cipher operations.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include "rtl_crypto.h"
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <asm/scatterlist.h>
+#include "internal.h"
+#include "scatterwalk.h"
+
+typedef void (cryptfn_t)(void *, u8 *, const u8 *);
+typedef void (procfn_t)(struct crypto_tfm *, u8 *,
+                        u8*, cryptfn_t, int enc, void *, int);
+
+static inline void xor_64(u8 *a, const u8 *b)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+}
+
+static inline void xor_128(u8 *a, const u8 *b)
+{
+	((u32 *)a)[0] ^= ((u32 *)b)[0];
+	((u32 *)a)[1] ^= ((u32 *)b)[1];
+	((u32 *)a)[2] ^= ((u32 *)b)[2];
+	((u32 *)a)[3] ^= ((u32 *)b)[3];
+}
+
+
+/* 
+ * Generic encrypt/decrypt wrapper for ciphers, handles operations across
+ * multiple page boundaries by using temporary blocks.  In user context,
+ * the kernel is given a chance to schedule us once per block.
+ */
+static int crypt(struct crypto_tfm *tfm,
+		 struct scatterlist *dst,
+		 struct scatterlist *src,
+                 unsigned int nbytes, cryptfn_t crfn,
+                 procfn_t prfn, int enc, void *info)
+{
+	struct scatter_walk walk_in, walk_out;
+	const unsigned int bsize = crypto_tfm_alg_blocksize(tfm);
+	u8 tmp_src[bsize];
+	u8 tmp_dst[bsize];
+
+	if (!nbytes)
+		return 0;
+
+	if (nbytes % bsize) {
+		tfm->crt_flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;
+		return -EINVAL;
+	}
+
+	scatterwalk_start(&walk_in, src);
+	scatterwalk_start(&walk_out, dst);
+
+	for(;;) {
+		u8 *src_p, *dst_p;
+		int in_place;
+
+		scatterwalk_map(&walk_in, 0);
+		scatterwalk_map(&walk_out, 1);
+		src_p = scatterwalk_whichbuf(&walk_in, bsize, tmp_src);
+		dst_p = scatterwalk_whichbuf(&walk_out, bsize, tmp_dst);
+		in_place = scatterwalk_samebuf(&walk_in, &walk_out,
+					       src_p, dst_p);
+
+		nbytes -= bsize;
+
+		scatterwalk_copychunks(src_p, &walk_in, bsize, 0);
+
+		prfn(tfm, dst_p, src_p, crfn, enc, info, in_place);
+
+		scatterwalk_done(&walk_in, 0, nbytes);
+
+		scatterwalk_copychunks(dst_p, &walk_out, bsize, 1);
+		scatterwalk_done(&walk_out, 1, nbytes);
+
+		if (!nbytes)
+			return 0;
+
+		crypto_yield(tfm);
+	}
+}
+
+static void cbc_process(struct crypto_tfm *tfm, u8 *dst, u8 *src,
+			cryptfn_t fn, int enc, void *info, int in_place)
+{
+	u8 *iv = info;
+	
+	/* Null encryption */
+	if (!iv)
+		return;
+		
+	if (enc) {
+		tfm->crt_u.cipher.cit_xor_block(iv, src);
+		fn(crypto_tfm_ctx(tfm), dst, iv);
+		memcpy(iv, dst, crypto_tfm_alg_blocksize(tfm));
+	} else {
+		u8 stack[in_place ? crypto_tfm_alg_blocksize(tfm) : 0];
+		u8 *buf = in_place ? stack : dst;
+
+		fn(crypto_tfm_ctx(tfm), buf, src);
+		tfm->crt_u.cipher.cit_xor_block(buf, iv);
+		memcpy(iv, src, crypto_tfm_alg_blocksize(tfm));
+		if (buf != dst)
+			memcpy(dst, buf, crypto_tfm_alg_blocksize(tfm));
+	}
+}
+
+static void ecb_process(struct crypto_tfm *tfm, u8 *dst, u8 *src,
+			cryptfn_t fn, int enc, void *info, int in_place)
+{
+	fn(crypto_tfm_ctx(tfm), dst, src);
+}
+
+static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	struct cipher_alg *cia = &tfm->__crt_alg->cra_cipher;
+	
+	if (keylen < cia->cia_min_keysize || keylen > cia->cia_max_keysize) {
+		tfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	} else
+		return cia->cia_setkey(crypto_tfm_ctx(tfm), key, keylen,
+		                       &tfm->crt_flags);
+}
+
+static int ecb_encrypt(struct crypto_tfm *tfm,
+		       struct scatterlist *dst,
+                       struct scatterlist *src, unsigned int nbytes)
+{
+	return crypt(tfm, dst, src, nbytes,
+	             tfm->__crt_alg->cra_cipher.cia_encrypt,
+	             ecb_process, 1, NULL);
+}
+
+static int ecb_decrypt(struct crypto_tfm *tfm,
+                       struct scatterlist *dst,
+                       struct scatterlist *src,
+		       unsigned int nbytes)
+{
+	return crypt(tfm, dst, src, nbytes,
+	             tfm->__crt_alg->cra_cipher.cia_decrypt,
+	             ecb_process, 1, NULL);
+}
+
+static int cbc_encrypt(struct crypto_tfm *tfm,
+                       struct scatterlist *dst,
+                       struct scatterlist *src,
+		       unsigned int nbytes)
+{
+	return crypt(tfm, dst, src, nbytes,
+	             tfm->__crt_alg->cra_cipher.cia_encrypt,
+	             cbc_process, 1, tfm->crt_cipher.cit_iv);
+}
+
+static int cbc_encrypt_iv(struct crypto_tfm *tfm,
+                          struct scatterlist *dst,
+                          struct scatterlist *src,
+                          unsigned int nbytes, u8 *iv)
+{
+	return crypt(tfm, dst, src, nbytes,
+	             tfm->__crt_alg->cra_cipher.cia_encrypt,
+	             cbc_process, 1, iv);
+}
+
+static int cbc_decrypt(struct crypto_tfm *tfm,
+                       struct scatterlist *dst,
+                       struct scatterlist *src,
+		       unsigned int nbytes)
+{
+	return crypt(tfm, dst, src, nbytes,
+	             tfm->__crt_alg->cra_cipher.cia_decrypt,
+	             cbc_process, 0, tfm->crt_cipher.cit_iv);
+}
+
+static int cbc_decrypt_iv(struct crypto_tfm *tfm,
+                          struct scatterlist *dst,
+                          struct scatterlist *src,
+                          unsigned int nbytes, u8 *iv)
+{
+	return crypt(tfm, dst, src, nbytes,
+	             tfm->__crt_alg->cra_cipher.cia_decrypt,
+	             cbc_process, 0, iv);
+}
+
+static int nocrypt(struct crypto_tfm *tfm,
+                   struct scatterlist *dst,
+                   struct scatterlist *src,
+		   unsigned int nbytes)
+{
+	return -ENOSYS;
+}
+
+static int nocrypt_iv(struct crypto_tfm *tfm,
+                      struct scatterlist *dst,
+                      struct scatterlist *src,
+                      unsigned int nbytes, u8 *iv)
+{
+	return -ENOSYS;
+}
+
+int crypto_init_cipher_flags(struct crypto_tfm *tfm, u32 flags)
+{
+	u32 mode = flags & CRYPTO_TFM_MODE_MASK;
+	
+	tfm->crt_cipher.cit_mode = mode ? mode : CRYPTO_TFM_MODE_ECB;
+	if (flags & CRYPTO_TFM_REQ_WEAK_KEY)
+		tfm->crt_flags = CRYPTO_TFM_REQ_WEAK_KEY;
+	
+	return 0;
+}
+
+int crypto_init_cipher_ops(struct crypto_tfm *tfm)
+{
+	int ret = 0;
+	struct cipher_tfm *ops = &tfm->crt_cipher;
+
+	ops->cit_setkey = setkey;
+
+	switch (tfm->crt_cipher.cit_mode) {
+	case CRYPTO_TFM_MODE_ECB:
+		ops->cit_encrypt = ecb_encrypt;
+		ops->cit_decrypt = ecb_decrypt;
+		break;
+		
+	case CRYPTO_TFM_MODE_CBC:
+		ops->cit_encrypt = cbc_encrypt;
+		ops->cit_decrypt = cbc_decrypt;
+		ops->cit_encrypt_iv = cbc_encrypt_iv;
+		ops->cit_decrypt_iv = cbc_decrypt_iv;
+		break;
+		
+	case CRYPTO_TFM_MODE_CFB:
+		ops->cit_encrypt = nocrypt;
+		ops->cit_decrypt = nocrypt;
+		ops->cit_encrypt_iv = nocrypt_iv;
+		ops->cit_decrypt_iv = nocrypt_iv;
+		break;
+	
+	case CRYPTO_TFM_MODE_CTR:
+		ops->cit_encrypt = nocrypt;
+		ops->cit_decrypt = nocrypt;
+		ops->cit_encrypt_iv = nocrypt_iv;
+		ops->cit_decrypt_iv = nocrypt_iv;
+		break;
+
+	default:
+		BUG();
+	}
+	
+	if (ops->cit_mode == CRYPTO_TFM_MODE_CBC) {
+	    	
+	    	switch (crypto_tfm_alg_blocksize(tfm)) {
+	    	case 8:
+	    		ops->cit_xor_block = xor_64;
+	    		break;
+	    		
+	    	case 16:
+	    		ops->cit_xor_block = xor_128;
+	    		break;
+	    		
+	    	default:
+	    		printk(KERN_WARNING "%s: block size %u not supported\n",
+	    		       crypto_tfm_alg_name(tfm),
+	    		       crypto_tfm_alg_blocksize(tfm));
+	    		ret = -EINVAL;
+	    		goto out;
+	    	}
+	    	
+		ops->cit_ivsize = crypto_tfm_alg_blocksize(tfm);
+	    	ops->cit_iv = kmalloc(ops->cit_ivsize, GFP_KERNEL);
+		if (ops->cit_iv == NULL)
+			ret = -ENOMEM;
+	}
+
+out:	
+	return ret;
+}
+
+void crypto_exit_cipher_ops(struct crypto_tfm *tfm)
+{
+	if (tfm->crt_cipher.cit_iv)
+		kfree(tfm->crt_cipher.cit_iv);
+}
diff -ruN rtl8187l_orig/ieee80211/compress.c rtl8187l/ieee80211/compress.c
--- rtl8187l_orig/ieee80211/compress.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/compress.c	2009-06-26 09:07:43.849521000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Cryptographic API.
+ *
+ * Compression operations.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include <linux/types.h>
+#include "rtl_crypto.h"
+#include <linux/errno.h>
+#include <asm/scatterlist.h>
+#include <linux/string.h>
+#include "internal.h"
+
+static int crypto_compress(struct crypto_tfm *tfm,
+                            const u8 *src, unsigned int slen,
+                            u8 *dst, unsigned int *dlen)
+{
+	return tfm->__crt_alg->cra_compress.coa_compress(crypto_tfm_ctx(tfm),
+	                                                 src, slen, dst,
+	                                                 dlen);
+}
+
+static int crypto_decompress(struct crypto_tfm *tfm,
+                             const u8 *src, unsigned int slen,
+                             u8 *dst, unsigned int *dlen)
+{
+	return tfm->__crt_alg->cra_compress.coa_decompress(crypto_tfm_ctx(tfm),
+	                                                   src, slen, dst,
+	                                                   dlen);
+}
+
+int crypto_init_compress_flags(struct crypto_tfm *tfm, u32 flags)
+{
+	return flags ? -EINVAL : 0;
+}
+
+int crypto_init_compress_ops(struct crypto_tfm *tfm)
+{
+	int ret = 0;
+	struct compress_tfm *ops = &tfm->crt_compress;
+	
+	ret = tfm->__crt_alg->cra_compress.coa_init(crypto_tfm_ctx(tfm));
+	if (ret)
+		goto out;
+
+	ops->cot_compress = crypto_compress;
+	ops->cot_decompress = crypto_decompress;
+	
+out:
+	return ret;
+}
+
+void crypto_exit_compress_ops(struct crypto_tfm *tfm)
+{
+	tfm->__crt_alg->cra_compress.coa_exit(crypto_tfm_ctx(tfm));
+}
diff -ruN rtl8187l_orig/ieee80211/digest.c rtl8187l/ieee80211/digest.c
--- rtl8187l_orig/ieee80211/digest.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/digest.c	2009-06-26 09:07:43.849521000 +0200
@@ -0,0 +1,107 @@
+/*
+ * Cryptographic API.
+ *
+ * Digest operations.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include "rtl_crypto.h"
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/highmem.h>
+#include <asm/scatterlist.h>
+#include "internal.h"
+
+static void init(struct crypto_tfm *tfm)
+{
+	tfm->__crt_alg->cra_digest.dia_init(crypto_tfm_ctx(tfm));
+}
+
+static void update(struct crypto_tfm *tfm,
+                   struct scatterlist *sg, unsigned int nsg)
+{
+	unsigned int i;
+
+	for (i = 0; i < nsg; i++) {
+
+		struct page *pg = sg[i].page;
+		unsigned int offset = sg[i].offset;
+		unsigned int l = sg[i].length;
+
+		do {
+			unsigned int bytes_from_page = min(l, ((unsigned int)
+							   (PAGE_SIZE)) - 
+							   offset);
+			char *p = crypto_kmap(pg, 0) + offset;
+
+			tfm->__crt_alg->cra_digest.dia_update
+					(crypto_tfm_ctx(tfm), p,
+					 bytes_from_page);
+			crypto_kunmap(p, 0);
+			crypto_yield(tfm);
+			offset = 0;
+			pg++;
+			l -= bytes_from_page;
+		} while (l > 0);
+	}
+}
+
+static void final(struct crypto_tfm *tfm, u8 *out)
+{
+	tfm->__crt_alg->cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
+}
+
+static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	u32 flags;
+	if (tfm->__crt_alg->cra_digest.dia_setkey == NULL)
+		return -ENOSYS;
+	return tfm->__crt_alg->cra_digest.dia_setkey(crypto_tfm_ctx(tfm),
+						     key, keylen, &flags);
+}
+
+static void digest(struct crypto_tfm *tfm,
+                   struct scatterlist *sg, unsigned int nsg, u8 *out)
+{
+	unsigned int i;
+
+	tfm->crt_digest.dit_init(tfm);
+		
+	for (i = 0; i < nsg; i++) {
+		char *p = crypto_kmap(sg[i].page, 0) + sg[i].offset;
+		tfm->__crt_alg->cra_digest.dia_update(crypto_tfm_ctx(tfm),
+		                                      p, sg[i].length);
+		crypto_kunmap(p, 0);
+		crypto_yield(tfm);
+	}
+	crypto_digest_final(tfm, out);
+}
+
+int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags)
+{
+	return flags ? -EINVAL : 0;
+}
+
+int crypto_init_digest_ops(struct crypto_tfm *tfm)
+{
+	struct digest_tfm *ops = &tfm->crt_digest;
+	
+	ops->dit_init	= init;
+	ops->dit_update	= update;
+	ops->dit_final	= final;
+	ops->dit_digest	= digest;
+	ops->dit_setkey	= setkey;
+	
+	return crypto_alloc_hmac_block(tfm);
+}
+
+void crypto_exit_digest_ops(struct crypto_tfm *tfm)
+{
+	crypto_free_hmac_block(tfm);
+}
diff -ruN rtl8187l_orig/ieee80211/ieee80211_crypt.c rtl8187l/ieee80211/ieee80211_crypt.c
--- rtl8187l_orig/ieee80211/ieee80211_crypt.c	2011-01-02 18:14:30.735583000 +0100
+++ rtl8187l/ieee80211/ieee80211_crypt.c	2009-06-26 09:07:43.849521000 +0200
@@ -11,7 +11,6 @@
  *
  */
 
-//#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -75,8 +74,7 @@
 	if (!list_empty(&ieee->crypt_deinit_list)) {
 		printk(KERN_DEBUG "%s: entries remaining in delayed crypt "
 		       "deletion list\n", ieee->dev->name);
-		ieee->crypt_deinit_timer.expires = jiffies + HZ;
-		add_timer(&ieee->crypt_deinit_timer);
+		mod_timer(&ieee->crypt_deinit_timer, jiffies + HZ);
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 
@@ -101,8 +99,7 @@
 	spin_lock_irqsave(&ieee->lock, flags);
 	list_add(&tmp->list, &ieee->crypt_deinit_list);
 	if (!timer_pending(&ieee->crypt_deinit_timer)) {
-		ieee->crypt_deinit_timer.expires = jiffies + HZ;
-		add_timer(&ieee->crypt_deinit_timer);
+		mod_timer(&ieee->crypt_deinit_timer, jiffies + HZ);
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
diff -ruN rtl8187l_orig/ieee80211/ieee80211_crypt_ccmp.c rtl8187l/ieee80211/ieee80211_crypt_ccmp.c
--- rtl8187l_orig/ieee80211/ieee80211_crypt_ccmp.c	2011-01-02 18:14:30.739614000 +0100
+++ rtl8187l/ieee80211/ieee80211_crypt_ccmp.c	2009-06-26 09:07:43.853534000 +0200
@@ -9,7 +9,6 @@
  * more details.
  */
 
-//#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -35,7 +34,6 @@
     #include <linux/scatterlist.h>
 #endif
 
-//#include <asm/scatterlist.h>
 
 MODULE_AUTHOR("Jouni Malinen");
 MODULE_DESCRIPTION("Host AP crypt: CCMP");
@@ -170,7 +168,6 @@
 	qc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&
 		       (WLAN_FC_GET_STYPE(fc) & 0x08));
         */		       
-	// fixed by David :2006.9.6
 	qc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&
 		       (WLAN_FC_GET_STYPE(fc) & 0x80));
 	aad_len = 22;
@@ -254,7 +251,6 @@
 	pos = skb_push(skb, CCMP_HDR_LEN);
 	memmove(pos, pos + CCMP_HDR_LEN, hdr_len);
 	pos += hdr_len;
-//	mic = skb_put(skb, CCMP_MIC_LEN);
 
 	i = CCMP_PN_LEN - 1;
 	while (i >= 0) {
@@ -275,7 +271,6 @@
 
 	hdr = (struct ieee80211_hdr *) skb->data;
 #ifndef JOHN_CCMP
-	//mic is moved to here by john
 	mic = skb_put(skb, CCMP_MIC_LEN);
 	
 	ccmp_init_blocks(key->tfm, hdr, key->tx_pn, data_len, b0, b, s0);
@@ -482,7 +477,6 @@
 
 void ieee80211_ccmp_null(void)
 {
-  //  printk("============>%s()\n", __FUNCTION__);
 	return;
 }
 static struct ieee80211_crypto_ops ieee80211_crypt_ccmp = {
diff -ruN rtl8187l_orig/ieee80211/ieee80211_crypt_tkip.c rtl8187l/ieee80211/ieee80211_crypt_tkip.c
--- rtl8187l_orig/ieee80211/ieee80211_crypt_tkip.c	2011-01-02 18:14:30.739614000 +0100
+++ rtl8187l/ieee80211/ieee80211_crypt_tkip.c	2009-06-26 09:07:43.853534000 +0200
@@ -9,7 +9,6 @@
  * more details.
  */
 
-//#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -28,7 +27,6 @@
 #else
 #include <linux/crypto.h>
 #endif
-//#include <asm/scatterlist.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20) 
     #include <asm/scatterlist.h>
 #else
@@ -585,7 +583,6 @@
 	skb_pull(skb, 8);
 	skb_trim(skb, skb->len - 4);
 
-//john's test
 #ifdef JOHN_DUMP 
 if( ((u16*)skb->data)[0] & 0x4000){
         printk("@@ rx decrypted skb->data");
@@ -621,12 +618,7 @@
 	sg[1].offset = offset_in_page(data);
 	sg[1].length = data_len;
 
-	//crypto_digest_init(tkey->tfm_michael);
-	//crypto_digest_setkey(tkey->tfm_michael, key, 8);
-	//crypto_digest_update(tkey->tfm_michael, sg, 2);
-	//crypto_digest_final(tkey->tfm_michael, mic);
 
-	//return 0;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
 	crypto_digest_init(tkey->tfm_michael);
 	crypto_digest_setkey(tkey->tfm_michael, key, 8);
@@ -638,7 +630,6 @@
 if (crypto_hash_setkey(tkey->tfm_michael, key, 8))
 		return -1;
  
-//	return 0;
 	desc.tfm = tkey->tfm_michael;
 	desc.flags = 0;
 	ret = crypto_hash_digest(&desc, sg, data_len + 16, mic);
@@ -729,12 +720,9 @@
 	michael_mic_hdr(skb, tkey->tx_hdr);
 
 #if 0
-	// { david, 2006.9.1
-	// fix the wpa process with wmm enabled.
 	if(IEEE80211_QOS_HAS_SEQ(le16_to_cpu(hdr->frame_ctl))) {
 		tkey->tx_hdr[12] = *(skb->data + hdr_len - 2) & 0x07;
 	}
-	// }
 #endif
 	pos = skb_put(skb, 8);
         #if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
@@ -810,13 +798,10 @@
 
 	michael_mic_hdr(skb, tkey->rx_hdr);
 #if 0
-	// { david, 2006.9.1
-	// fix the wpa process with wmm enabled.
 	if(IEEE80211_QOS_HAS_SEQ(le16_to_cpu(hdr->frame_ctl))) {
 		tkey->rx_hdr[12] = *(skb->data + hdr_len - 2) & 0x07;
 	}
 #endif
-	// }
         #if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))	
 	if (michael_mic(tkey, &tkey->key[24], tkey->rx_hdr,
 			skb->data + hdr_len, skb->len - 8 - hdr_len, mic))
@@ -983,7 +968,6 @@
 
 void ieee80211_tkip_null(void)
 {
-//    printk("============>%s()\n", __FUNCTION__);
         return;
 }
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
diff -ruN rtl8187l_orig/ieee80211/ieee80211_crypt_wep.c rtl8187l/ieee80211/ieee80211_crypt_wep.c
--- rtl8187l_orig/ieee80211/ieee80211_crypt_wep.c	2011-01-02 18:14:30.735583000 +0100
+++ rtl8187l/ieee80211/ieee80211_crypt_wep.c	2009-06-26 09:07:43.853534000 +0200
@@ -9,7 +9,6 @@
  * more details.
  */
 
-//#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -31,7 +30,6 @@
 #else
     #include <linux/scatterlist.h>
 #endif
-//#include <asm/scatterlist.h>
 #include <linux/crc32.h>
 
 MODULE_AUTHOR("Jouni Malinen");
@@ -368,7 +366,6 @@
 
 void ieee80211_wep_null(void)
 {
-//	printk("============>%s()\n", __FUNCTION__);
         return;
 }
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
diff -ruN rtl8187l_orig/ieee80211/ieee80211.h rtl8187l/ieee80211/ieee80211.h
--- rtl8187l_orig/ieee80211/ieee80211.h	2011-01-02 18:14:30.739614000 +0100
+++ rtl8187l/ieee80211/ieee80211.h	2009-06-26 09:07:43.849521000 +0200
@@ -35,35 +35,27 @@
 #endif
 #include <linux/timer.h>
 #include <linux/sched.h>
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13))
+#include <linux/delay.h>
 #include <linux/wireless.h>
-#endif
-/*
-#ifndef bool
-#define bool int
-#endif
 
-#ifndef true
-#define true   1
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#define jiffies_to_msecs(t)  ((t) * 1000 / HZ)
+#ifndef __bitwise
+#define __bitwise __attribute__((bitwise))
 #endif
-
-#ifndef false
-#define false  0
+typedef __u16  __le16;
 #endif
-*/
+
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
 #ifndef bool
 typedef enum{false = 0, true} bool;
 #endif
 #endif
-//#ifdef JOHN_HWSEC
 #define KEY_TYPE_NA		0x0
 #define KEY_TYPE_WEP40 		0x1
 #define KEY_TYPE_TKIP		0x2
 #define KEY_TYPE_CCMP		0x4
 #define KEY_TYPE_WEP104		0x5
-//#endif
 
 
 #define aSifsTime					10
@@ -85,15 +77,9 @@
 #define IEEE_PARAM_PRIVACY_INVOKED		4
 #define IEEE_PARAM_AUTH_ALGS			5
 #define IEEE_PARAM_IEEE_802_1X			6
-//It should consistent with the driver_XXX.c
-//   David, 2006.9.26
 #define IEEE_PARAM_WPAX_SELECT			7
-//Added for notify the encryption type selection
-//   David, 2006.9.26
 #define IEEE_PROTO_WPA				1	
 #define IEEE_PROTO_RSN				2
-//Added for notify the encryption type selection
-//   David, 2006.9.26
 #define IEEE_WPAX_USEGROUP			0
 #define IEEE_WPAX_WEP40				1
 #define IEEE_WPAX_TKIP				2
@@ -120,17 +106,12 @@
 
 #define	IEEE_CRYPT_ALG_NAME_LEN			16
 
-//#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10))
 #define ieee80211_wx_get_scan ieee80211_wx_get_scan_rtl
 #define ieee80211_wx_set_encode ieee80211_wx_set_encode_rtl
 #define ieee80211_wx_get_encode ieee80211_wx_get_encode_rtl
-////////////////////////////////
-// added for kernel conflict under FC5
 #define ieee80211_wx_get_name   ieee80211_wx_get_name_rtl
 #define free_ieee80211          free_ieee80211_rtl
 #define alloc_ieee80211        	alloc_ieee80211_rtl
-///////////////////////////////
-//#endif
 #define ieee80211_rx ieee80211_rx_rtl
 #define ieee80211_wake_queue ieee80211_wake_queue_rtl
 #define ieee80211_stop_queue ieee80211_stop_queue_rtl
@@ -224,15 +205,12 @@
 {
 	task->routine = func;
 	task->data 	= data;
-	//task->next = NULL;
 	INIT_LIST_HEAD(&task->list);
 	task->sync = 0;
 }
 #endif
 
-// linux under 2.6.9 release may not support it, so modify it for common use
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9))
-//#define MSECS(t)	(1000 * ((t) / HZ) + 1000 * ((t) % HZ) / HZ)
 #define MSECS(t)	(HZ * ((t) / 1000) + HZ * ((t) % 1000) / 1000)
 static inline unsigned long msleep_interruptible_rtl(unsigned int msecs)
 {
@@ -341,7 +319,6 @@
 	EAPOL_ENCAP_ASF_ALERT
 };
 
-//by lizhaoming for LED 2008.6.23 from r8187_led.h
 #ifdef LED
 typedef enum _LED_CTL_MODE {
 	LED_CTL_POWER_ON,
@@ -388,7 +365,7 @@
 #define IEEE80211_FCTL_STYPE		0x00f0
 #define IEEE80211_FCTL_TODS		0x0100
 #define IEEE80211_FCTL_FROMDS		0x0200
-#define IEEE80211_FCTL_DSTODS		0x0300 //added by david
+#define IEEE80211_FCTL_DSTODS		0x0300 
 #define IEEE80211_FCTL_MOREFRAGS	0x0400
 #define IEEE80211_FCTL_RETRY		0x0800
 #define IEEE80211_FCTL_PM		0x1000
@@ -431,7 +408,7 @@
 #define IEEE80211_STYPE_CFACK		0x0050
 #define IEEE80211_STYPE_CFPOLL		0x0060
 #define IEEE80211_STYPE_CFACKPOLL	0x0070
-#define IEEE80211_STYPE_QOS_DATA	0x0080 //added for WMM 2006/8/2
+#define IEEE80211_STYPE_QOS_DATA	0x0080 
 #define IEEE80211_STYPE_QOS_NULL	0x00C0
 
 
@@ -440,7 +417,6 @@
 
 
 /* debug macros */
-//#define CONFIG_IEEE80211_DEBUG
 #ifdef CONFIG_IEEE80211_DEBUG
 extern u32 ieee80211_debug_level;
 #define IEEE80211_DEBUG(level, fmt, args...) \
@@ -507,9 +483,9 @@
 #include <linux/if_arp.h> /* ARPHRD_ETHER */
 
 #ifndef WIRELESS_SPY
-#define WIRELESS_SPY		// enable iwspy support
+#define WIRELESS_SPY		
 #endif
-#include <net/iw_handler.h>	// new driver API
+#include <net/iw_handler.h>	
 
 #ifndef ETH_P_PAE
 #define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
@@ -863,7 +839,6 @@
 	u16 algorithm;
 	u16 transaction;
 	u16 status;
-	//struct ieee80211_info_element_hdr info_element;
 } __attribute__ ((packed));
 
 
@@ -884,7 +859,6 @@
 	struct ieee80211_hdr_3addr header;
 	u16 capability;
 	u16 listen_interval;
-	//u8 current_ap[ETH_ALEN];
 	struct ieee80211_info_element_hdr info_element;
 } __attribute__ ((packed));
 
@@ -959,8 +933,7 @@
 	u8	Len;
 }CHANNEL_LIST, *PCHANNEL_LIST;
 
-#define IEEE80211_SOFTMAC_SCAN_TIME	  400
-//(HZ / 2)
+#define IEEE80211_SOFTMAC_SCAN_TIME	  100
 #define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
 
 #define CRC_LENGTH                 4U
@@ -980,8 +953,6 @@
 #define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
 #define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
 
-//added by David for QoS 2006/6/30
-//#define WMM_Hang_8187
 #ifdef WMM_Hang_8187
 #undef WMM_Hang_8187
 #endif
@@ -994,15 +965,12 @@
 #define WME_AIFSN_MASK 0x03
 #define WME_AC_PRAM_LEN 16
 
-//UP Mapping to AC, using in MgntQuery_SequenceNumber() and maybe for DSCP
-//#define UP2AC(up)	((up<3) ? ((up==0)?1:0) : (up>>1)) 
 #define UP2AC(up) (		   \
 	((up) < 1) ? WME_AC_BE : \
 	((up) < 3) ? WME_AC_BK : \
 	((up) < 4) ? WME_AC_BE : \
 	((up) < 6) ? WME_AC_VI : \
 	WME_AC_VO)	
-//AC Mapping to UP, using in Tx part for selecting the corresponding TX queue
 #define AC2UP(_ac)	(       \
 	((_ac) == WME_AC_VO) ? 6 : \
 	((_ac) == WME_AC_VI) ? 5 : \
@@ -1054,14 +1022,11 @@
 	u8 dtim_data;
 	u32 last_dtim_sta_time[2];
 	struct list_head list;
-	//appeded for QoS
 	u8 wmm_info;
 	struct ieee80211_wmm_ac_param wmm_param[4];
 	u8 QoS_Enable;
 	u8 SignalStrength;
-//#ifdef THOMAS_TURBO
-	u8 Turbo_Enable;//enable turbo mode, added by thomas
-//#endif
+	u8 Turbo_Enable;
 
 };
 
@@ -1177,16 +1142,14 @@
 	size_t wpa_ie_len;
 	u8 *wpa_ie;
 
-//#ifdef JOHN_TKIP
 	u8 ap_mac_addr[6];
 	u16 pairwise_key_type;
 	u16 broadcast_key_type;
-//#endif
 	struct list_head crypt_deinit_list;
 	struct ieee80211_crypt_data *crypt[WEP_KEYS];
 	int tx_keyidx; /* default TX key index (crypt[tx_keyidx]) */
 	struct timer_list crypt_deinit_timer;
-	int crypt_quiesced;//add by lawrence ,0626
+	int crypt_quiesced;
 
 	int bcrx_sta_key; /* use individual keys to override default keys even
 			   * with RX of broad/multicast frames */
@@ -1197,7 +1160,6 @@
 	unsigned int frag_next_idx;
 	u16 fts; /* Fragmentation Threshold */
 	
-	//added by david. 2007.1.31
 	/* Fragmentation structure for Tx process */
 	struct ieee80211_txb  *alloc_txb[MAX_TX_SKB];
 	unsigned int tx_skb_index;
@@ -1228,12 +1190,10 @@
 	short sync_scan_hurryup; 
 	
 	/* map of allowed channels. 0 is dummy */
-	// FIXME: remeber to default to a basic channel plan depending of the PHY type
 	int channel_map[MAX_CHANNEL_NUMBER+1];
 	
 	int rate;       /* current rate */
 	int basic_rate;
-	//FIXME: pleace callback, see if redundant with softmac_features
 	short active_scan;
 	
 	/* this contains flags for selectively enable softmac support */
@@ -1274,8 +1234,8 @@
 	short wap_set;
 	short ssid_set;
 	
-	u8  wpax_type_set;    //{added by David, 2006.9.28}
-	u32 wpax_type_notify; //{added by David, 2006.9.26}
+	u8  wpax_type_set;    
+	u32 wpax_type_notify; 
 
 	/* QoS related flag */
 	char init_wmmparam_flag;
@@ -1295,13 +1255,11 @@
 	struct sk_buff *mgmt_queue_ring[MGMT_QUEUE_NUM];
 	int mgmt_queue_head;
 	int mgmt_queue_tail;
-//by amy for ps
 	bool bInactivePs;
 	bool actscanning;
 	bool beinretry;
 	u16 ListenInterval;
 	u32 NumRxData;
-//by amy for ps		
 	
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
 	struct  tx_pending_t tx_pending;
@@ -1311,17 +1269,11 @@
 
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
-	struct work_struct associate_complete_wq;
-	//struct work_struct associate_retry_wq;
-//	struct work_struct start_ibss_wq;
-	struct work_struct associate_procedure_wq;
 
-	//lzm add for radio on/off 080917
 	bool bHwRadioOff;
-	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)	
-//lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	struct delayed_work GPIOChangeRFWorkItem;
 #endif
@@ -1333,14 +1285,11 @@
 	struct delayed_work softmac_scan_wq;
 	struct delayed_work start_ibss_wq;
 	struct delayed_work associate_retry_wq;
-//by amy for rate adaptive
         struct delayed_work rate_adapter_wq;
-//by amy for rate adaptive
 	struct delayed_work watch_dog_wq;
 	struct delayed_work hw_dig_wq;
 	struct delayed_work tx_pw_wq;
 #else
-//lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	struct work_struct GPIOChangeRFWorkItem;
 #endif
@@ -1352,37 +1301,49 @@
 	struct work_struct softmac_scan_wq;
 	struct work_struct start_ibss_wq;
 	struct work_struct associate_retry_wq;
-//by amy for rate adaptive
-                struct work_struct rate_adapter_wq;
-//by amy for rate adaptive
+        struct work_struct rate_adapter_wq;
 	struct work_struct watch_dog_wq;
 	struct work_struct hw_dig_wq;
 	struct work_struct tx_pw_wq;
 #endif	
 
-//struct work_struct softmac_scan_wq;
+	struct work_struct associate_complete_wq;
+	struct work_struct associate_procedure_wq;
  	struct work_struct wx_sync_scan_wq;
-	//struct work_struct wxsync_scan_wq;//for a test
-	struct work_struct ps_request_tx_ack_wq;//for ps
+	struct work_struct ps_request_tx_ack_wq;
 	struct work_struct hw_wakeup_wq;
 	struct work_struct hw_sleep_wq;
-       // struct work_struct rx_handle_wq;	
-
-	struct work_struct wmm_param_update_wq;
 	struct workqueue_struct *wq;
-#else
-	/* used for periodly scan */
-	struct timer_list scan_timer;
+	
+#else 
 
-	struct tq_struct associate_complete_wq;
-	struct tq_struct associate_retry_wq;
+#ifdef POLLING_METHOD_FOR_RADIO
+	struct tq_struct GPIOChangeRFWorkItem;
+#endif
+
+#ifdef SW_ANTE_DIVERSITY
+	struct tq_struct SwAntennaWorkItem;
+#endif
+
+	struct tq_struct softmac_scan_wq;
 	struct tq_struct start_ibss_wq;
+	struct tq_struct associate_retry_wq;
+        struct tq_struct rate_adapter_wq;
+	struct tq_struct watch_dog_wq;
+	struct tq_struct hw_dig_wq;
+	struct tq_struct tx_pw_wq;
+	
+	struct tq_struct associate_complete_wq;
 	struct tq_struct associate_procedure_wq;
-	struct tq_struct softmac_scan_wq;
 	struct tq_struct wx_sync_scan_wq;
-	struct tq_struct wmm_param_update_wq;
+	struct tq_struct ps_request_tx_ack_wq;
+	struct tq_struct hw_wakeup_wq;
+	struct tq_struct hw_sleep_wq;
 #endif
 
+	/* used for periodly scan */
+	struct timer_list scan_timer;
+
 	/* Callback functions */
 	void (*set_security)(struct net_device *dev,
 			     struct ieee80211_security *sec);
@@ -1471,13 +1432,10 @@
 	void (*enter_sleep_state) (struct net_device *dev, u32 th, u32 tl);
 	short (*ps_is_queue_empty) (struct net_device *dev);
 	
-//by lizhaoming for LED 2008.6.23
 #ifdef LED
 	void (*ieee80211_led_contorl) (struct net_device *dev, LED_CTL_MODE LedAction);
 #endif
 	/* QoS related */
-	//void (*wmm_param_update) (struct net_device *dev, u8 *ac_param);
-	//void (*wmm_param_update) (struct ieee80211_device *ieee);
 
 	
 	/* This must be the last item so that it points to the data
@@ -1640,6 +1598,7 @@
 extern int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
 				   struct iw_request_info *info,
 				   union iwreq_data *wrqu, char *key);
+#if WIRELESS_EXT >= 18
 extern int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
                             struct iw_request_info *info,
                             union iwreq_data* wrqu, char *extra);
@@ -1649,8 +1608,10 @@
 int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra);
+#endif
 
 int ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len);
+
 /* ieee80211_softmac.c */
 extern short ieee80211_is_54g(struct ieee80211_network net);
 extern short ieee80211_is_shortslot(struct ieee80211_network net);
@@ -1731,7 +1692,6 @@
 extern int ieee80211_wx_get_freq(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-//extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void ieee80211_wx_sync_scan_wq(struct work_struct *work);
 #else
diff -ruN rtl8187l_orig/ieee80211/ieee80211_module.c rtl8187l/ieee80211/ieee80211_module.c
--- rtl8187l_orig/ieee80211/ieee80211_module.c	2011-01-02 18:14:30.739614000 +0100
+++ rtl8187l/ieee80211/ieee80211_module.c	2009-06-26 09:07:43.853534000 +0200
@@ -31,7 +31,6 @@
 *******************************************************************************/
 
 #include <linux/compiler.h>
-//#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>
 #include <linux/in6.h>
@@ -116,8 +115,11 @@
 		goto failed;
 	}
 	
-	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 
 	ieee = netdev_priv(dev);
+#else
+	ieee = (struct ieee80211_device *)dev->priv;
+#endif
 	dev->hard_start_xmit = ieee80211_xmit;
 
 	ieee->dev = dev;
@@ -187,14 +189,22 @@
 	
  failed:
 	if (dev)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))	
 		free_netdev(dev);
+#else
+		kfree(dev);
+#endif
 	return NULL;
 }
 
 
 void free_ieee80211(struct net_device *dev)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 
 	struct ieee80211_device *ieee = netdev_priv(dev);
+#else
+	struct ieee80211_device *ieee = (struct ieee80211_device *)dev->priv;
+#endif
 
 	int i;
 	struct list_head *p, *q;
@@ -215,7 +225,11 @@
 		if (crypt) {
 			if (crypt->ops) {
 				crypt->ops->deinit(crypt->priv);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)	
 				module_put(crypt->ops->owner);
+#else
+				__MOD_DEC_USE_COUNT(crypt->ops->owner);
+#endif
 			}
 			kfree(crypt);
 			ieee->crypt[i] = NULL;
@@ -232,7 +246,11 @@
 	}
 
 	
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))	
 	free_netdev(dev);
+#else
+	kfree(dev);
+#endif
 }
 
 #ifdef CONFIG_IEEE80211_DEBUG
@@ -308,6 +326,7 @@
 	}
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
 MODULE_PARM_DESC(debug, "debug output mask");
@@ -317,5 +336,13 @@
 module_init(ieee80211_init);
 #endif
 
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(alloc_ieee80211);
 EXPORT_SYMBOL(free_ieee80211);
+#else
+EXPORT_SYMBOL_NOVERS(alloc_ieee80211);
+EXPORT_SYMBOL_NOVERS(free_ieee80211);
+#endif
+
diff -ruN rtl8187l_orig/ieee80211/ieee80211_rx.c rtl8187l/ieee80211/ieee80211_rx.c
--- rtl8187l_orig/ieee80211/ieee80211_rx.c	2011-01-02 18:14:30.744091000 +0100
+++ rtl8187l/ieee80211/ieee80211_rx.c	2009-06-26 09:07:43.853534000 +0200
@@ -22,7 +22,6 @@
  
 
 #include <linux/compiler.h>
-//#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>
 #include <linux/in6.h>
@@ -201,7 +200,7 @@
 	rx_stats->len = skb->len;
 	ieee80211_rx_mgt(ieee,(struct ieee80211_hdr *)skb->data,rx_stats);	
 
-	if ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN)))//use ADDR1 to perform address matching for Management frames
+	if ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN)))
 	{
 		dev_kfree_skb_any(skb);
 		return 0;
@@ -389,7 +388,6 @@
 static int is_duplicate_packet(struct ieee80211_device *ieee,
 				      struct ieee80211_hdr *header)
 {
-//	u16 fc = le16_to_cpu(header->frame_ctl);
 	u16 sc = le16_to_cpu(header->seq_ctl);
 	u16 seq = WLAN_GET_SEQ_SEQ(sc);
 	u16 frag = WLAN_GET_SEQ_FRAG(sc);
@@ -403,13 +401,11 @@
 		struct ieee_ibss_seq *entry = NULL;
 		u8 *mac = header->addr2;
 		int index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;
-		//for (pos = (head)->next; pos != (head); pos = pos->next)
-		__list_for_each(p, &ieee->ibss_mac_hash[index]) {
+		list_for_each(p, &ieee->ibss_mac_hash[index]) {
 			entry = list_entry(p, struct ieee_ibss_seq, list);
 			if (!memcmp(entry->mac, mac, ETH_ALEN))
 				break;
 		}
-	//	if (memcmp(entry->mac, mac, ETH_ALEN)){
 		if (p == &ieee->ibss_mac_hash[index]) {
 			entry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);
 			if (!entry) {
@@ -437,7 +433,6 @@
 	default:
 		return 0;
 	}
-//	printk("%x %x\n",*last_seq, seq);
 	if ((*last_seq == seq) &&
 	    time_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {
 		if (*last_frag == frag)
@@ -453,8 +448,6 @@
 	return 0;
 
 drop:
-//	BUG_ON(!(fc & IEEE80211_FCTL_RETRY));
-//	printk("DUP\n");
 	
 	return 1;
 }
@@ -698,8 +691,6 @@
 	hdr = (struct ieee80211_hdr *) skb->data;
 
 	/* skb: hdr + (possibly fragmented) plaintext payload */
-	// PR: FIXME: hostap hdas additional conditions in the "if" below:
-	// ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&
 	if ((frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {
 		int flen;
 		struct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);
@@ -906,9 +897,7 @@
 		netif_rx(skb);
 	}
 
-//by lizhaoming for LED_RX 2008.6.23
 #ifdef LED_SHIN
-//		printk("==================>data rcvd\n");
 		ieee->ieee80211_led_contorl(dev,LED_CTL_RX);
 #endif
 
@@ -947,22 +936,15 @@
 }
 
 
-//
-//	Description:
-//		Translate 0-100 signal strength index into dBm.
-//
 int 
 TranslateToDbm8187(
-	unsigned char SignalStrengthIndex	// 0-100 index.
+	unsigned char SignalStrengthIndex	
 	)
 {
-	unsigned char SignalPower; // in dBm.
+	unsigned char SignalPower; 
 
-	// Translate to dBm (x=0.5y-95).
-	//SignalPower = (int)((SignalStrengthIndex + 1) >> 1); 
 	SignalPower = (int)SignalStrengthIndex * 7 / 10; 
 	SignalPower -= 95; 
-//	printk("==>SignalPower:%d\n", SignalPower);
 	return SignalPower;
 }
 
@@ -972,7 +954,6 @@
 {
 	int RetSS;
 
-	// Step 1. Scale mapping. 
 	if(CurrSS >= 71 && CurrSS <= 100)
 	{
 		RetSS = 95 + (((CurrSS - 70) / 6 == 5) ? 5 : ((CurrSS - 70) / 6 + 1));
@@ -1013,11 +994,8 @@
 	{
 		RetSS = CurrSS; 
 	}
-	//RT_TRACE(COMP_DBG, DBG_LOUD, ("##### After Mapping:  LastSS: %d, CurrSS: %d, RetSS: %d\n", LastSS, CurrSS, RetSS));
 
-	// Step 2. Smoothing.
 	
-	//RT_TRACE(COMP_DBG, DBG_LOUD, ("$$$$$ After Smoothing:  LastSS: %d, CurrSS: %d, RetSS: %d\n", LastSS, CurrSS, RetSS));
 
 	return RetSS;
 }
@@ -1174,7 +1152,6 @@
 				
 			offset = (info_element->data[2] >> 1)*2;
 			
-//			printk("offset1:%d aid:%d\n",offset, ieee->assoc_id); 
 		
 			if(ieee->assoc_id < 8*offset || 
 				ieee->assoc_id > 8*(offset + info_element->len -3))
@@ -1182,14 +1159,10 @@
 				break;
 			
 			
-			offset = ieee->assoc_id / 8 -offset;// + ((aid % 8)? 0 : 1) ;
+			offset = ieee->assoc_id / 8 -offset;
 			
-//			printk("offset:%x data:%x, ucast:%d\n", offset, 
-//				info_element->data[3+offset] ,
-//				info_element->data[3+offset] & (1<<(ieee->assoc_id%8)));
 				
 			if(info_element->data[3+offset] & (1<<(ieee->assoc_id%8))) {
-//				printk(KERN_INFO "UCAST!\n");
 				network->dtim_data |= IEEE80211_DTIM_UCAST;}
 				
 			break;
@@ -1261,10 +1234,7 @@
 		network->flags |= NETWORK_EMPTY_ESSID;
 
 #if 1
-	//if(strcmp(network->ssid, "linksys_lzm000") == 0)
-	//	printk("----signalstrength = %d   ", stats->signalstrength);
 	stats->signal = TranslateToDbm8187(stats->signalstrength);
-	//stats->noise = stats->signal - stats->noise;
 	stats->noise = TranslateToDbm8187(100 - stats->signalstrength) - 25;
 #endif
 	memcpy(&network->stats, stats, sizeof(network->stats));
@@ -1280,12 +1250,10 @@
 	 * and the capability field (in particular IBSS and BSS) all match.  
 	 * We treat all <hidden> with the same BSSID and channel
 	 * as one network */
-	return (((src->ssid_len == dst->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&  //YJ,mod,080819,for hidden ap
-//	return ((src->ssid_len == dst->ssid_len) &&
+	return (((src->ssid_len == dst->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&  
 		(src->channel == dst->channel) &&
 		!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
-		(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) && //YJ,mod,080819,for hidden ap
-//		!memcmp(src->ssid, dst->ssid, src->ssid_len) &&
+		(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) && 
 		((src->capability & WLAN_CAPABILITY_IBSS) == 
 		(dst->capability & WLAN_CAPABILITY_IBSS)) &&
 		((src->capability & WLAN_CAPABILITY_BSS) == 
@@ -1302,11 +1270,8 @@
                 quality = (dst->stats.signalstrength * 5 + src->stats.signalstrength + 5)/6;
         }
 	signal = TranslateToDbm8187(quality);
-	//noise = signal - src->stats.noise;
 	if(dst->stats.noise > 0)
 		noise = (dst->stats.noise * 5 + src->stats.noise)/6;
-        //if(strcmp(dst->ssid, "linksys_lzm000") == 0)
-//	printk("ssid:%s, quality:%d, signal:%d\n", dst->ssid, quality, signal);
 	memcpy(&dst->stats, &src->stats, sizeof(struct ieee80211_rx_stats));
 	dst->stats.signalstrength = quality;
 	dst->stats.signal = signal;
@@ -1317,16 +1282,12 @@
 	memcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);
 	dst->rates_ex_len = src->rates_ex_len;
 
-	//YJ,add,080819,for hidden ap
 	if(src->ssid_len > 0)
 	{
-		//if(src->ssid_len == 13)
-		//	printk("=====================>>>>>>>> Dst ssid: %s Src ssid: %s\n", dst->ssid, src->ssid);
 		memset(dst->ssid, 0, dst->ssid_len);
 		dst->ssid_len = src->ssid_len;
 		memcpy(dst->ssid, src->ssid, src->ssid_len);
 	}
-	//YJ,add,080819,for hidden ap,end
 
 	dst->mode = src->mode;
 	dst->flags = src->flags;
@@ -1349,9 +1310,7 @@
 	dst->last_scanned = jiffies;
 	/* dst->last_associate is not overwritten */
 	dst->SignalStrength = src->SignalStrength;
-//#ifdef THOMAS_TURBO
 	dst->Turbo_Enable = src->Turbo_Enable;
-//#endif
 }
 
 static inline void ieee80211_process_probe_response(
@@ -1367,7 +1326,7 @@
 #endif
 	unsigned long flags;
 	short renew;
-	u8 is_beacon = (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == IEEE80211_STYPE_BEACON)? 1:0;  //YJ,add,080819,for hidden ap
+	u8 is_beacon = (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == IEEE80211_STYPE_BEACON)? 1:0;  
 
 	IEEE80211_DEBUG_SCAN(
 		"'%s' (" MAC_FMT "): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",
@@ -1414,14 +1373,10 @@
 	spin_lock_irqsave(&ieee->lock, flags);
 	
 	if(is_same_network(&ieee->current_network, &network, ieee)){
-		//DMESG("Is the same network");
 
-		//YJ,add,080819,for hidden ap
 		if(is_beacon == 0)
 			network.flags = (~NETWORK_EMPTY_ESSID & network.flags)|(NETWORK_EMPTY_ESSID & ieee->current_network.flags);
 		else if(ieee->state == IEEE80211_LINKED)
-			//ieee->NumRxBcnInPeriod++;//lzm del 0925 for 87l
-		//YJ,add,080819,for hidden ap,end
 		
 		update_network(&ieee->current_network, &network);
 	}
@@ -1466,7 +1421,6 @@
 #endif
 		memcpy(target, &network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
-		//DMESG("softmac features is %x",ieee->softmac_features);				     
 		if(ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
 			ieee80211_softmac_new_net(ieee,&network); 
 	} else {
@@ -1484,18 +1438,13 @@
 		 */
 		renew = !time_after(target->last_scanned + ieee->scan_age, jiffies);
 
-		//YJ,add,080819,for hidden ap
 		if(is_beacon == 0)
 			network.flags = (~NETWORK_EMPTY_ESSID & network.flags)|(NETWORK_EMPTY_ESSID & target->flags);
-		//if(strncmp(network.ssid, "linksys-c",9) == 0)
-		//	printk("====>2 network.ssid=%s FLAG=%d target.ssid=%s FLAG=%d\n", network.ssid, network.flags, target->ssid, target->flags);
 		if(((network.flags & NETWORK_EMPTY_ESSID) == NETWORK_EMPTY_ESSID) \
 		    && (((network.ssid_len > 0) && (strncmp(target->ssid, network.ssid, network.ssid_len)))\
 		    ||((ieee->current_network.ssid_len == network.ssid_len)&&(strncmp(ieee->current_network.ssid, network.ssid, network.ssid_len) == 0)&&(ieee->state == IEEE80211_NOLINK))))
 			renew = 1;
-		//YJ,add,080819,for hidden ap,end
 		
-		//	DMESG("softmac features is %x,renew=%x",ieee->softmac_features,renew);	
 		update_network(target, &network);
 		if(renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))
 		{	
@@ -1531,6 +1480,10 @@
 	}
 }
 
-
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_rx_mgt);
 EXPORT_SYMBOL(ieee80211_rx);
+#else
+EXPORT_SYMBOL_NOVERS(ieee80211_rx_mgt);
+EXPORT_SYMBOL_NOVERS(ieee80211_rx);
+#endif
diff -ruN rtl8187l_orig/ieee80211/ieee80211_softmac.c rtl8187l/ieee80211/ieee80211_softmac.c
--- rtl8187l_orig/ieee80211/ieee80211_softmac.c	2011-01-02 18:14:30.735583000 +0100
+++ rtl8187l/ieee80211/ieee80211_softmac.c	2009-06-26 09:07:43.853534000 +0200
@@ -19,6 +19,8 @@
 #include <linux/random.h>
 #include <linux/delay.h>
 #include <linux/version.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
 
 #define RTL8187_MODULE_NAME "ieee80211"
 #define DMESG(x,a...) printk(KERN_INFO RTL8187_MODULE_NAME ": " x "\n", ## a)
@@ -108,7 +110,7 @@
  *	
  * if (nh == ieee->mgmt_queue_tail)
  *		return -1;
- */	//david, 2007.1.23
+ */	
 	if (nh == ieee->mgmt_queue_tail) {
 		dev_kfree_skb_any(skb);
 	} else {
@@ -116,7 +118,6 @@
 		ieee->mgmt_queue_ring[nh] = skb;
 	}
 	
-	//return 0;
 }
 
 struct sk_buff *dequeue_mgmt(struct ieee80211_device *ieee)
@@ -172,7 +173,6 @@
 			/* avoid watchdog triggers */
 			ieee->dev->trans_start = jiffies;
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
-			//added by david, 2007.1.23
 			dev_kfree_skb_any(skb);
 		}
 		
@@ -249,10 +249,10 @@
 	
 	req = (struct ieee80211_probe_request *) skb_put(skb,sizeof(struct ieee80211_probe_request));
 	if (ieee->ps == IEEE80211_PS_DISABLED) 
-		req->header.frame_ctl = IEEE80211_STYPE_PROBE_REQ;//changed!!
+		req->header.frame_ctl = IEEE80211_STYPE_PROBE_REQ;
 	else 
-		req->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ|IEEE80211_FCTL_PM);//tony ,for ps ctl bit
-	req->header.duration_id = 0; //FIXME: is this OK ? 
+		req->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ|IEEE80211_FCTL_PM);
+	req->header.duration_id = 0; 
 	
 	memset(req->header.addr1, 0xff, ETH_ALEN);
 	memcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
@@ -282,14 +282,9 @@
 		softmac_mgmt_xmit(skb, ieee);
 		ieee->softmac_stats.tx_beacons++;
 	}
-
-	ieee->beacon_timer.expires = jiffies + 
-		(MSECS( ieee->current_network.beacon_interval -5));
 	
-	spin_lock_irqsave(&ieee->beacon_lock,flags);
 	if(ieee->beacon_txing)
-		add_timer(&ieee->beacon_timer);
-	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
+		mod_timer(&ieee->beacon_timer,(jiffies + MSECS(ieee->current_network.beacon_interval -5)));
 }
 
 
@@ -362,7 +357,6 @@
 			goto out;
 		
 		ieee->set_chan(ieee->dev, ch);
-	//	printk(KERN_INFO "current probe channel is %d!\n",ch);
 		ieee80211_send_probe_requests(ieee);
 		
 		/* this prevent excessive time wait when we
@@ -379,10 +373,11 @@
 	ieee->sync_scan_hurryup = 0;
 	up(&ieee->scan_sem);
 }
-#if 0
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
 /* called both by wq with ieee->lock held */
 void ieee80211_softmac_scan(struct ieee80211_device *ieee)
 {
+#if 0
 	short watchdog = 0;
 	
 	do{
@@ -393,8 +388,16 @@
 				
 	}while(!ieee->channel_map[ieee->current_network.channel]);
 		
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20) 
+	queue_delayed_work(ieee->wq,&ieee->softmac_scan_wq,0);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	queue_work(ieee->wq,&ieee->softmac_scan_wq);	
+#else		        
+	schedule_task(&ieee->softmac_scan_wq);
+#endif
 
-	schedule_work(&ieee->softmac_scan_wq);
 }
 #endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
@@ -406,7 +409,6 @@
 void ieee80211_softmac_scan_wq(struct ieee80211_device *ieee)
 {	
 #endif
-	//short watchdog = 0;into ieee->scan_watchdog for roaming
 	down(&ieee->scan_sem);
 
 	if (ieee->scanning == 0 )
@@ -425,19 +427,22 @@
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	ieee80211_send_probe_requests(ieee);
 
-#if 0	
-	ieee->.expires = jiffies + (IEEE80211_SOFTMAC_SCAN_TIME);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);	
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	queue_work(ieee->wq,&ieee->softmac_scan_wq);	
+#else		
 	if (ieee->scanning == 1) 
-		add_timer(&ieee->scan_timer);
+		mod_timer(&ieee->scan_timer,(jiffies + MSECS(IEEE80211_SOFTMAC_SCAN_TIME)));
 #endif
-	queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);	
+
 out:
 	ieee->actscanning = false;
 	ieee->scan_watchdog = 0;
 	up(&ieee->scan_sem);
 }
 
-#if 0
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
 void ieee80211_softmac_scan_cb(unsigned long _dev)
 {
 	unsigned long flags;
@@ -496,21 +501,20 @@
 
 void ieee80211_softmac_stop_scan(struct ieee80211_device *ieee)
 {
-//	unsigned long flags;	
 	
-	//ieee->sync_scan_hurryup = 1;
 	
 	down(&ieee->scan_sem);
-//	spin_lock_irqsave(&ieee->lock, flags);
 	
 	if (ieee->scanning == 1){
 		ieee->scanning = 0;
 		ieee->scan_watchdog = 0;
-		//del_timer_sync(&ieee->scan_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		cancel_delayed_work(&ieee->softmac_scan_wq);
+#else
+		del_timer_sync(&ieee->scan_timer);
+#endif
 	}
 	
-//	spin_unlock_irqrestore(&ieee->lock, flags);
 	up(&ieee->scan_sem);
 }
 
@@ -529,9 +533,14 @@
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){	
 		if (ieee->scanning == 0){
 			ieee->scanning = 1;
-			//ieee80211_softmac_scan(ieee);
-			//queue_work(ieee->wq, &ieee->softmac_scan_wq);
-			queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq,0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+			queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, 0);
+#elif  LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
+
+			queue_work(ieee->wq, &ieee->softmac_scan_wq);
+#else
+			ieee80211_softmac_scan(ieee);
+#endif
 		}
 	}else
 		ieee->start_scan(ieee->dev);
@@ -565,10 +574,10 @@
 	
 	auth->header.frame_ctl = IEEE80211_STYPE_AUTH;
 	if (challengelen) auth->header.frame_ctl |= IEEE80211_FCTL_WEP;
-	if (ieee->ps != IEEE80211_PS_DISABLED) auth->header.frame_ctl |= IEEE80211_FCTL_PM;//tony 060624
+	if (ieee->ps != IEEE80211_PS_DISABLED) auth->header.frame_ctl |= IEEE80211_FCTL_PM;
 
 	
-	auth->header.duration_id = 0x013a; //FIXME
+	auth->header.duration_id = 0x013a; 
 	
 	memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
@@ -613,9 +622,15 @@
 	else
 		erp_len = 0;
 	
+	crypt = ieee->crypt[ieee->tx_keyidx];
+
+
+	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
+		((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));
+
 	beacon_size = sizeof(struct ieee80211_probe_response)+
 		ssid_len
-		+3 //channel
+		+3 
 		+rate_len
 		+rate_ex_len
 		+atim_len
@@ -633,7 +648,7 @@
 	memcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
 
-	beacon_buf->header.duration_id = 0; //FIXME
+	beacon_buf->header.duration_id = 0; 
 	beacon_buf->beacon_interval = 
 		cpu_to_le16(ieee->current_network.beacon_interval);
 	beacon_buf->capability = 
@@ -644,8 +659,6 @@
 	
 	crypt = ieee->crypt[ieee->tx_keyidx];
 
-	encrypt = ieee->host_encrypt && crypt && crypt->ops && 
-		(0 == strcmp(crypt->ops->name, "WEP"));
 
 	if (encrypt)	
 		beacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
@@ -693,7 +706,7 @@
 
 	if (wpa_ie_len){
 		if (ieee->iw_mode == IW_MODE_ADHOC)
-		{//as Windows will set pairwise key same as the group key which is not allowed in Linux, so set this for IOT issue. WB 2008.07.07
+		{
 			memcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);
 		}
 		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
@@ -854,8 +867,8 @@
 	
 	
 	int len=sizeof(struct ieee80211_assoc_request_frame)+
-				+ beacon->ssid_len//essid tagged val
-				+ rate_len//rates tagged val
+				+ beacon->ssid_len
+				+ rate_len
 				+ rsn_len
 				+ wpa_len;
 				
@@ -869,8 +882,8 @@
 	
 	
 	hdr->header.frame_ctl = IEEE80211_STYPE_ASSOC_REQ;
-	if (ieee->ps != IEEE80211_PS_DISABLED) hdr->header.frame_ctl |= IEEE80211_FCTL_PM; //tony
-	hdr->header.duration_id= 37; //FIXME
+	if (ieee->ps != IEEE80211_PS_DISABLED) hdr->header.frame_ctl |= IEEE80211_FCTL_PM; 
+	hdr->header.duration_id= 37; 
 	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
@@ -879,12 +892,12 @@
 	if (beacon->capability & WLAN_CAPABILITY_PRIVACY ) 
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
 	if(beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
-		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE); //tony 20060606
+		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE); 
 	
 	if(ieee->short_slot)
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);
 	
-	hdr->listen_interval = 0xa; //FIXME
+	hdr->listen_interval = 0xa; 
 	
 	hdr->info_element.id = MFIE_TYPE_SSID;
 
@@ -939,7 +952,6 @@
 	u8  authen_type = (ieee->wpax_type_notify >> 16) & 0xff;
 #endif
 #if 1	
-	// for testing purpose
 	unsigned int rsn_len = beacon->rsn_ie_len;
 #else
 	unsigned int rsn_len = beacon->rsn_ie_len - 4;
@@ -954,9 +966,6 @@
 	
 	int len = 0; 
 	
-	//[0] Notify type of encryption: WPA/WPA2
-	//[1] pair wise type
-	//[2] authen type
 	if(ieee->wpax_type_set) {
 		if (IEEE_PROTO_WPA == encry_proto) {
 			rsn_len = 0;
@@ -966,16 +975,16 @@
 	}
 #ifdef THOMAS_TURBO		
 	len = sizeof(struct ieee80211_assoc_request_frame)+
-		+ beacon->ssid_len//essid tagged val
-		+ rate_len//rates tagged val
+		+ beacon->ssid_len
+		+ rate_len
 		+ wpa_len
 		+ rsn_len
 		+ wmm_info_len
 		+ turbo_info_len;
 #else
 	len = sizeof(struct ieee80211_assoc_request_frame)+
-		+ beacon->ssid_len//essid tagged val
-		+ rate_len//rates tagged val
+		+ beacon->ssid_len
+		+ rate_len
 		+ wpa_len
 		+ rsn_len
 		+ wmm_info_len;
@@ -983,7 +992,7 @@
 
 #ifdef _RTL8187_EXT_PATCH_
 	if(ieee->iw_mode == ieee->iw_ext_mode)
-		skb = dev_alloc_skb(len+256); // stanley
+		skb = dev_alloc_skb(len+256); 
 	else
 #endif
 	skb = dev_alloc_skb(len);
@@ -994,13 +1003,12 @@
 	hdr = (struct ieee80211_assoc_request_frame *)
 		skb_put(skb, sizeof(struct ieee80211_assoc_request_frame));
 	
-	//printk("===========>%s, bssid:"MAC_FMT"\n", __FUNCTION__, MAC_ARG(beacon->bssid));	
 	hdr->header.frame_ctl = IEEE80211_STYPE_ASSOC_REQ;
-	hdr->header.duration_id= 37; //FIXME
+	hdr->header.duration_id= 37; 
 	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
-	memcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);//for HW security, John
+	memcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);
 	
 	hdr->capability = cpu_to_le16(WLAN_CAPABILITY_BSS);
 	if (beacon->capability & WLAN_CAPABILITY_PRIVACY ) 
@@ -1014,7 +1022,7 @@
 		ieee->ext_patch_ieee80211_association_req_1(hdr);
 #endif
 
-	hdr->listen_interval = 0xa; //FIXME
+	hdr->listen_interval = 0xa; 
 	
 	hdr->info_element.id = MFIE_TYPE_SSID;
 
@@ -1027,8 +1035,6 @@
 	ieee80211_MFIE_Brate(ieee, &tag);
 	ieee80211_MFIE_Grate(ieee, &tag);
 	
-	//add rsn==0 condition for ap's mix security mode(wpa+wpa2), john2007.8.9
-	//choose AES encryption as default algorithm while using mixed mode
 #if 0
 	if(rsn_len == 0){
 
@@ -1037,34 +1043,28 @@
 		if(wpa_len) {
 		
 
-		  //{add by david. 2006.8.31
-		  //fix linksys compatibility bug
-		  //}
-		  if(wpa_len > 24) {//22+2, mean include the capability
+		  if(wpa_len > 24) {
 			beacon->wpa_ie[wpa_len - 2] = 0;
 		  }
-		//multicast cipher OUI
-                  if(  beacon->wpa_ie[11]==0x2      ){ //0x0050f202 is the oui of tkip
+                  if(  beacon->wpa_ie[11]==0x2      ){ 
                   ieee->broadcast_key_type = KEY_TYPE_TKIP;
                 }
-                  else if(  beacon->wpa_ie[11]==0x4      ){//0x0050f204 is the oui of ccmp
+                  else if(  beacon->wpa_ie[11]==0x4      ){
                   ieee->broadcast_key_type = KEY_TYPE_CCMP;
                 }
- 		//unicast cipher OUI
 		  if(	beacon->wpa_ie[14]==0		 
 			&& beacon->wpa_ie[15]==0x50
                         && beacon->wpa_ie[16]==0xf2
-                        && beacon->wpa_ie[17]==0x2  	){ //0x0050f202 is the oui of tkip
+                        && beacon->wpa_ie[17]==0x2  	){ 
                   ieee->pairwise_key_type = KEY_TYPE_TKIP;
 		}
 
                   else if(   beacon->wpa_ie[14]==0
                         && beacon->wpa_ie[15]==0x50
                         && beacon->wpa_ie[16]==0xf2
-                        && beacon->wpa_ie[17]==0x4      ){//0x0050f204 is the oui of ccmp
+                        && beacon->wpa_ie[17]==0x4      ){
                   ieee->pairwise_key_type = KEY_TYPE_CCMP;
 		}
-		//indicate the wpa_ie content to WPA_SUPPLICANT
 		buff = kmalloc(IW_CUSTOM_MAX, GFP_ATOMIC);
 		memset(buff, 0, IW_CUSTOM_MAX);
 		p=buff;
@@ -1110,7 +1110,7 @@
                         if(     beacon->rsn_ie[10]==0x0 &&
                                 beacon->rsn_ie[11]==0xf &&
                                 beacon->rsn_ie[12]==0xac){
-				if(beacon->rsn_ie[8]==1){//not mixed mode
+				if(beacon->rsn_ie[8]==1){
 	                                switch(beacon->rsn_ie[13]){
         	                                case 0x2:
                 	                                ieee->pairwise_key_type = KEY_TYPE_TKIP;
@@ -1123,7 +1123,7 @@
                 	                                break;
                                 	}
 				}
-				else if(beacon->rsn_ie[8]==2){//mixed mode
+				else if(beacon->rsn_ie[8]==2){
 					ieee->pairwise_key_type = KEY_TYPE_CCMP;
 				}
                         }
@@ -1148,13 +1148,10 @@
 				memcpy(tag,(beacon->rsn_ie + info_addr),4);
 				info_addr += 4;
 			} else {
-				// if the wpax_type_notify has been set by the application,
-				// just use it, otherwise just use the default one.
 				if(ieee->wpax_type_set) {
 					suit_select = ((0 == i) ? pairwise_type:authen_type)&0x0f ;
 					memcpy(tag,rsn_authen_cipher_suite[suit_select],4);
 				} else {
-					//default set as ccmp, or none authentication
 					if(i == 0) {
 						memcpy(tag,rsn_authen_cipher_suite[4],4);
 					} else {
@@ -1203,7 +1200,7 @@
                         if(     beacon->rsn_ie[10]==0x0 &&
                                 beacon->rsn_ie[11]==0xf &&
                                 beacon->rsn_ie[12]==0xac){
-                                if(beacon->rsn_ie[8]==1){//not mixed mode
+                                if(beacon->rsn_ie[8]==1){
                                         switch(beacon->rsn_ie[13]){
                                                 case 0x2:
                                                         ieee->pairwise_key_type = KEY_TYPE_TKIP;
@@ -1217,7 +1214,7 @@
                                 	}
 
 				}
-                                else if(beacon->rsn_ie[8]==2){//mixed mode
+                                else if(beacon->rsn_ie[8]==2){
                                         ieee->pairwise_key_type = KEY_TYPE_CCMP;
                                 }
                         }
@@ -1278,8 +1275,14 @@
 	}
 		
 	ieee->state = IEEE80211_ASSOCIATING_RETRY;
-		
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	queue_delayed_work(ieee->wq, &ieee->associate_retry_wq, IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
+#else	
+	schedule_task(&ieee->associate_retry_wq);
+#endif	
+		
+	
 	
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
@@ -1306,8 +1309,6 @@
 		ieee->state = IEEE80211_ASSOCIATING_AUTHENTICATING ;
 
 		softmac_mgmt_xmit(skb, ieee);
-		//ieee->associate_timer.expires = jiffies + (HZ / 2);
-		//add_timer(&ieee->associate_timer);
 		mod_timer(&ieee->associate_timer, jiffies + HZ/2);
 	}	
 }
@@ -1317,7 +1318,6 @@
 	u8 *c;	
 	struct sk_buff *skb;
 	struct ieee80211_network *beacon = &ieee->current_network;
-//	int hlen = sizeof(struct ieee80211_authentication);
 	
 	ieee->associate_seq++;
 	ieee->softmac_stats.tx_auth_rq++;
@@ -1336,8 +1336,6 @@
 		ieee80211_encrypt_fragment(ieee, skb, sizeof(struct ieee80211_hdr_3addr  ));
 			
 		softmac_mgmt_xmit(skb, ieee);
-		//ieee->associate_timer.expires = jiffies + (HZ / 2);
-		//add_timer(&ieee->associate_timer);
 		mod_timer(&ieee->associate_timer, jiffies + HZ/2);
 	}	
 	kfree(challenge);
@@ -1358,8 +1356,6 @@
 		ieee80211_associate_abort(ieee);
 	else{
 		softmac_mgmt_xmit(skb, ieee);
-		//ieee->associate_timer.expires = jiffies + (HZ / 2);
-		//add_timer(&ieee->associate_timer);
 		mod_timer(&ieee->associate_timer, jiffies + HZ/2);
 	}	
 }
@@ -1383,7 +1379,6 @@
 		printk(KERN_INFO"Using B rates\n");
 	}
 
-//by lizhaoming for LED LINK
 #ifdef LED_SHIN
 	{
 		struct net_device *dev = ieee->dev;
@@ -1412,7 +1407,11 @@
 	ieee->state = IEEE80211_LINKED;
 	IEEE80211_DEBUG_MGMT("Successfully associated\n");
 	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	queue_work(ieee->wq, &ieee->associate_complete_wq);
+#else
+	schedule_task(&ieee->associate_complete_wq);
+#endif
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
@@ -1464,8 +1463,8 @@
 		 * This could be obtained by beacons or, if the network does not
 		 * broadcast it, it can be put manually.
 		 */
-		apset = ieee->wap_set;//(memcmp(ieee->current_network.bssid, zero,ETH_ALEN)!=0 );
-		ssidset = ieee->ssid_set;//ieee->current_network.ssid[0] != '\0';
+		apset = ieee->wap_set;
+		ssidset = ieee->ssid_set;
 		ssidbroad =  !(net->ssid_len == 0 || net->ssid[0]== '\0');
 		apmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN)==0);
 		ssidmatch = (0==strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));
@@ -1507,7 +1506,11 @@
 					ieee->state = IEEE80211_ASSOCIATING;
 					ieee->beinretry = false;
 					
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)					
 					queue_work(ieee->wq, &ieee->associate_procedure_wq);
+#else
+					schedule_task(&ieee->associate_procedure_wq);
+#endif
 				}else{
 					if(ieee80211_is_54g(ieee->current_network) && 
 						(ieee->modulation & IEEE80211_OFDM_MODULATION)){
@@ -1542,7 +1545,6 @@
 		if (ieee->state != IEEE80211_NOLINK) 
 			break;
 			
-		//if (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))
 			ieee80211_softmac_new_net(ieee, target);
 	}
 	
@@ -1624,7 +1626,6 @@
 		tag++; /* point to the next tag */
 	}
 	
-	//IEEE80211DMESG("Card MAC address is "MACSTR, MAC2STR(src));
 	if (ssidlen == 0) return 1;
 	
 	if (!ssid) return 1; /* ssid not found in tagged param */
@@ -1668,11 +1669,8 @@
 {
 	u8 dest[ETH_ALEN];
 	
-	//IEEE80211DMESG("Rx probe");
 	ieee->softmac_stats.rx_probe_rq++;
-	//DMESG("Dest is "MACSTR, MAC2STR(dest));
 	if (probe_rq_parse(ieee, skb, dest)){
-		//IEEE80211DMESG("Was for me!");
 		ieee->softmac_stats.tx_probe_rs++;
 		ieee80211_resp_to_probe(ieee, dest);
 	}
@@ -1683,13 +1681,11 @@
 {
 	u8 dest[ETH_ALEN];
 	int status;
-	//IEEE80211DMESG("Rx probe");
 	ieee->softmac_stats.rx_auth_rq++;
 	
 	if ((status = auth_rq_parse(skb, dest))!= -1){
 		ieee80211_resp_to_auth(ieee, status, dest);
 	}
-	//DMESG("Dest is "MACSTR, MAC2STR(dest));
 	
 }
 
@@ -1698,7 +1694,6 @@
 {
 	
 	u8 dest[ETH_ALEN];
-	//unsigned long flags;
 	
 	ieee->softmac_stats.rx_ass_rq++;
 	if (assoc_rq_parse(skb,dest) != -1){
@@ -1706,7 +1701,6 @@
 	}
 	
 	printk(KERN_INFO"New client associated: "MAC_FMT"\n", MAC_ARG(dest));
-	//FIXME
 	#if 0
 	spin_lock_irqsave(&ieee->lock,flags);
 	add_associate(ieee,dest);
@@ -1723,7 +1717,6 @@
 	
 	if (buf)
 		softmac_ps_mgmt_xmit(buf, ieee);
-//	printk(KERN_INFO "ieee80211_sta_ps_send_null_frame!\n");
 
 } 
 
@@ -1771,7 +1764,6 @@
 	}
 	ieee->ps_th=*time_h;
 	ieee->ps_tl=*time_l;
-//	printk(KERN_INFO "ieee->ps_tl %lu!\n",ieee->ps_tl);
 	return 1;
 	
 	
@@ -1784,14 +1776,12 @@
 	short sleep;
 	
 	unsigned long flags,flags2;
-////	printk(KERN_INFO "enter ieee80211_sta_ps!\n");
 	spin_lock_irqsave(&ieee->lock, flags);
 	
 	if((ieee->ps == IEEE80211_PS_DISABLED ||
 		ieee->iw_mode != IW_MODE_INFRA || 
 		ieee->state != IEEE80211_LINKED)){
 		
-//		#warning CHECK_LOCK_HERE
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 		
 		ieee80211_sta_wakeup(ieee, 1);	
@@ -1801,18 +1791,18 @@
 	
 	sleep = ieee80211_sta_ps_sleep(ieee,&th, &tl);
 	/* 2 wake, 1 sleep, 0 do nothing */
-	//printk(KERN_INFO "sleep %d,th %lu, tl %lu,sta_sleep %d\n",sleep,th,tl,ieee->sta_sleep);
 	if(sleep == 0)
 		goto out;
 	
 	if(sleep == 1){
 	
 		if(ieee->sta_sleep == 1)
-			//ieee->enter_sleep_state(ieee->dev,th,tl);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 			queue_work(ieee->wq,&ieee->hw_sleep_wq);
-		
+#else
+			schedule_task(&ieee->hw_sleep_wq);
+#endif
 		else if(ieee->sta_sleep == 0){
-		//	printk("send null 1\n");
 			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 			
 			if(ieee->ps_is_queue_empty(ieee->dev)){
@@ -1820,16 +1810,12 @@
 			
 				ieee->sta_sleep = 2;
 				
-			//	ieee->ps_request_tx_ack(ieee->dev);
-			//	printk(KERN_INFO "ps request address %lu!\n",ieee->ps_request_tx_ack);
-			//	queue_work(ieee->wq,&ieee->ps_request_tx_ack_wq);	
 				ieee80211_sta_ps_send_null_frame(ieee,1);
 				ieee80211_sta_ps_send_null_frame(ieee,1);
 				
 				ieee->ps_th = th;
 				ieee->ps_tl = tl;
-			//	udelay(100);
-				ieee80211_ps_tx_ack(ieee,1);//add without interrupt like 8185
+				ieee80211_ps_tx_ack(ieee,1);
 			}	
 			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 			
@@ -1837,7 +1823,6 @@
 		
 		
 	}else if(sleep == 2){
-//	#warning CHECK_LOCK_HERE
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 			
 		ieee80211_sta_wakeup(ieee,1);
@@ -1852,26 +1837,24 @@
 
 void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)
 {
-	//printk(KERN_INFO "ieee80211_sta_wakeup!\n");
 	if(ieee->sta_sleep == 0){
 		if(nl){
 			printk("Warning: driver is probably failing to report TX ps error\n");
-			//ieee->ps_request_tx_ack(ieee->dev);
-			//queue_work(ieee->wq,&ieee->ps_request_tx_ack_wq);
 			ieee80211_sta_ps_send_null_frame(ieee, 0);
 		}
 		return;
 		
 	}
 	if(ieee->sta_sleep == 1) 
-		//ieee->sta_wake_up(ieee->dev);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		queue_work(ieee->wq,&ieee->hw_wakeup_wq);
+#else
+		schedule_task(&ieee->hw_wakeup_wq);
+#endif
 		
 	ieee->sta_sleep = 0;
 	
 	if(nl){
-		//ieee->ps_request_tx_ack(ieee->dev);
-		//queue_work(ieee->wq,&ieee->ps_request_tx_ack_wq);
 		ieee80211_sta_ps_send_null_frame(ieee, 0);
 	}
 }
@@ -1879,16 +1862,17 @@
 void ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success)
 {
 	unsigned long flags,flags2;
-//	printk(KERN_INFO "ieee80211_ps_tx_ack,success %d,sta_sleep %d!\n",success,ieee->sta_sleep);
 	spin_lock_irqsave(&ieee->lock, flags);
 	
 	if(ieee->sta_sleep == 2){
 		/* Null frame with PS bit set */
 		if(success){
 			ieee->sta_sleep = 1;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 			queue_work(ieee->wq,&ieee->hw_sleep_wq);
-////			printk(KERN_INFO "sleep in queue!\n");
-			//ieee->enter_sleep_state(ieee->dev,ieee->ps_th,ieee->ps_tl);
+#else
+			schedule_task(&ieee->hw_sleep_wq);
+#endif
 		}
 		/* if the card report not success we can't be sure the AP
 		 * has not RXed so we can't assume the AP believe us awake
@@ -1916,7 +1900,6 @@
 	u8* challenge;
 	int chlen = 0;
 	int aid;
-//	printk(KERN_INFO "rx_frame_softmac!\n");
 	header = (struct ieee80211_hdr_3addr *) skb->data;
 	if(!ieee->proto_started)
 		return 0;
@@ -1924,7 +1907,6 @@
 	if(ieee->sta_sleep || (ieee->ps != IEEE80211_PS_DISABLED &&
 		ieee->iw_mode == IW_MODE_INFRA && 
 		ieee->state == IEEE80211_LINKED)) {
-////		printk(KERN_INFO "schedule ps task!\n");
 		tasklet_schedule(&ieee->ps_task);}
 				
 	if(WLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_PROBE_RESP &&
@@ -2019,8 +2001,12 @@
 				ieee->softmac_stats.reassoc++;
 				
 				notify_wx_assoc_event(ieee);
-								
+				
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)								
 				queue_work(ieee->wq, &ieee->associate_procedure_wq);
+#else
+				schedule_task(&ieee->associate_procedure_wq);
+#endif
 			}
 			
 			break;
@@ -2030,7 +2016,6 @@
 			break;
 	}
 	
-	//dev_kfree_skb_any(skb);
 	return 0;
 }
 
@@ -2068,7 +2053,6 @@
 		IEEE80211DMESG("EE: IEEE hard_start_xmit invoked when kernel queue should be stopped");
 		netif_stop_queue(ieee->dev);
 		ieee->ieee_stats.swtxstop++;
-		//dev_kfree_skb_any(skb);
 		err = 1;
 		goto exit;
 	}
@@ -2081,12 +2065,10 @@
 	
 	if(txb==NULL){
 		IEEE80211DMESG("WW: IEEE stack failed to provide txb");
-		//dev_kfree_skb_any(skb);
 		err = 1;
 		goto exit;
 	}
 	#endif
-	//added by david. 2007.1.23
 	if ((ieee->queue_stop)&&(ieee->tx_pending.txb != NULL)) {
 		goto lost;
 	}
@@ -2096,9 +2078,7 @@
 	for(i = 0; i < txb->nr_frags; i++) {
 	
 		if (ieee->queue_stop){
-			//added by david. 2007.1.23
 			if(ieee->tx_pending.txb != NULL) {
-				//ieee80211_txb_free(ieee->tx_pending.txb);
 			}
 			ieee->tx_pending.txb = txb;
 			ieee->tx_pending.frag = i;
@@ -2107,14 +2087,12 @@
 			ieee->softmac_data_hard_start_xmit(
 				txb->fragments[i],
 				ieee->dev,ieee->rate);
-				//(i+1)<txb->nr_frags);
 			ieee->stats.tx_packets++;
 			ieee->stats.tx_bytes += txb->fragments[i]->len;
 			ieee->dev->trans_start = jiffies; 
 		}
 	}	
 	lost:
-	//ieee80211_txb_free(txb);
 	
 	exit:
 	atomic_dec(&ieee->tx_pending_txb);
@@ -2136,14 +2114,12 @@
 			ieee->softmac_data_hard_start_xmit( 
 				ieee->tx_pending.txb->fragments[i],
 				ieee->dev,ieee->rate);
-				//(i+1)<ieee->tx_pending.txb->nr_frags);
 			ieee->stats.tx_packets++;
 			ieee->dev->trans_start = jiffies;
 		}
 	}
 	
 	
-	//ieee80211_txb_free(ieee->tx_pending.txb);
 	ieee->tx_pending.txb = NULL;
 }
 
@@ -2154,13 +2130,11 @@
 	struct sk_buff *ret;
 	
 	spin_lock_irqsave(&ieee->lock,flags);
-	// added by david, 2007.1.23
 	while((ret = dequeue_mgmt(ieee)) != NULL) {
 		dev_kfree_skb_any(ret);
 	}
 	init_mgmt_queue(ieee);
 	if (ieee->tx_pending.txb){
-		//ieee80211_txb_free(ieee->tx_pending.txb);
 		ieee->tx_pending.txb = NULL;
 	}
 	ieee->queue_stop = 0;
@@ -2194,7 +2168,6 @@
 
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
 
-			//added by david, 2007.1.23
 			dev_kfree_skb_any(skb);
 		}
 	}
@@ -2213,15 +2186,12 @@
 
 void ieee80211_stop_queue(struct ieee80211_device *ieee)
 {
-	//unsigned long flags;
-	//spin_lock_irqsave(&ieee->lock,flags);
 
 	if (! netif_queue_stopped(ieee->dev)){
 		netif_stop_queue(ieee->dev);
 		ieee->softmac_stats.swtxstop++;
 	}
 	ieee->queue_stop = 1;
-	//spin_unlock_irqrestore(&ieee->lock,flags);
 	
 }
 
@@ -2257,7 +2227,6 @@
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	ieee->state = IEEE80211_LINKED;
 
-//by lizhaoming for LED LINK
 #ifdef LED_SHIN
 	ieee->ieee80211_led_contorl(ieee->dev, LED_CTL_LINK);
 #endif
@@ -2308,7 +2277,6 @@
 		ieee->ssid_set = 1;
 	} 
 	
-//by lizhaoming for LED BLINK 2008.6.23
 #ifdef LED_SHIN
 	ieee->ieee80211_led_contorl(ieee->dev, LED_CTL_SITE_SURVEY);
 #endif
@@ -2369,7 +2337,6 @@
 			ieee->rate = 110;
 		}
 #ifdef WMM	
-		// By default, WMM function will be disabled in IBSS mode
 		ieee->current_network.QoS_Enable = 0;
 #endif
 	
@@ -2382,7 +2349,6 @@
 	
 	ieee->state = IEEE80211_LINKED;
 		
-//by lizhaoming for LED LINK
 #ifdef LED_SHIN
 	ieee->ieee80211_led_contorl(ieee->dev, LED_CTL_LINK);
 #endif
@@ -2406,7 +2372,7 @@
 inline void ieee80211_start_ibss(struct ieee80211_device *ieee)
 {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
-	queue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 150); //change to delayed work, delayed time is need to check
+	queue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 150); 
 #else
 	schedule_task(&ieee->start_ibss_wq);
 #endif
@@ -2422,9 +2388,8 @@
 	 * in associating / authenticating phase) start the background scanning.
 	 */
 
-//by lizhaoming for LED BLINK 2008.6.23
 #ifdef LED_SHIN
-	struct net_device *dev = ieee->dev;//by lizhaoming for LED 2008.6.23
+	struct net_device *dev = ieee->dev;
 	ieee->ieee80211_led_contorl(dev, LED_CTL_SITE_SURVEY);
 #endif
 	ieee80211_softmac_check_all_nets(ieee);
@@ -2456,7 +2421,9 @@
 			ieee->data_hard_stop(ieee->dev);
 	
 	ieee->state = IEEE80211_NOLINK;
-	ieee->link_change(ieee->dev);
+        ieee->wap_set = 0;
+        ieee->ssid_set = 0;
+
 	notify_wx_assoc_event(ieee);
 	
 }
@@ -2560,6 +2527,8 @@
 
 void ieee80211_stop_protocol(struct ieee80211_device *ieee)
 {
+	u8 i = 0;
+	
 	if (!ieee->proto_started)
 		return;
 	ieee->proto_started = 0;
@@ -2569,11 +2538,14 @@
 	del_timer_sync(&ieee->associate_timer);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	cancel_delayed_work(&ieee->associate_retry_wq);	
-    cancel_delayed_work(&ieee->start_ibss_wq); //cancel ibss start workqueue when stop protocol
+    	cancel_delayed_work(&ieee->start_ibss_wq); 
 #endif	
 	ieee80211_stop_scan(ieee);
 
 	ieee80211_disassociate(ieee);
+
+	for(i = 0; i < ETH_ALEN; i++)
+		ieee->current_network.bssid[i] = 0x22;
 }
 
 void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee)
@@ -2647,7 +2619,7 @@
 	ieee->queue_stop = 0;
 	ieee->scanning = 0;
 	ieee->scan_watchdog = 0;
-	ieee->softmac_features = 0; //so IEEE2100-like driver are happy
+	ieee->softmac_features = 0; 
 	ieee->wap_set = 0;
 	ieee->ssid_set = 0;
 	ieee->proto_started = 0;
@@ -2655,17 +2627,14 @@
 	ieee->rate = 3;
 	ieee->ps = IEEE80211_PS_DISABLED;
 	ieee->sta_sleep = 0;
-//lzm add 080917
 	ieee->bHwRadioOff = false;
-//by amy
 	ieee->bInactivePs = false;
 	ieee->actscanning = false;
 	ieee->beinretry = false;
 	ieee->ListenInterval = 2;
 	ieee->NumRxData = 0;
-//by amy		
 	init_mgmt_queue(ieee);
-#if 0
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
 	init_timer(&ieee->scan_timer);
 	ieee->scan_timer.data = (unsigned long)ieee;
 	ieee->scan_timer.function = ieee80211_softmac_scan_cb;
@@ -2688,28 +2657,28 @@
 #endif
 #endif
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)//added by lawrence,070702
-INIT_WORK(&ieee->start_ibss_wq,(void*) ieee80211_start_ibss_wq,ieee);
-	INIT_WORK(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq,ieee);
-	INIT_WORK(&ieee->associate_complete_wq,(void*) ieee80211_associate_complete_wq,ieee);
-	INIT_WORK(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq,ieee);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
 	INIT_WORK(&ieee->softmac_scan_wq,(void*) ieee80211_softmac_scan_wq,ieee);
+	INIT_WORK(&ieee->start_ibss_wq,(void*) ieee80211_start_ibss_wq,ieee);	
+	INIT_WORK(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq,ieee);	
+	INIT_WORK(&ieee->associate_complete_wq,(void*) ieee80211_associate_complete_wq,ieee);	
+	INIT_WORK(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq,ieee);
 	INIT_WORK(&ieee->wx_sync_scan_wq,(void*) ieee80211_wx_sync_scan_wq,ieee);
 #else
+	INIT_DELAYED_WORK(&ieee->softmac_scan_wq,(void*) ieee80211_softmac_scan_wq);
 	INIT_DELAYED_WORK(&ieee->start_ibss_wq,(void*)ieee80211_start_ibss_wq);
+	INIT_DELAYED_WORK(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq);		
 	INIT_WORK(&ieee->associate_complete_wq,(void*) ieee80211_associate_complete_wq);
-	INIT_WORK(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq);
-	INIT_DELAYED_WORK(&ieee->softmac_scan_wq,(void*) ieee80211_softmac_scan_wq);
-	INIT_DELAYED_WORK(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq);	
+	INIT_WORK(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq);	
 	INIT_WORK(&ieee->wx_sync_scan_wq,(void*) ieee80211_wx_sync_scan_wq);
 
 #endif	
 #else
-	tq_init(&ieee->start_ibss_wq,(void*) ieee80211_start_ibss_wq,ieee);
-	tq_init(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq,ieee);
-	tq_init(&ieee->associate_complete_wq,(void*) ieee80211_associate_complete_wq,ieee);
-	tq_init(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq,ieee);
 	tq_init(&ieee->softmac_scan_wq,(void*) ieee80211_softmac_scan_wq,ieee);
+	tq_init(&ieee->start_ibss_wq,(void*) ieee80211_start_ibss_wq,ieee);	
+	tq_init(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq,ieee);	
+	tq_init(&ieee->associate_complete_wq,(void*) ieee80211_associate_complete_wq,ieee);	
+	tq_init(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq,ieee);	
 	tq_init(&ieee->wx_sync_scan_wq,(void*) ieee80211_wx_sync_scan_wq,ieee);
 #endif
 
@@ -2730,9 +2699,10 @@
 	down(&ieee->wx_sem);
 	
 	del_timer_sync(&ieee->associate_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	cancel_delayed_work(&ieee->associate_retry_wq);
 	destroy_workqueue(ieee->wq);
-	
+#endif	
 	up(&ieee->wx_sem);
 }
 
@@ -2768,7 +2738,6 @@
 
 	switch (command) {
 	case IEEE_MLME_STA_DEAUTH:
-		// silently ignore
 		break;
 
 	case IEEE_MLME_STA_DISASSOC:
@@ -2915,8 +2884,6 @@
 #if 0 
 	int ret = 0;
 	int group_key = 0;
-	//struct r8180_priv *priv = ieee80211_priv(dev);
-	//struct ieee80211_device *ieee = priv->ieee;
 	struct ieee80211_crypto_ops *ops;
 	struct ieee80211_crypt_data **crypt;
 
@@ -2951,8 +2918,6 @@
 	if (strcmp(param->u.crypt.alg, "none") == 0) {
 		if (crypt) {
 			sec.enabled = 0;
-			// FIXME FIXME
-			//sec.encrypt = 0;
 			sec.level = SEC_LEVEL_0;
 			sec.flags |= SEC_LEVEL;
 			ieee80211_crypt_delayed_deinit(ieee, crypt);
@@ -3085,7 +3050,6 @@
 #else	
 	int ret = 0;
 	int tmp = 0;
-//added
 	struct ieee80211_crypto_ops *ops;
 	struct ieee80211_crypt_data **crypt;
 
@@ -3116,8 +3080,6 @@
 	if (strcmp(param->u.crypt.alg, "none") == 0) {
 		if (crypt) {
 			sec.enabled = 0;
-			// FIXME FIXME
-			//sec.encrypt = 0;
 			sec.level = SEC_LEVEL_0;
 			sec.flags |= SEC_ENABLED | SEC_LEVEL;
 			ieee80211_crypt_delayed_deinit(ieee, crypt);
@@ -3129,11 +3091,7 @@
 	}
 
 	sec.enabled = 1;
-// FIXME FIXME
-//	sec.encrypt = 1;
 	sec.flags |= SEC_ENABLED;
-//FOR TEST a big bug.
-	//goto done;//ok
 
 
 	/* IPW HW cannot build TKIP MIC, host decryption still needed. */
@@ -3141,8 +3099,6 @@
 	    strcmp(param->u.crypt.alg, "TKIP")){
 	
 		goto skip_host_crypt;}
-//FOR TEST 
-	//goto done;//?
 
 	ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
 	if (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {
@@ -3156,7 +3112,6 @@
 		ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
 	}
 
-	//goto done;//ok.
 	if (ops == NULL) {
 
 		param->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;
@@ -3177,7 +3132,11 @@
 		}
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 		new_crypt->ops = ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#else
+		if (new_crypt->ops && try_inc_mod_count(new_crypt->ops->owner))
+#endif
 			new_crypt->priv =
 				new_crypt->ops->init(param->u.crypt.idx);
 
@@ -3191,29 +3150,23 @@
 		*crypt = new_crypt;
 	}
 
-//goto done;//ok
 
 
 
-	//goto done;//ok
 	if (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key){
 
 	tmp = (*crypt)->ops->set_key(param->u.crypt.key,
 				   param->u.crypt.key_len, param->u.crypt.seq,
 				   (*crypt)->priv);
 
-//	udelay(2111);
-////	return -EINVAL;
 	if ( tmp < 0) {
 
 		param->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;
 		ret = -EINVAL;
-	//	return ret;
 		goto done;
 	}}
 
 
-//goto done;
  skip_host_crypt:
 	if (param->u.crypt.set_tx) {
 		ieee->tx_keyidx = param->u.crypt.idx;
@@ -3270,7 +3223,6 @@
 	int ret=0;
 
 	down(&ieee->wx_sem);
-	//IEEE_DEBUG_INFO("wpa_supplicant: len=%d\n", p->length);
 
 	if (p->length < sizeof(struct ieee_param) || !p->pointer){
 		ret = -EINVAL;
@@ -3295,8 +3247,6 @@
 		goto out;	
 	}
 #endif	
-	//DMESG(">>>>>>>>>>>>>%x<<<<<<<<<<<",param->cmd);
-	//DMESG("Inieee80211_wpa_supplicant_ioctl,the cmd is:%x\n",param->cmd);
 	udelay(5);	
 	switch (param->cmd) {
 
@@ -3311,6 +3261,30 @@
 		break;
 
 	case IEEE_CMD_SET_ENCRYPTION:
+		if (param->u.crypt.set_tx)
+		{
+			if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+				ieee->pairwise_key_type = KEY_TYPE_CCMP;
+			else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+				ieee->pairwise_key_type = KEY_TYPE_TKIP;
+			else if (strcmp(param->u.crypt.alg, "WEP") == 0)
+			{
+				if (param->u.crypt.key_len == 13)
+					ieee->pairwise_key_type = KEY_TYPE_WEP104;
+				else if (param->u.crypt.key_len == 5)
+					ieee->pairwise_key_type = KEY_TYPE_WEP40;
+			} else {
+				ieee->pairwise_key_type = KEY_TYPE_NA;
+			}
+
+			if (ieee->pairwise_key_type)
+			{
+				u8 zero_addr[6] = {0};
+				if (memcmp(ieee->ap_mac_addr, zero_addr, 6) == 0)
+					ieee->iw_mode = IW_MODE_ADHOC;
+			}
+		}
+		
 		ret = ieee80211_wpa_set_encryption(ieee, param, p->length);
 		break;
 
@@ -3320,15 +3294,12 @@
 		break;
 
 	default:
-		//printk("Unknown WPA supplicant request: %d\n",param->cmd);
 		ret = -EOPNOTSUPP;
 		break;
 	}
-	//DMESG("call copy_to_user");
 	udelay(100);	
 	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
 		ret = -EFAULT;
-	//DMESG("call copy_to_user over!");
 	kfree(param);
 out:
 	up(&ieee->wx_sem);	
@@ -3350,7 +3321,7 @@
 }
 
 
-
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_get_beacon);
 EXPORT_SYMBOL(ieee80211_wake_queue);
 EXPORT_SYMBOL(ieee80211_stop_queue);
@@ -3364,5 +3335,20 @@
 EXPORT_SYMBOL(ieee80211_start_protocol);
 EXPORT_SYMBOL(ieee80211_stop_protocol);
 EXPORT_SYMBOL(ieee80211_disassociate);
-
-//EXPORT_SYMBOL(ieee80211_sta_ps_send_null_frame);
+EXPORT_SYMBOL(ieee80211_start_scan_syncro);
+#else
+EXPORT_SYMBOL_NOVERS(ieee80211_get_beacon);
+EXPORT_SYMBOL_NOVERS(ieee80211_wake_queue);
+EXPORT_SYMBOL_NOVERS(ieee80211_stop_queue);
+EXPORT_SYMBOL_NOVERS(ieee80211_reset_queue);
+EXPORT_SYMBOL_NOVERS(ieee80211_softmac_stop_protocol);
+EXPORT_SYMBOL_NOVERS(ieee80211_softmac_start_protocol);
+EXPORT_SYMBOL_NOVERS(ieee80211_is_shortslot);
+EXPORT_SYMBOL_NOVERS(ieee80211_is_54g);
+EXPORT_SYMBOL_NOVERS(ieee80211_wpa_supplicant_ioctl);
+EXPORT_SYMBOL_NOVERS(ieee80211_ps_tx_ack);
+EXPORT_SYMBOL_NOVERS(ieee80211_start_protocol);
+EXPORT_SYMBOL_NOVERS(ieee80211_stop_protocol);
+EXPORT_SYMBOL_NOVERS(ieee80211_disassociate);
+EXPORT_SYMBOL_NOVERS(ieee80211_start_scan_syncro);
+#endif
diff -ruN rtl8187l_orig/ieee80211/ieee80211_softmac_wx.c rtl8187l/ieee80211/ieee80211_softmac_wx.c
--- rtl8187l_orig/ieee80211/ieee80211_softmac_wx.c	2011-01-02 18:14:30.744091000 +0100
+++ rtl8187l/ieee80211/ieee80211_softmac_wx.c	2009-06-26 09:07:43.853534000 +0200
@@ -136,7 +136,7 @@
 	u8 zero[] = {0,0,0,0,0,0};
 	unsigned long flags;
 	
-	short ifup = ieee->proto_started;//dev->flags & IFF_UP;
+	short ifup = ieee->proto_started;
 	struct sockaddr *temp = (struct sockaddr *)awrq;
 	
 	ieee->sync_scan_hurryup = 1;
@@ -219,7 +219,6 @@
 	u32 target_rate = wrqu->bitrate.value;
 	
 	ieee->rate = target_rate/100000;
-	//FIXME: we might want to limit rate also in management protocols.
 	return 0; 
 }
 
@@ -322,19 +321,23 @@
 	}
 	
 	if ( ieee->state == IEEE80211_LINKED){
-			if(list_empty(&(((&(ieee->wx_sync_scan_wq))->entry)))) {	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
+		if(list_empty(&(((&(ieee->wx_sync_scan_wq))->entry)))) 
+#endif
+		{	
 			ieee->actscanning = true;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
-		queue_work(ieee->wq, &ieee->wx_sync_scan_wq);
+			queue_work(ieee->wq, &ieee->wx_sync_scan_wq);
 #else
-		schedule_task(&ieee->wx_sync_scan_wq);
+			schedule_task(&ieee->wx_sync_scan_wq);
 #endif
-			}
-					
+		}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		else {
 			DMESG("the wx_sync_scan_wq is not empty.");
 			goto out;
 		}
+#endif
 		/* intentionally forget to up sem */
 		return 0;
 	}
@@ -344,7 +347,6 @@
 	return ret;
 }
 
-/////////////////////////////////////
 int ieee80211_wx_set_essid(struct ieee80211_device *ieee, 
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
@@ -381,24 +383,20 @@
 	
 	if (wrqu->essid.flags && wrqu->essid.length) {
 
-//YJ,modified,080819
 #if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,20)		
 		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
 #else
 		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length) : IW_ESSID_MAX_SIZE;
 #endif
-		memset(ieee->current_network.ssid, 0, ieee->current_network.ssid_len); //YJ,add,080819
+		memset(ieee->current_network.ssid, 0, ieee->current_network.ssid_len); 
 		strncpy(ieee->current_network.ssid, extra, len);
 		ieee->current_network.ssid_len = len;
 		ieee->ssid_set = 1;
-//YJ,modified,080819,end
 		
-		//YJ,add,080819,for hidden ap
 		if(len == 0){
 			memset(ieee->current_network.bssid, 0, ETH_ALEN);
 			ieee->current_network.capability = 0;
 		}
-		//YJ,add,080819,for hidden ap,end
 	}
 	else{ 
 		ieee->ssid_set = 0;
@@ -491,9 +489,6 @@
 	int ret = 0;
 
 	if(
-	//	(!ieee->sta_wake_up) ||
-	//	(!ieee->ps_request_tx_ack) ||
-	//	(!ieee->enter_sleep_state) ||
 		(!ieee->ps_is_queue_empty)){
 		
 		printk("ERROR. PS mode is tryied to be use but\
@@ -530,20 +525,17 @@
 	if (wrqu->power.flags & IW_POWER_TIMEOUT) {
 				      
 		ieee->ps_timeout = wrqu->power.value / 1000;
-		//printk("Timeout %d\n",ieee->ps_timeout);
 	}
 	
 	if (wrqu->power.flags & IW_POWER_PERIOD) {
 		
 		ret = -EOPNOTSUPP;
 		goto exit;
-		//wrq->value / 1024;
 		
 	}
 	
 exit:
 	up(&ieee->wx_sem);
-	//printk(KERN_INFO "normal power set!\n");
 	return ret;
 
 }
@@ -564,16 +556,8 @@
 
 	wrqu->power.disabled = 0;
 
-//	if ((wrqu->power.flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {
 		wrqu->power.flags = IW_POWER_TIMEOUT;
 		wrqu->power.value = ieee->ps_timeout * 1000;
-//	} else {
-//		ret = -EOPNOTSUPP;
-//		goto exit;
-		//wrqu->power.flags = IW_POWER_PERIOD;
-		//wrqu->power.value = ieee->current_network.dtim_period *
-		//	ieee->current_network.beacon_interval * 1024;
-//	}
 
 
 	if (ieee->ps & IEEE80211_PS_MBCAST)
diff -ruN rtl8187l_orig/ieee80211/ieee80211_tx.c rtl8187l/ieee80211/ieee80211_tx.c
--- rtl8187l_orig/ieee80211/ieee80211_tx.c	2011-01-02 18:14:30.731498000 +0100
+++ rtl8187l/ieee80211/ieee80211_tx.c	2009-06-26 09:07:43.857584000 +0200
@@ -32,7 +32,6 @@
 ******************************************************************************/
 
 #include <linux/compiler.h>
-//#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>
 #include <linux/in6.h>
@@ -57,7 +56,6 @@
 #endif
 
 #include "ieee80211.h"
-//#include "ieee80211_crypt.h"
 
 /*
 
@@ -207,7 +205,6 @@
 	/* To encrypt, frame format is:
 	 * IV (4 bytes), clear payload (including SNAP), ICV (4 bytes) */
 
-	// PR: FIXME: Copied from hostap. Check fragmentation/MSDU/MPDU encryption.
 	/* Host-based IEEE 802.11 fragmentation for TX is not yet supported, so
 	 * call both MSDU and MPDU encryption functions from here. */
 	atomic_inc(&crypt->refcnt);
@@ -251,8 +248,6 @@
 		return NULL;
 
 	memset(txb, 0, sizeof(struct ieee80211_txb));
-	//txb->nr_frags = nr_frags;
-	//txb->frag_size = txb_size;
 
 	for (i = 0; i < nr_frags; i++) {
 		txb->fragments[i] = dev_alloc_skb(txb_size);
@@ -274,7 +269,11 @@
 int ieee80211_xmit(struct sk_buff *skb,
 		   struct net_device *dev)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 
 	struct ieee80211_device *ieee = netdev_priv(dev);
+#else
+	struct ieee80211_device *ieee = (struct ieee80211_device *)dev->priv;
+#endif
 	struct ieee80211_txb *txb = NULL;
 	struct ieee80211_hdr *frag_hdr;
 	int i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;
@@ -390,8 +389,6 @@
 	
 		/* Each fragment may need to have room for encryptiong pre/postfix */
 		if (encrypt)
-		//for 2.6.21,modify by lawrence	
-			//bytes_per_frag -= crypt->ops->extra_mpdu_prefix_len+(crypt->ops->extra_mpdu_postfix_len+crypt->ops->extra_msdu_postfix_len) ;
 			bytes_per_frag -= crypt->ops->extra_prefix_len +
 					crypt->ops->extra_postfix_len;
 	
@@ -407,8 +404,6 @@
 		/* When we allocate the TXB we allocate enough space for the reserve
 		* and full fragment bytes (bytes_per_frag doesn't include prefix,
 		* postfix, header, FCS, etc.) */
-		//added by david. 2007.1.31
-	       //	txb = ieee80211_alloc_txb(nr_frags, frag_size, GFP_ATOMIC);
 		
 		pend = atomic_read(&ieee->tx_pending_txb);
 		if(pend > (MAX_TX_SKB - 1)) {
@@ -483,12 +478,10 @@
 			(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 				skb_put(skb_frag, 4);
 		}
-		// Advance sequence number in data frame. 
 		if (ieee->seq_ctrl == 0xFFF)
 			ieee->seq_ctrl = 0;
 		else
 			ieee->seq_ctrl++;
-		//---
 	}else{
 		if (unlikely(skb->len < sizeof(struct ieee80211_hdr_3addr))) {
 			printk(KERN_WARNING "%s: skb too small (%d).\n",
@@ -533,5 +526,10 @@
 
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_txb_free);
 EXPORT_SYMBOL(ieee80211_alloc_txb);
+#else
+EXPORT_SYMBOL_NOVERS(ieee80211_txb_free);
+EXPORT_SYMBOL_NOVERS(ieee80211_alloc_txb);
+#endif
diff -ruN rtl8187l_orig/ieee80211/ieee80211_wx.c rtl8187l/ieee80211/ieee80211_wx.c
--- rtl8187l_orig/ieee80211/ieee80211_wx.c	2011-01-02 18:14:30.735583000 +0100
+++ rtl8187l/ieee80211/ieee80211_wx.c	2009-06-26 09:07:43.857584000 +0200
@@ -39,6 +39,33 @@
 	"?", "a", "b", "ab", "g", "ag", "bg", "abg"
 };
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+static inline char *
+iwe_stream_add_event_rsl(char *     stream,         /* Stream of events */
+                     char *     ends,           /* End of stream */
+                     struct iw_event *iwe,      /* Payload */
+                     int        event_len)      /* Real size of payload */
+{
+        /* Check if it's possible */
+        if((stream + event_len) < ends) {
+                iwe->len = event_len;
+		ndelay(1);   
+                memcpy(stream, (char *) iwe, event_len);
+                stream += event_len;
+        }
+        return stream;
+}
+#else
+#define iwe_stream_add_event_rsl iwe_stream_add_event
+#endif
+
+#ifndef IWEVCUSTOM
+#define IWEVCUSTOM 	0x8c02
+#endif
+#ifndef IWEVGENIE
+#define IWEVGENIE	0x8C05
+#endif
+
 #define MAX_CUSTOM_LEN 64
 static inline char *rtl818x_translate_scan(struct ieee80211_device *ieee,
  					   char *start, char *stop,
@@ -58,9 +85,9 @@
 	memcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_ADDR_LEN);
 #else
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_ADDR_LEN);
 #endif
 
 	/* Remaining entries will be displayed in the order we provide them */
@@ -68,15 +95,17 @@
 	/* Add the ESSID */
 	iwe.cmd = SIOCGIWESSID;
 	iwe.u.data.flags = 1;
-	//YJ,modified,080903,for hidden ap
-	//if (network->flags & NETWORK_EMPTY_ESSID) {
 	if (network->ssid_len == 0) {
-	//YJ,modified,080903,end
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+		iwe.u.data.length = sizeof("hidden") + 1;
+                start = iwe_stream_add_point(start, stop, &iwe, "hidden");
+#else
 		iwe.u.data.length = sizeof("<hidden>");
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-		start = iwe_stream_add_point(info, start, stop, &iwe, "<hidden>");
+                start = iwe_stream_add_point(info, start, stop, &iwe, "<hidden>");
 #else
-		start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
+                start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
+#endif
 #endif
 	} else {
 		iwe.u.data.length = min(network->ssid_len, (u8)32);
@@ -91,9 +120,9 @@
 	iwe.cmd = SIOCGIWNAME;
 	snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11%s", ieee80211_modes[network->mode]);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_CHAR_LEN);
 #else
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_CHAR_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_CHAR_LEN);
 #endif
         /* Add mode */
         iwe.cmd = SIOCGIWMODE;
@@ -105,9 +134,9 @@
 			iwe.u.mode = IW_MODE_ADHOC;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-		start = iwe_stream_add_event(info, start, stop, &iwe,IW_EV_UINT_LEN);
+		start = iwe_stream_add_event_rsl(info, start, stop, &iwe,IW_EV_UINT_LEN);
 #else
-		start = iwe_stream_add_event(start, stop, &iwe,IW_EV_UINT_LEN);
+		start = iwe_stream_add_event_rsl(start, stop, &iwe,IW_EV_UINT_LEN);
 #endif
 	}
 
@@ -119,9 +148,9 @@
 	iwe.u.freq.e = 0;
 	iwe.u.freq.i = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_FREQ_LEN);
 #else
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_FREQ_LEN);
 #endif
 
 	/* Add encryption capability */
@@ -165,9 +194,9 @@
 	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
 	iwe.u.bitrate.value = max_rate * 500000;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	start = iwe_stream_add_event(info, start, stop, &iwe,IW_EV_PARAM_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe,IW_EV_PARAM_LEN);
 #else
-	start = iwe_stream_add_event(start, stop, &iwe,IW_EV_PARAM_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe,IW_EV_PARAM_LEN);
 #endif
 
 	iwe.cmd = IWEVCUSTOM;
@@ -182,8 +211,8 @@
 	/* Add quality statistics */
 	/* TODO: Fix these values... */
 	iwe.cmd = IWEVQUAL;
-	iwe.u.qual.qual = network->stats.signalstrength;//network->stats.signal;
-	iwe.u.qual.level = network->stats.signal;//network->stats.rssi;
+	iwe.u.qual.qual = network->stats.signalstrength;
+	iwe.u.qual.level = network->stats.signal;
 	iwe.u.qual.noise = network->stats.noise;
 #if 0
 	iwe.u.qual.updated = network->stats.mask & IEEE80211_STATMASK_WEMASK;
@@ -195,11 +224,11 @@
 		iwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;
 #endif
 
-	iwe.u.qual.updated = 0x7;//network->stats.mask & IEEE80211_STATMASK_WEMASK;
+	iwe.u.qual.updated = 0x7;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_QUAL_LEN);
 #else
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_QUAL_LEN);
 #endif
 
 	iwe.cmd = IWEVCUSTOM;
@@ -213,10 +242,9 @@
 		start = iwe_stream_add_point(start, stop, &iwe, custom);
 #endif
 
-#if 0
+#if (WIRELESS_EXT < 18) 
 	if (ieee->wpa_enabled && network->wpa_ie_len){
 		char buf[MAX_WPA_IE_LEN * 2 + 30];
-	//	printk("WPA IE\n");
 		u8 *p = buf;
 		p += sprintf(p, "wpa_ie=");
 		for (i = 0; i < network->wpa_ie_len; i++) {
@@ -226,8 +254,12 @@
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVCUSTOM;
 		iwe.u.data.length = strlen(buf);
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
-	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+#else
+                start = iwe_stream_add_point(start, stop, &iwe, buf);
+#endif
+        }
 
 	if (ieee->wpa_enabled && network->rsn_ie_len){
 		char buf[MAX_WPA_IE_LEN * 2 + 30];
@@ -238,46 +270,44 @@
 			p += sprintf(p, "%02x", network->rsn_ie[i]);
 		}
 
-
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		iwe.u.data.length = strlen(buf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+#else
+                start = iwe_stream_add_point(start, stop, &iwe, buf);
+#endif
+        }
 #else
 	memset(&iwe, 0, sizeof(iwe));
-        if (network->wpa_ie_len) {
-		//printk("wpa_ie_len:%d\n", network->wpa_ie_len);
-                char buf[MAX_WPA_IE_LEN];
-                memcpy(buf, network->wpa_ie, network->wpa_ie_len);
-                iwe.cmd = IWEVGENIE;
-                iwe.u.data.length = network->wpa_ie_len;
+	if (network->wpa_ie_len)
+	{
+		char buf[MAX_WPA_IE_LEN];
+		memcpy(buf, network->wpa_ie, network->wpa_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = network->wpa_ie_len;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
                 start = iwe_stream_add_point(info, start, stop, &iwe, buf);
 #else
                 start = iwe_stream_add_point(start, stop, &iwe, buf);
 #endif
         }
-
-        memset(&iwe, 0, sizeof(iwe));
-        if (network->rsn_ie_len) {
-		//printk("=====>rsn_ie_len:\n", network->rsn_ie_len);
-		#if 0
-		{
-			int i;
-			for (i=0; i<network->rsn_ie_len; i++);
-			printk("%2x ", network->rsn_ie[i]);
-			printk("\n");
-		}
-		#endif
-                char buf[MAX_WPA_IE_LEN];
-                memcpy(buf, network->rsn_ie, network->rsn_ie_len);
-                iwe.cmd = IWEVGENIE;
-                iwe.u.data.length = network->rsn_ie_len;
+	memset(&iwe, 0, sizeof(iwe));
+	if (network->rsn_ie_len)
+	{
+		char buf[MAX_WPA_IE_LEN];
+		memcpy(buf, network->rsn_ie, network->rsn_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = network->rsn_ie_len;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
 #else
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
+                start = iwe_stream_add_point(start, stop, &iwe, buf);
 #endif
-	}
-
+        }
 #endif
-		
+
 	/* Add EXTRA: Age to display seconds since last beacon/probe response
 	 * for given network. */
 	iwe.cmd = IWEVCUSTOM;
@@ -304,8 +334,7 @@
 	unsigned long flags;
 	int err = 0;
 	char *ev = extra;
-	char *stop = ev + wrqu->data.length;//IW_SCAN_MAX_DATA;
-	//char *stop = ev + IW_SCAN_MAX_DATA;
+	char *stop = ev + wrqu->data.length;
 	int i = 0;
 
 	IEEE80211_DEBUG_WX("Getting scan\n");
@@ -470,7 +499,7 @@
 		if (key == sec.active_key)
 			sec.flags |= SEC_ACTIVE_KEY;
 
-		ieee->tx_keyidx = key; //we need it to support multi_key setting. added by wb 2008_2_22 
+		ieee->tx_keyidx = key; 
 	} else {
 		len = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,
 					     NULL, (*crypt)->priv);
@@ -575,14 +604,17 @@
 	return 0;
 }
 
+#if WIRELESS_EXT >= 18
 int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
+	int ret = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = ieee->dev;
         struct iw_point *encoding = &wrqu->encoding;
         struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-        int i, idx, ret = 0;
+        int i, idx;
         int group_key = 0;
         const char *alg, *module;
         struct ieee80211_crypto_ops *ops;
@@ -591,7 +623,6 @@
         struct ieee80211_security sec = {
                 .flags = 0,
         };
-	//printk("======>encoding flag:%x,ext flag:%x, ext alg:%d\n", encoding->flags,ext->ext_flags, ext->alg);
         idx = encoding->flags & IW_ENCODE_INDEX;
         if (idx) {
                 if (idx < 1 || idx > WEP_KEYS)
@@ -609,7 +640,6 @@
                 group_key = 1;
         } else {
                 /* some Cisco APs use idx>0 for unicast in dynamic WEP */
-		//printk("not group key, flags:%x, ext->alg:%d\n", ext->ext_flags, ext->alg);
                 if (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)
                         return -EINVAL;
                 if (ieee->iw_mode == IW_MODE_INFRA)
@@ -622,7 +652,7 @@
                         return -EINVAL;
         }
 
-        sec.flags |= SEC_ENABLED;// | SEC_ENCRYPT;
+        sec.flags |= SEC_ENABLED;
         if ((encoding->flags & IW_ENCODE_DISABLED) ||
             ext->alg == IW_ENCODE_ALG_NONE) {
                 if (*crypt)
@@ -638,16 +668,13 @@
 
                 if (i == WEP_KEYS) {
                         sec.enabled = 0;
-                      //  sec.encrypt = 0;
                         sec.level = SEC_LEVEL_0;
                         sec.flags |= SEC_LEVEL;
                 }
-		//printk("disabled: flag:%x\n", encoding->flags);
                 goto done;
         }
 	
 	sec.enabled = 1;
-    //    sec.encrypt = 1;
 #if 0
         if (group_key ? !ieee->host_mc_decrypt :
             !(ieee->host_encrypt || ieee->host_decrypt ||
@@ -704,7 +731,11 @@
                         goto done;
                 }
                 new_crypt->ops = ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
                 if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#else
+	        if (new_crypt->ops && try_inc_mod_count(new_crypt->ops->owner))
+#endif
                         new_crypt->priv = new_crypt->ops->init(idx);
                 if (new_crypt->priv == NULL) {
                         kfree(new_crypt);
@@ -714,7 +745,6 @@
                 *crypt = new_crypt;
 
  	}
-	//I need to deinit other crypt here in mesh mode instead deinit them while use them to tx&rx.
 #ifdef _RTL8187_EXT_PATCH_
 	if (ieee->iw_mode == ieee->iw_ext_mode)
 	{
@@ -738,8 +768,6 @@
                 goto done;
         }
 #if 1	
- //skip_host_crypt:
-	//printk("skip_host_crypt:ext_flags:%x\n", ext->ext_flags);
         if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
                 ieee->tx_keyidx = idx;
                 sec.active_key = idx;
@@ -751,15 +779,12 @@
                 sec.key_sizes[idx] = ext->key_len;
                 sec.flags |= (1 << idx);
                 if (ext->alg == IW_ENCODE_ALG_WEP) {
-                      //  sec.encode_alg[idx] = SEC_ALG_WEP;
                         sec.flags |= SEC_LEVEL;
                         sec.level = SEC_LEVEL_1;
                 } else if (ext->alg == IW_ENCODE_ALG_TKIP) {
-                      //  sec.encode_alg[idx] = SEC_ALG_TKIP;
                         sec.flags |= SEC_LEVEL;
                         sec.level = SEC_LEVEL_2;
                 } else if (ext->alg == IW_ENCODE_ALG_CCMP) {
-                       // sec.encode_alg[idx] = SEC_ALG_CCMP;
                         sec.flags |= SEC_LEVEL;
                         sec.level = SEC_LEVEL_3;
                 }
@@ -778,42 +803,38 @@
                 IEEE80211_DEBUG_WX("%s: reset_port failed\n", dev->name);
                 return -EINVAL;
         }
-
+#endif
         return ret;
 }
+
 int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
-//	printk("\ndkgadfslkdjgalskdf===============>%s(), cmd:%x\n", __FUNCTION__, mlme->cmd);
-#if 1
+
 	switch (mlme->cmd) {
         case IW_MLME_DEAUTH:
 	case IW_MLME_DISASSOC:
-	//	printk("disassoc now\n");
 		ieee80211_disassociate(ieee);
 		break;
 	 default:
                 return -EOPNOTSUPP;
         }
-#endif		
+
+#endif
 	return 0;
 }
 int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
                                struct iw_request_info *info,
                                struct iw_param *data, char *extra)
 {
-/*
-	 struct ieee80211_security sec = {
-                .flags = SEC_AUTH_MODE,
-	}
-*/
-	//printk("set auth:flag:%x, data value:%x\n", data->flags, data->value);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+
 	switch (data->flags & IW_AUTH_INDEX) {
         case IW_AUTH_WPA_VERSION:
 	     /*need to support wpa2 here*/
-		//printk("wpa version:%x\n", data->value);
 		break;
         case IW_AUTH_CIPHER_PAIRWISE:
         case IW_AUTH_CIPHER_GROUP:
@@ -832,13 +853,11 @@
 
 	case IW_AUTH_80211_AUTH_ALG:
 		ieee->open_wep = (data->value&IW_AUTH_ALG_OPEN_SYSTEM)?1:0;
-		//printk("open_wep:%d\n", ieee->open_wep);
 		break;
 
 #if 1
 	case IW_AUTH_WPA_ENABLED:
 		ieee->wpa_enabled = (data->value)?1:0;
-		//printk("enalbe wpa:%d\n", ieee->wpa_enabled);
 		break;
 
 #endif
@@ -850,27 +869,19 @@
 		break;
 	default:
                 return -EOPNOTSUPP;
-	}	
+	}
+#endif
 	return 0;
 }
+#endif
 
-#if 1
 int ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len)
 {
-#if 0
-	printk("====>%s()\n", __FUNCTION__);
-	{
-		int i;
-		for (i=0; i<len; i++)
-		printk("%2x ", ie[i]&0xff);
-		printk("\n");
-	}
-#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	u8 *buf = NULL; 
 	
 	if (!len || len>MAX_WPA_IE_LEN || (len && ie == NULL))
 	{
-	//	printk("return error out, len:%d\n", len);
 	return -EINVAL;
 	}
 	if (len != ie[1]+2) printk("len:%d, ie:%d\n", len, ie[1]);
@@ -890,18 +901,31 @@
 		ieee->wpa_ie = NULL;
 		ieee->wpa_ie_len = 0;
 	}
-//	printk("<=====out %s()\n", __FUNCTION__);
+#endif
 
 	return 0;
 
 }
-#endif
 
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_wx_set_gen_ie);
+#if WIRELESS_EXT >= 18
 EXPORT_SYMBOL(ieee80211_wx_set_mlme);
 EXPORT_SYMBOL(ieee80211_wx_set_auth);
 EXPORT_SYMBOL(ieee80211_wx_set_encode_ext);
+#endif
 EXPORT_SYMBOL(ieee80211_wx_get_scan);
 EXPORT_SYMBOL(ieee80211_wx_set_encode);
 EXPORT_SYMBOL(ieee80211_wx_get_encode);
-
+#else
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_gen_ie);
+#if WIRELESS_EXT >= 18
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_mlme);
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_auth);
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_encode_ext);
+#endif
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_scan);
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_encode);
+EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_encode);
+#endif
diff -ruN rtl8187l_orig/ieee80211/internal.h rtl8187l/ieee80211/internal.h
--- rtl8187l_orig/ieee80211/internal.h	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/internal.h	2009-06-26 09:07:43.857584000 +0200
@@ -0,0 +1,114 @@
+/*
+ * Cryptographic API.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#ifndef _CRYPTO_INTERNAL_H
+#define _CRYPTO_INTERNAL_H
+
+
+#include "rtl_crypto.h"
+#include <linux/mm.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <asm/hardirq.h>
+#include <asm/softirq.h>
+#include <asm/kmap_types.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20))
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		     prefetch(pos->member.next);			\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     prefetch(pos->member.next))
+
+static inline void cond_resched(void)
+{
+	if (need_resched()) {
+		set_current_state(TASK_RUNNING);
+		schedule();
+	}
+}
+#endif
+
+extern enum km_type crypto_km_types[];
+
+static inline enum km_type crypto_kmap_type(int out)
+{
+	return crypto_km_types[(in_softirq() ? 2 : 0) + out];
+}
+
+static inline void *crypto_kmap(struct page *page, int out)
+{
+	return kmap_atomic(page, crypto_kmap_type(out));
+}
+
+static inline void crypto_kunmap(void *vaddr, int out)
+{
+	kunmap_atomic(vaddr, crypto_kmap_type(out));
+}
+
+static inline void crypto_yield(struct crypto_tfm *tfm)
+{
+	if (!in_softirq())
+		cond_resched();
+}
+
+static inline void *crypto_tfm_ctx(struct crypto_tfm *tfm)
+{
+	return (void *)&tfm[1];
+}
+
+struct crypto_alg *crypto_alg_lookup(const char *name);
+
+#ifdef CONFIG_KMOD
+void crypto_alg_autoload(const char *name);
+struct crypto_alg *crypto_alg_mod_lookup(const char *name);
+#else
+static inline struct crypto_alg *crypto_alg_mod_lookup(const char *name)
+{
+	return crypto_alg_lookup(name);
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_HMAC
+int crypto_alloc_hmac_block(struct crypto_tfm *tfm);
+void crypto_free_hmac_block(struct crypto_tfm *tfm);
+#else
+static inline int crypto_alloc_hmac_block(struct crypto_tfm *tfm)
+{
+	return 0;
+}
+
+static inline void crypto_free_hmac_block(struct crypto_tfm *tfm)
+{ }
+#endif
+
+#ifdef CONFIG_PROC_FS
+void __init crypto_init_proc(void);
+#else
+static inline void crypto_init_proc(void)
+{ }
+#endif
+
+int crypto_init_digest_flags(struct crypto_tfm *tfm, u32 flags);
+int crypto_init_cipher_flags(struct crypto_tfm *tfm, u32 flags);
+int crypto_init_compress_flags(struct crypto_tfm *tfm, u32 flags);
+
+int crypto_init_digest_ops(struct crypto_tfm *tfm);
+int crypto_init_cipher_ops(struct crypto_tfm *tfm);
+int crypto_init_compress_ops(struct crypto_tfm *tfm);
+
+void crypto_exit_digest_ops(struct crypto_tfm *tfm);
+void crypto_exit_cipher_ops(struct crypto_tfm *tfm);
+void crypto_exit_compress_ops(struct crypto_tfm *tfm);
+
+#endif	/* _CRYPTO_INTERNAL_H */
+
diff -ruN rtl8187l_orig/ieee80211/kmap_types.h rtl8187l/ieee80211/kmap_types.h
--- rtl8187l_orig/ieee80211/kmap_types.h	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/kmap_types.h	2009-06-26 09:07:43.857584000 +0200
@@ -0,0 +1,20 @@
+#ifndef __KMAP_TYPES_H
+
+#define __KMAP_TYPES_H
+
+
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BH_IRQ,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#define _ASM_KMAP_TYPES_H
+
+#endif
diff -ruN rtl8187l_orig/ieee80211/license rtl8187l/ieee80211/license
--- rtl8187l_orig/ieee80211/license	2011-01-02 18:14:30.735583000 +0100
+++ rtl8187l/ieee80211/license	2009-06-26 09:07:43.857584000 +0200
@@ -1,7 +1,7 @@
 
 "This software program is licensed subject to the GNU General Public License 
 (GPL). Version 2, June 1991, available at 
-<http://www.fsf.org/copyleft/gpl.html>"
+<http:
 
 GNU General Public License 
 
diff -ruN rtl8187l_orig/ieee80211/Makefile rtl8187l/ieee80211/Makefile
--- rtl8187l_orig/ieee80211/Makefile	2011-01-02 18:14:30.744091000 +0100
+++ rtl8187l/ieee80211/Makefile	2009-06-26 09:07:43.857584000 +0200
@@ -3,7 +3,11 @@
 CC = gcc
 KVER  := $(shell uname -r)
 MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/$(NIC_SELECT)
+KSRC := /lib/modules/$(KVER)/build
+PWD = $(shell pwd)
+INSTALL_PREFIX :=
 
+ifneq ($(shell uname -r|cut -d. -f1,2), 2.4)
 EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/wireless
 EXTRA_CFLAGS += -std=gnu89
 EXTRA_CFLAGS += -O2
@@ -11,9 +15,14 @@
 EXTRA_CFLAGS += -DPOLLING_METHOD_FOR_RADIO
 EXTRA_CFLAGS += -DLED
 #EXTRA_CFLAGS += -DLED_SHIN
-EXTRA_CFLAGS += -DSW_ANTE_DIVERSITY
+#EXTRA_CFLAGS += -DSW_ANTE_DIVERSITY
 
-ieee80211-rtl-objs := ieee80211_softmac.o ieee80211_rx.o ieee80211_tx.o ieee80211_wx.o ieee80211_module.o ieee80211_softmac_wx.o
+ieee80211-rtl-objs := ieee80211_softmac.o \
+	ieee80211_rx.o \
+	ieee80211_tx.o \
+	ieee80211_wx.o \
+	ieee80211_module.o \
+	ieee80211_softmac_wx.o
 
 ieee80211_crypt-rtl-objs := ieee80211_crypt.o
 ieee80211_crypt_tkip-rtl-objs := ieee80211_crypt_tkip.o
@@ -26,10 +35,6 @@
 obj-m +=ieee80211_crypt_tkip-rtl.o
 obj-m +=ieee80211_crypt_ccmp-rtl.o
 
-KVER  := $(shell uname -r)
-KSRC := /lib/modules/$(KVER)/build
-PWD = $(shell pwd)
-INSTALL_PREFIX :=
 
 all: modules
 
@@ -56,3 +61,100 @@
 	rm -fr $(MODDESTDIR)
 	depmod -a 
 
+else #2.4 kernel
+
+LD := ld
+CONFIG_FILE := $(KSRC)/include/linux/autoconf.h
+
+CFLAGS += -DLINUX -D__KERNEL__ -DMODULE -O2 -pipe -Wall
+CFLAGS += -I$(KSRC)/include -I.
+#Kernel 2.4.31
+CFLAGS += -DMODVERSIONS -DEXPORT_SYMTAB -include $(KSRC)/include/linux/modversions.h
+#Kernel 2.4.20
+#CFLAGS += -D__NO_VERSION__ -DEXPORT_SYMTAB 
+
+CFLAGS += -DPOLLING_METHOD_FOR_RADIO
+CFLAGS += -DLED
+#CFLAGS += -DLED_SHIN
+#CFLAGS += -DSW_ANTE_DIVERSITY
+
+SMP := $(shell $(CC) $(MODCFLAGS) -E -dM $(CONFIG_FILE) | \
+   grep CONFIG_SMP | awk '{print $$3}')
+ifneq ($(SMP),1)
+   SMP := 0
+endif
+ifeq ($(SMP),1)
+   CFLAGS    += -D__SMP__
+endif
+
+OBJS := ${patsubst %.c, %.o, ${wildcard *.c}}
+all:${OBJS} ieee80211_crypt-rsl.o \
+	michael_mic-rsl.o \
+	aes-rsl.o \
+	ieee80211_crypt_wep-rsl.o \
+	ieee80211_crypt_tkip-rsl.o \
+	ieee80211_crypt_ccmp-rsl.o \
+	crypto-rsl.o ieee80211-rsl.o
+
+ieee80211_crypt-rsl.o: ieee80211_crypt.o
+	mv $^ $@	
+
+michael_mic-rsl.o: michael_mic.o
+	mv $^ $@
+
+aes-rsl.o: aes.o
+	mv $^ $@
+
+ieee80211_crypt_wep-rsl.o: ieee80211_crypt_wep.o
+	mv $^ $@
+
+ieee80211_crypt_tkip-rsl.o: ieee80211_crypt_tkip.o
+	mv $^ $@
+
+ieee80211_crypt_ccmp-rsl.o: ieee80211_crypt_ccmp.o
+	mv $^ $@
+
+crypto-rsl.o: arc4.o \
+	api.o \
+	autoload.o \
+	cipher.o \
+	compress.o \
+	digest.o \
+	scatterwalk.o \
+	proc.o
+	$(LD) -r $^ -o $@
+
+ieee80211-rsl.o: ieee80211_rx.o \
+	ieee80211_tx.o \
+	ieee80211_wx.o \
+	ieee80211_module.o \
+	ieee80211_softmac_wx.o \
+	ieee80211_softmac.o 
+	$(LD) -r $^ -o $@
+install:
+	rm -fr $(MODDESTDIR)
+	mkdir -p $(MODDESTDIR)
+	@install -p -m 644 ieee80211_crypt-rsl.o $(MODDESTDIR)
+	@install -p -m 644 crypto-rsl.o $(MODDESTDIR)
+	@install -p -m 644 michael_mic-rsl.o $(MODDESTDIR)
+	@install -p -m 644 aes-rsl.o $(MODDESTDIR)
+	@install -p -m 644 ieee80211_crypt_wep-rsl.o $(MODDESTDIR)
+	@install -p -m 644 ieee80211_crypt_tkip-rsl.o $(MODDESTDIR)
+	@install -p -m 644 ieee80211_crypt_ccmp-rsl.o $(MODDESTDIR)
+	@install -p -m 644 ieee80211-rsl.o $(MODDESTDIR)
+	/sbin/depmod -a ${shell uname -r}
+
+uninstall:
+	rm -fr $(MODDESTDIR)
+	/sbin/depmod -a ${shell uname -r}
+
+clean:
+	rm -f *.mod.c *.mod *.o .*.cmd *.ko *~
+	rm -rf $(PWD)/tmp
+	rm -rf *~
+	rm -fr Module.symvers
+	rm -fr modules.order
+	rm -fr Module.markers
+	rm -rf tags
+
+endif
diff -ruN rtl8187l_orig/ieee80211/michael_mic.c rtl8187l/ieee80211/michael_mic.c
--- rtl8187l_orig/ieee80211/michael_mic.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/michael_mic.c	2009-06-26 09:07:43.857584000 +0200
@@ -0,0 +1,193 @@
+/*
+ * Cryptographic API
+ *
+ * Michael MIC (IEEE 802.11i/TKIP) keyed digest
+ *
+ * Copyright (c) 2004 Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include "rtl_crypto.h"
+
+
+struct michael_mic_ctx {
+	u8 pending[4];
+	size_t pending_len;
+
+	u32 l, r;
+};
+
+
+static inline u32 rotl(u32 val, int bits)
+{
+	return (val << bits) | (val >> (32 - bits));
+}
+
+
+static inline u32 rotr(u32 val, int bits)
+{
+	return (val >> bits) | (val << (32 - bits));
+}
+
+
+static inline u32 xswap(u32 val)
+{
+	return ((val & 0x00ff00ff) << 8) | ((val & 0xff00ff00) >> 8);
+}
+
+
+#define michael_block(l, r)	\
+do {				\
+	r ^= rotl(l, 17);	\
+	l += r;			\
+	r ^= xswap(l);		\
+	l += r;			\
+	r ^= rotl(l, 3);	\
+	l += r;			\
+	r ^= rotr(l, 2);	\
+	l += r;			\
+} while (0)
+
+
+static inline u32 get_le32(const u8 *p)
+{
+	return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);
+}
+
+
+static inline void put_le32(u8 *p, u32 v)
+{
+	p[0] = v;
+	p[1] = v >> 8;
+	p[2] = v >> 16;
+	p[3] = v >> 24;
+}
+
+
+static void michael_init(void *ctx)
+{
+	struct michael_mic_ctx *mctx = ctx;
+	mctx->pending_len = 0;
+}
+
+
+static void michael_update(void *ctx, const u8 *data, unsigned int len)
+{
+	struct michael_mic_ctx *mctx = ctx;
+
+	if (mctx->pending_len) {
+		int flen = 4 - mctx->pending_len;
+		if (flen > len)
+			flen = len;
+		memcpy(&mctx->pending[mctx->pending_len], data, flen);
+		mctx->pending_len += flen;
+		data += flen;
+		len -= flen;
+
+		if (mctx->pending_len < 4)
+			return;
+
+		mctx->l ^= get_le32(mctx->pending);
+		michael_block(mctx->l, mctx->r);
+		mctx->pending_len = 0;
+	}
+
+	while (len >= 4) {
+		mctx->l ^= get_le32(data);
+		michael_block(mctx->l, mctx->r);
+		data += 4;
+		len -= 4;
+	}
+
+	if (len > 0) {
+		mctx->pending_len = len;
+		memcpy(mctx->pending, data, len);
+	}
+}
+
+
+static void michael_final(void *ctx, u8 *out)
+{
+	struct michael_mic_ctx *mctx = ctx;
+	u8 *data = mctx->pending;
+
+	/* Last block and padding (0x5a, 4..7 x 0) */
+	switch (mctx->pending_len) {
+	case 0:
+		mctx->l ^= 0x5a;
+		break;
+	case 1:
+		mctx->l ^= data[0] | 0x5a00;
+		break;
+	case 2:
+		mctx->l ^= data[0] | (data[1] << 8) | 0x5a0000;
+		break;
+	case 3:
+		mctx->l ^= data[0] | (data[1] << 8) | (data[2] << 16) |
+			0x5a000000;
+		break;
+	}
+	michael_block(mctx->l, mctx->r);
+	/* l ^= 0; */
+	michael_block(mctx->l, mctx->r);
+
+	put_le32(out, mctx->l);
+	put_le32(out + 4, mctx->r);
+}
+
+
+static int michael_setkey(void *ctx, const u8 *key, unsigned int keylen,
+			  u32 *flags)
+{
+	struct michael_mic_ctx *mctx = ctx;
+	if (keylen != 8) {
+		if (flags)
+			*flags = CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+	mctx->l = get_le32(key);
+	mctx->r = get_le32(key + 4);
+	return 0;
+}
+
+
+static struct crypto_alg michael_mic_alg = {
+	.cra_name	= "michael_mic",
+	.cra_flags	= CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize	= 8,
+	.cra_ctxsize	= sizeof(struct michael_mic_ctx),
+	.cra_module	= THIS_MODULE,
+	.cra_list	= LIST_HEAD_INIT(michael_mic_alg.cra_list),
+	.cra_u		= { .digest = {
+	.dia_digestsize	= 8,
+	.dia_init	= michael_init,
+	.dia_update	= michael_update,
+	.dia_final	= michael_final,
+	.dia_setkey	= michael_setkey } }
+};
+
+
+static int __init michael_mic_init(void)
+{
+	return crypto_register_alg(&michael_mic_alg);
+}
+
+
+static void __exit michael_mic_exit(void)
+{
+	crypto_unregister_alg(&michael_mic_alg);
+}
+
+
+module_init(michael_mic_init);
+module_exit(michael_mic_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Michael MIC");
+MODULE_AUTHOR("Jouni Malinen <jkmaline@cc.hut.fi>");
diff -ruN rtl8187l_orig/ieee80211/proc.c rtl8187l/ieee80211/proc.c
--- rtl8187l_orig/ieee80211/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/proc.c	2009-06-26 09:07:43.857584000 +0200
@@ -0,0 +1,115 @@
+/*
+ * Scatterlist Cryptographic API.
+ *
+ * Procfs information.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include <linux/init.h>
+#include "rtl_crypto.h"
+#include <linux/rwsem.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "internal.h"
+
+extern struct list_head crypto_alg_list;
+extern struct rw_semaphore crypto_alg_sem;
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	struct list_head *v;
+	loff_t n = *pos;
+
+	down_read(&crypto_alg_sem);
+	list_for_each(v, &crypto_alg_list)
+		if (!n--)
+			return list_entry(v, struct crypto_alg, cra_list);
+	return NULL;
+}
+
+static void *c_next(struct seq_file *m, void *p, loff_t *pos)
+{
+	struct list_head *v = p;
+	
+	(*pos)++;
+	v = v->next;
+	return (v == &crypto_alg_list) ?
+		NULL : list_entry(v, struct crypto_alg, cra_list);
+}
+
+static void c_stop(struct seq_file *m, void *p)
+{
+	up_read(&crypto_alg_sem);
+}
+
+static int c_show(struct seq_file *m, void *p)
+{
+	struct crypto_alg *alg = (struct crypto_alg *)p;
+	
+	seq_printf(m, "name         : %s\n", alg->cra_name);
+	seq_printf(m, "module       : %s\n",
+		   (alg->cra_module ?
+		    alg->cra_module->name :
+		    "kernel"));
+	
+	switch (alg->cra_flags & CRYPTO_ALG_TYPE_MASK) {
+	case CRYPTO_ALG_TYPE_CIPHER:
+		seq_printf(m, "type         : cipher\n");
+		seq_printf(m, "blocksize    : %u\n", alg->cra_blocksize);
+		seq_printf(m, "min keysize  : %u\n",
+					alg->cra_cipher.cia_min_keysize);
+		seq_printf(m, "max keysize  : %u\n",
+					alg->cra_cipher.cia_max_keysize);
+		break;
+		
+	case CRYPTO_ALG_TYPE_DIGEST:
+		seq_printf(m, "type         : digest\n");
+		seq_printf(m, "blocksize    : %u\n", alg->cra_blocksize);
+		seq_printf(m, "digestsize   : %u\n",
+		           alg->cra_digest.dia_digestsize);
+		break;
+	case CRYPTO_ALG_TYPE_COMPRESS:
+		seq_printf(m, "type         : compression\n");
+		break;
+	default:
+		seq_printf(m, "type         : unknown\n");
+		break;
+	}
+
+	seq_putc(m, '\n');
+	return 0;
+}
+
+static struct seq_operations crypto_seq_ops = {
+	.start		= c_start,
+	.next		= c_next,
+	.stop		= c_stop,
+	.show		= c_show
+};
+
+static int crypto_info_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &crypto_seq_ops);
+}
+        
+static struct file_operations proc_crypto_ops = {
+	.open		= crypto_info_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release
+};
+
+void __init crypto_init_proc(void)
+{
+	struct proc_dir_entry *proc;
+	
+	proc = create_proc_entry("crypto", 0, NULL);
+	if (proc)
+		proc->proc_fops = &proc_crypto_ops;
+}
diff -ruN rtl8187l_orig/ieee80211/readme rtl8187l/ieee80211/readme
--- rtl8187l_orig/ieee80211/readme	2011-01-02 18:14:30.744091000 +0100
+++ rtl8187l/ieee80211/readme	1970-01-01 01:00:00.000000000 +0100
@@ -1,162 +0,0 @@
-What this layer should do
-
-- It mantain the old mechanism as alternative, so the
-  ipw2100 driver works with really few changes.
-- Encapsulate / Decapsulate ieee80211 packet 
-- Handle fragmentation 
-- Optionally provide an alterantive mechanism for netif queue stop/wake, 
-  so that the ieee80211 layer will pass one fragment per time instead of
-  one txb struct per time. so the driver can stop the queue in the middle
-  of a packet.
-- Provide two different TX interfaces for cards that can handle management
-  frames on one HW queue, and data on another, and for cards that have only
-  one HW queue  (the latter untested and very, very rough).
-- Optionally provide the logic for handling IBSS/MASTER/MONITOR/BSS modes
-  and for the channel, essid and wap get/set wireless extension requests.
-  so that the driver has only to change channel when the ieee stack tell it.
-- Optionally provide a scanning mechanism so that the driver has not to
-  worry about this, just implement the set channel calback and pass 
-  frames to the upper layer
-- Optionally provide the bss client protocol handshaking (just with open 
-  authentication)
-- Optionally provide the probe request send mechanism
-- Optionally provide the bss master mode logic to handle association
-  protocol (only open authentication) and probe responses.
-- SW wep encryption (with open authentication)
-- It collects some stats
-- It provides beacons to the card when it ask for them
-
-What this layer doesn't do (yet)
-- Perform shared authentication
-- Have full support for master mode (the AP should loop back in the air
-  frames from an associated client to another. This could be done easily
-  with few lines of code, and it is done in my previous version of the 
-  stach, but a table of association must be keept and a disassociation
-  policy must be decided and implemented.
-- Handle cleanly the full ieee 802.11 protocol. In AP mode it never
-  disassociate clients, and it is really prone to always allow access.
-  In bss client mode it is a bit rough with AP deauth and disassoc requests.
-- It has not any entry point to view the collected stats.
-- Altought it takes care of the card supported rates in the management frame
-  it sends, support for rate changing on TXed packet is not complete.
-- Give up once associated in bss client mode (it never detect a
-  signal loss condition to disassociate and restart scanning)
-- Provide a mechanism for enabling the TX in monitor mode, so
-  userspace programs can TX raw packets.
-- Provide a mechanism for cards that need that the SW take care of beacon
-  TX completely, in sense that the SW has to enqueue by itself beacons
-  to the card so it TX them (if any...)
-APIs
-
-Callback functions in the original stack has been mantained.
-following has been added (from ieee80211.h)
-
-	/* Softmac-generated frames (mamagement) are TXed via this 
-	 * callback if the flag IEEE_SOFTMAC_SINGLE_QUEUE is 
-	 * not set. As some cards may have different HW queues that 
-	 * one might want to use for data and management frames
-	 * the option to have two callbacks might be useful.
-	 * This fucntion can't sleep.
-	 */
-	int (*softmac_hard_start_xmit)(struct sk_buff *skb,
-			       struct net_device *dev);
-	
-	/* used instead of hard_start_xmit (not softmac_hard_start_xmit)
-	 * if the IEEE_SOFTMAC_TX_QUEUE feature is used to TX data
-	 * frames. I the option IEEE_SOFTMAC_SINGLE_QUEUE is also set
-	 * then also management frames are sent via this callback.
-	 * This function can't sleep.
-	 */    
-	void (*softmac_data_hard_start_xmit)(struct sk_buff *skb,
-			       struct net_device *dev);
-
-	/* stops the HW queue for DATA frames. Useful to avoid
-	 * waste time to TX data frame when we are reassociating
-	 * This function can sleep.
-	 */	 
-	void (*data_hard_stop)(struct net_device *dev);
-	
-	/* OK this is complementar to data_poll_hard_stop */
-	void (*data_hard_resume)(struct net_device *dev);
-	
-	/* ask to the driver to retune the radio .
-	 * This function can sleep. the driver should ensure
-	 * the radio has been swithced before return.
-	 */
-	void (*set_chan)(struct net_device *dev,short ch);
-	
-	/* These are not used if the ieee stack takes care of
-	 * scanning (IEEE_SOFTMAC_SCAN feature set). 
-	 * In this case only the set_chan is used.
-	 *
-	 * The syncro version is similar to the start_scan but
-	 * does not return until all channels has been scanned.
-	 * this is called in user context and should sleep, 
-	 * it is called in a work_queue when swithcing to ad-hoc mode
-	 * or in behalf of iwlist scan when the card is associated 
-	 * and root user ask for a scan. 
-	 * the fucntion stop_scan should stop both the syncro and
-	 * background scanning and can sleep.
-	 * The fucntion start_scan should initiate the background 
-	 * scanning and can't sleep.
-	 */ 
-	void (*scan_syncro)(struct net_device *dev);
-	void (*start_scan)(struct net_device *dev);
-	void (*stop_scan)(struct net_device *dev);
-	
-	/* indicate the driver that the link state is changed
-	 * for example it may indicate the card is associated now.
-	 * Driver might be interested in this to apply RX filter 
-	 * rules or simply light the LINK led 
-	 */
-	void (*link_change)(struct net_device *dev);
-	
-Functions hard_data_[resume/stop] are optional and should not be used
-if the driver decides to uses data+management frames enqueue in a 
-single HQ queue (thus using just the softmac_hard_data_start_xmit 
-callback).
- 
-Function that the driver can use are:
-
-ieee80211_get_beacon             - this is called by the driver when
-                                   the HW needs a beacon.
-ieee80211_softmac_start_protocol - this should normally be called in the
-                                   driver open function
-ieee80211_softmac_stop_protocol  - the opposite of the above
-ieee80211_wake_queue             - this is similar to netif_wake_queue 
-ieee80211_reset_queue            - this throw away fragments pending(if any)
-ieee80211_stop_queue             - this is similar to netif_stop_queue
-
-
-known BUGS:
-- When performing syncro scan (possiblily when swithcing to ad-hoc mode
-  and when running iwlist scan when associated) there is still an odd
-  behaviour.. I have not looked in this more accurately (yet).
-
-locking:
-locking is done by means of three structures.
-1- ieee->lock (by means of spin_[un]lock_irq[save/restore]
-2- ieee->wx_sem
-3- ieee->scan_sem
-
-the lock 1 is what protect most of the critical sections in the ieee stack.
-the lock 2 is used to avoid that more than one of the SET wireless extension 
-handlers (as well as start/stop protocol function) are running at the same time. 
-the lock 1 is used when we need to modify or read the shared data in the wx handlers. 
-In other words the lock 2 will prevent one SET action will run across another SET
-action (by make sleep the 2nd one) but allow GET actions, while the lock 1
-make atomic those little shared data access in both GET and SET operation.
-So get operation will be never be delayed really: they will never sleep..
-Furthermore in the top of some SET operations a flag is set before acquiring
-the lock. This is an help to make the previous running SET operation to
-finish faster if needed (just in case the second one will totally undo the
-first, so there is not need to complete the 1st really.. ).
-The background scanning mechaninsm is protected by the lock 1 except for the
-workqueue. this wq is here just to let the set_chan callback sleep (I thinked it
-might be appreciated by USB network card driver developer). In this case the lock 3 
-take its turn. 
-Thus the stop function needs both the locks.
-Funny in the syncro scan the lock 2 play its role (as both the syncro_scan
-function and the stop scan function are called with this semaphore held).
-
-
diff -ruN rtl8187l_orig/ieee80211/rtl_crypto.h rtl8187l/ieee80211/rtl_crypto.h
--- rtl8187l_orig/ieee80211/rtl_crypto.h	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/rtl_crypto.h	2009-06-26 09:07:43.857584000 +0200
@@ -0,0 +1,399 @@
+/*
+ * Scatterlist Cryptographic API.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * Copyright (c) 2002 David S. Miller (davem@redhat.com)
+ *
+ * Portions derived from Cryptoapi, by Alexander Kjeldaas <astor@fast.no>
+ * and Nettle, by Niels M鰈ler.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#ifndef _LINUX_CRYPTO_H
+#define _LINUX_CRYPTO_H
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/string.h>
+#include <asm/page.h>
+#include <asm/errno.h>
+
+#define crypto_register_alg crypto_register_alg_rsl
+#define crypto_unregister_alg crypto_unregister_alg_rsl
+#define crypto_alloc_tfm crypto_alloc_tfm_rsl
+#define crypto_free_tfm crypto_free_tfm_rsl
+#define crypto_alg_available crypto_alg_available_rsl
+
+/*
+ * Algorithm masks and types.
+ */
+#define CRYPTO_ALG_TYPE_MASK		0x000000ff
+#define CRYPTO_ALG_TYPE_CIPHER		0x00000001
+#define CRYPTO_ALG_TYPE_DIGEST		0x00000002
+#define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
+
+/*
+ * Transform masks and values (for crt_flags).
+ */
+#define CRYPTO_TFM_MODE_MASK		0x000000ff
+#define CRYPTO_TFM_REQ_MASK		0x000fff00
+#define CRYPTO_TFM_RES_MASK		0xfff00000
+
+#define CRYPTO_TFM_MODE_ECB		0x00000001
+#define CRYPTO_TFM_MODE_CBC		0x00000002
+#define CRYPTO_TFM_MODE_CFB		0x00000004
+#define CRYPTO_TFM_MODE_CTR		0x00000008
+
+#define CRYPTO_TFM_REQ_WEAK_KEY		0x00000100
+#define CRYPTO_TFM_RES_WEAK_KEY		0x00100000
+#define CRYPTO_TFM_RES_BAD_KEY_LEN   	0x00200000
+#define CRYPTO_TFM_RES_BAD_KEY_SCHED 	0x00400000
+#define CRYPTO_TFM_RES_BAD_BLOCK_LEN 	0x00800000
+#define CRYPTO_TFM_RES_BAD_FLAGS 	0x01000000
+
+/*
+ * Miscellaneous stuff.
+ */
+#define CRYPTO_UNSPEC			0
+#define CRYPTO_MAX_ALG_NAME		64
+
+struct scatterlist;
+
+/*
+ * Algorithms: modular crypto algorithm implementations, managed
+ * via crypto_register_alg() and crypto_unregister_alg().
+ */
+struct cipher_alg {
+	unsigned int cia_min_keysize;
+	unsigned int cia_max_keysize;
+	int (*cia_setkey)(void *ctx, const u8 *key,
+	                  unsigned int keylen, u32 *flags);
+	void (*cia_encrypt)(void *ctx, u8 *dst, const u8 *src);
+	void (*cia_decrypt)(void *ctx, u8 *dst, const u8 *src);
+};
+
+struct digest_alg {
+	unsigned int dia_digestsize;
+	void (*dia_init)(void *ctx);
+	void (*dia_update)(void *ctx, const u8 *data, unsigned int len);
+	void (*dia_final)(void *ctx, u8 *out);
+	int (*dia_setkey)(void *ctx, const u8 *key,
+	                  unsigned int keylen, u32 *flags);
+};
+
+struct compress_alg {
+	int (*coa_init)(void *ctx);
+	void (*coa_exit)(void *ctx);
+	int (*coa_compress)(void *ctx, const u8 *src, unsigned int slen,
+	                    u8 *dst, unsigned int *dlen);
+	int (*coa_decompress)(void *ctx, const u8 *src, unsigned int slen,
+	                      u8 *dst, unsigned int *dlen);
+};
+
+#define cra_cipher	cra_u.cipher
+#define cra_digest	cra_u.digest
+#define cra_compress	cra_u.compress
+
+struct crypto_alg {
+	struct list_head cra_list;
+	u32 cra_flags;
+	unsigned int cra_blocksize;
+	unsigned int cra_ctxsize;
+	const char cra_name[CRYPTO_MAX_ALG_NAME];
+
+	union {
+		struct cipher_alg cipher;
+		struct digest_alg digest;
+		struct compress_alg compress;
+	} cra_u;
+	
+	struct module *cra_module;
+};
+
+/*
+ * Algorithm registration interface.
+ */
+int crypto_register_alg(struct crypto_alg *alg);
+int crypto_unregister_alg(struct crypto_alg *alg);
+
+/*
+ * Algorithm query interface.
+ */
+int crypto_alg_available(const char *name, u32 flags);
+
+/*
+ * Transforms: user-instantiated objects which encapsulate algorithms
+ * and core processing logic.  Managed via crypto_alloc_tfm() and
+ * crypto_free_tfm(), as well as the various helpers below.
+ */
+struct crypto_tfm;
+
+struct cipher_tfm {
+	void *cit_iv;
+	unsigned int cit_ivsize;
+	u32 cit_mode;
+	int (*cit_setkey)(struct crypto_tfm *tfm,
+	                  const u8 *key, unsigned int keylen);
+	int (*cit_encrypt)(struct crypto_tfm *tfm,
+			   struct scatterlist *dst,
+			   struct scatterlist *src,
+			   unsigned int nbytes);
+	int (*cit_encrypt_iv)(struct crypto_tfm *tfm,
+	                      struct scatterlist *dst,
+	                      struct scatterlist *src,
+	                      unsigned int nbytes, u8 *iv);
+	int (*cit_decrypt)(struct crypto_tfm *tfm,
+			   struct scatterlist *dst,
+			   struct scatterlist *src,
+			   unsigned int nbytes);
+	int (*cit_decrypt_iv)(struct crypto_tfm *tfm,
+			   struct scatterlist *dst,
+			   struct scatterlist *src,
+			   unsigned int nbytes, u8 *iv);
+	void (*cit_xor_block)(u8 *dst, const u8 *src);
+};
+
+struct digest_tfm {
+	void (*dit_init)(struct crypto_tfm *tfm);
+	void (*dit_update)(struct crypto_tfm *tfm,
+	                   struct scatterlist *sg, unsigned int nsg);
+	void (*dit_final)(struct crypto_tfm *tfm, u8 *out);
+	void (*dit_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
+	                   unsigned int nsg, u8 *out);
+	int (*dit_setkey)(struct crypto_tfm *tfm,
+	                  const u8 *key, unsigned int keylen);
+#ifdef CONFIG_CRYPTO_HMAC
+	void *dit_hmac_block;
+#endif
+};
+
+struct compress_tfm {
+	int (*cot_compress)(struct crypto_tfm *tfm,
+	                    const u8 *src, unsigned int slen,
+	                    u8 *dst, unsigned int *dlen);
+	int (*cot_decompress)(struct crypto_tfm *tfm,
+	                      const u8 *src, unsigned int slen,
+	                      u8 *dst, unsigned int *dlen);
+};
+
+#define crt_cipher	crt_u.cipher
+#define crt_digest	crt_u.digest
+#define crt_compress	crt_u.compress
+
+struct crypto_tfm {
+
+	u32 crt_flags;
+	
+	union {
+		struct cipher_tfm cipher;
+		struct digest_tfm digest;
+		struct compress_tfm compress;
+	} crt_u;
+	
+	struct crypto_alg *__crt_alg;
+};
+
+/* 
+ * Transform user interface.
+ */
+ 
+/*
+ * crypto_alloc_tfm() will first attempt to locate an already loaded algorithm.
+ * If that fails and the kernel supports dynamically loadable modules, it
+ * will then attempt to load a module of the same name or alias.  A refcount
+ * is grabbed on the algorithm which is then associated with the new transform.
+ *
+ * crypto_free_tfm() frees up the transform and any associated resources,
+ * then drops the refcount on the associated algorithm.
+ */
+struct crypto_tfm *crypto_alloc_tfm(const char *alg_name, u32 tfm_flags);
+void crypto_free_tfm(struct crypto_tfm *tfm);
+
+/*
+ * Transform helpers which query the underlying algorithm.
+ */
+static inline const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)
+{
+	return tfm->__crt_alg->cra_name;
+}
+
+static inline const char *crypto_tfm_alg_modname(struct crypto_tfm *tfm)
+{
+	struct crypto_alg *alg = tfm->__crt_alg;
+	
+	if (alg->cra_module)
+		return alg->cra_module->name;
+	else
+		return NULL;
+}
+
+static inline u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)
+{
+	return tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;
+}
+
+static inline unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return tfm->__crt_alg->cra_cipher.cia_min_keysize;
+}
+
+static inline unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return tfm->__crt_alg->cra_cipher.cia_max_keysize;
+}
+
+static inline unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return tfm->crt_cipher.cit_ivsize;
+}
+
+static inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)
+{
+	return tfm->__crt_alg->cra_blocksize;
+}
+
+static inline unsigned int crypto_tfm_alg_digestsize(struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	return tfm->__crt_alg->cra_digest.dia_digestsize;
+}
+
+/*
+ * API wrappers.
+ */
+static inline void crypto_digest_init(struct crypto_tfm *tfm)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	tfm->crt_digest.dit_init(tfm);
+}
+
+static inline void crypto_digest_update(struct crypto_tfm *tfm,
+                                        struct scatterlist *sg,
+                                        unsigned int nsg)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	tfm->crt_digest.dit_update(tfm, sg, nsg);
+}
+
+static inline void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	tfm->crt_digest.dit_final(tfm, out);
+}
+
+static inline void crypto_digest_digest(struct crypto_tfm *tfm,
+                                        struct scatterlist *sg,
+                                        unsigned int nsg, u8 *out)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	tfm->crt_digest.dit_digest(tfm, sg, nsg, out);
+}
+
+static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
+                                       const u8 *key, unsigned int keylen)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	if (tfm->crt_digest.dit_setkey == NULL)
+		return -ENOSYS;
+	return tfm->crt_digest.dit_setkey(tfm, key, keylen);
+}
+
+static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
+                                       const u8 *key, unsigned int keylen)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return tfm->crt_cipher.cit_setkey(tfm, key, keylen);
+}
+
+static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
+                                        struct scatterlist *dst,
+                                        struct scatterlist *src,
+                                        unsigned int nbytes)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return tfm->crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
+}                                        
+
+static inline int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
+                                           struct scatterlist *dst,
+                                           struct scatterlist *src,
+                                           unsigned int nbytes, u8 *iv)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	BUG_ON(tfm->crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
+	return tfm->crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
+}                                        
+
+static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
+                                        struct scatterlist *dst,
+                                        struct scatterlist *src,
+                                        unsigned int nbytes)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	return tfm->crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
+}
+
+static inline int crypto_cipher_decrypt_iv(struct crypto_tfm *tfm,
+                                           struct scatterlist *dst,
+                                           struct scatterlist *src,
+                                           unsigned int nbytes, u8 *iv)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	BUG_ON(tfm->crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
+	return tfm->crt_cipher.cit_decrypt_iv(tfm, dst, src, nbytes, iv);
+}
+
+static inline void crypto_cipher_set_iv(struct crypto_tfm *tfm,
+                                        const u8 *src, unsigned int len)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	memcpy(tfm->crt_cipher.cit_iv, src, len);
+}
+
+static inline void crypto_cipher_get_iv(struct crypto_tfm *tfm,
+                                        u8 *dst, unsigned int len)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
+	memcpy(dst, tfm->crt_cipher.cit_iv, len);
+}
+
+static inline int crypto_comp_compress(struct crypto_tfm *tfm,
+                                       const u8 *src, unsigned int slen,
+                                       u8 *dst, unsigned int *dlen)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_COMPRESS);
+	return tfm->crt_compress.cot_compress(tfm, src, slen, dst, dlen);
+}
+
+static inline int crypto_comp_decompress(struct crypto_tfm *tfm,
+                                         const u8 *src, unsigned int slen,
+                                         u8 *dst, unsigned int *dlen)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_COMPRESS);
+	return tfm->crt_compress.cot_decompress(tfm, src, slen, dst, dlen);
+}
+
+/*
+ * HMAC support.
+ */
+#ifdef CONFIG_CRYPTO_HMAC
+void crypto_hmac_init(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen);
+void crypto_hmac_update(struct crypto_tfm *tfm,
+                        struct scatterlist *sg, unsigned int nsg);
+void crypto_hmac_final(struct crypto_tfm *tfm, u8 *key,
+                       unsigned int *keylen, u8 *out);
+void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen,
+                 struct scatterlist *sg, unsigned int nsg, u8 *out);
+#endif	/* CONFIG_CRYPTO_HMAC */
+
+#endif	/* _LINUX_CRYPTO_H */
+
diff -ruN rtl8187l_orig/ieee80211/scatterwalk.c rtl8187l/ieee80211/scatterwalk.c
--- rtl8187l_orig/ieee80211/scatterwalk.c	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/scatterwalk.c	2009-06-26 09:07:43.861605000 +0200
@@ -0,0 +1,126 @@
+/*
+ * Cryptographic API.
+ *
+ * Cipher operations.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *               2002 Adam J. Richter <adam@yggdrasil.com>
+ *               2004 Jean-Luc Cooke <jlcooke@certainkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+#include "kmap_types.h"
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <asm/scatterlist.h>
+#include "internal.h"
+#include "scatterwalk.h"
+
+enum km_type crypto_km_types[] = {
+	KM_USER0,
+	KM_USER1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+};
+
+void *scatterwalk_whichbuf(struct scatter_walk *walk, unsigned int nbytes, void *scratch)
+{
+	if (nbytes <= walk->len_this_page &&
+	    (((unsigned long)walk->data) & (PAGE_CACHE_SIZE - 1)) + nbytes <=
+	    PAGE_CACHE_SIZE)
+		return walk->data;
+	else
+		return scratch;
+}
+
+static void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)
+{
+	if (out)
+		memcpy(sgdata, buf, nbytes);
+	else
+		memcpy(buf, sgdata, nbytes);
+}
+
+void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg)
+{
+	unsigned int rest_of_page;
+
+	walk->sg = sg;
+
+	walk->page = sg->page;
+	walk->len_this_segment = sg->length;
+
+	rest_of_page = PAGE_CACHE_SIZE - (sg->offset & (PAGE_CACHE_SIZE - 1));
+	walk->len_this_page = min(sg->length, rest_of_page);
+	walk->offset = sg->offset;
+}
+
+void scatterwalk_map(struct scatter_walk *walk, int out)
+{
+	walk->data = crypto_kmap(walk->page, out) + walk->offset;
+}
+
+static void scatterwalk_pagedone(struct scatter_walk *walk, int out,
+				 unsigned int more)
+{
+	/* walk->data may be pointing the first byte of the next page;
+	   however, we know we transfered at least one byte.  So,
+	   walk->data - 1 will be a virtual address in the mapped page. */
+
+	if (out)
+		flush_dcache_page(walk->page);
+
+	if (more) {
+		walk->len_this_segment -= walk->len_this_page;
+
+		if (walk->len_this_segment) {
+			walk->page++;
+			walk->len_this_page = min(walk->len_this_segment,
+						  (unsigned)PAGE_CACHE_SIZE);
+			walk->offset = 0;
+		}
+		else
+			scatterwalk_start(walk, sg_next(walk->sg));
+	}
+}
+
+void scatterwalk_done(struct scatter_walk *walk, int out, int more)
+{
+	crypto_kunmap(walk->data, out);
+	if (walk->len_this_page == 0 || !more)
+		scatterwalk_pagedone(walk, out, more);
+}
+
+/*
+ * Do not call this unless the total length of all of the fragments
+ * has been verified as multiple of the block size.
+ */
+int scatterwalk_copychunks(void *buf, struct scatter_walk *walk,
+			   size_t nbytes, int out)
+{
+	if (buf != walk->data) {
+		while (nbytes > walk->len_this_page) {
+			memcpy_dir(buf, walk->data, walk->len_this_page, out);
+			buf += walk->len_this_page;
+			nbytes -= walk->len_this_page;
+
+			crypto_kunmap(walk->data, out);
+			scatterwalk_pagedone(walk, out, 1);
+			scatterwalk_map(walk, out);
+		}
+
+		memcpy_dir(buf, walk->data, nbytes, out);
+	}
+
+	walk->offset += nbytes;
+	walk->len_this_page -= nbytes;
+	walk->len_this_segment -= nbytes;
+	return 0;
+}
diff -ruN rtl8187l_orig/ieee80211/scatterwalk.h rtl8187l/ieee80211/scatterwalk.h
--- rtl8187l_orig/ieee80211/scatterwalk.h	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187l/ieee80211/scatterwalk.h	2009-06-26 09:07:43.861605000 +0200
@@ -0,0 +1,51 @@
+/*
+ * Cryptographic API.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * Copyright (c) 2002 Adam J. Richter <adam@yggdrasil.com>
+ * Copyright (c) 2004 Jean-Luc Cooke <jlcooke@certainkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_SCATTERWALK_H
+#define _CRYPTO_SCATTERWALK_H
+#include <linux/mm.h>
+#include <asm/scatterlist.h>
+
+struct scatter_walk {
+	struct scatterlist	*sg;
+	struct page		*page;
+	void			*data;
+	unsigned int		len_this_page;
+	unsigned int		len_this_segment;
+	unsigned int		offset;
+};
+
+/* Define sg_next is an inline routine now in case we want to change
+   scatterlist to a linked list later. */
+static inline struct scatterlist *sg_next(struct scatterlist *sg)
+{
+	return sg + 1;
+}
+
+static inline int scatterwalk_samebuf(struct scatter_walk *walk_in,
+				      struct scatter_walk *walk_out,
+				      void *src_p, void *dst_p)
+{
+	return walk_in->page == walk_out->page &&
+	       walk_in->offset == walk_out->offset &&
+	       walk_in->data == src_p && walk_out->data == dst_p;
+}
+
+void *scatterwalk_whichbuf(struct scatter_walk *walk, unsigned int nbytes, void *scratch);
+void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg);
+int scatterwalk_copychunks(void *buf, struct scatter_walk *walk, size_t nbytes, int out);
+void scatterwalk_map(struct scatter_walk *walk, int out);
+void scatterwalk_done(struct scatter_walk *walk, int out, int more);
+
+#endif  /* _CRYPTO_SCATTERWALK_H */
diff -ruN rtl8187l_orig/rtl8187/changes rtl8187l/rtl8187/changes
--- rtl8187l_orig/rtl8187/changes	2011-01-02 18:14:31.055768000 +0100
+++ rtl8187l/rtl8187/changes	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-v 0.1
-
-First version.
-This is based on the rtl8180-sa2400 pre-0.22-CVS code..
-
diff -ruN rtl8187l_orig/rtl8187/install rtl8187l/rtl8187/install
--- rtl8187l_orig/rtl8187/install	2011-01-02 18:14:31.051505000 +0100
+++ rtl8187l/rtl8187/install	1970-01-01 01:00:00.000000000 +0100
@@ -1,239 +0,0 @@
-    Installing the rtl8180-sa2400 Linux kernel driver
-
-Released under the terms of GNU General Public Licence (GPL)
-Copyright(c) Andrea Merello - 2004, Install instructions by Rick Bronson
-
-NOTE: These instructions were written for a Knoppix 3.6 (using Linux
-2.6.7 kernel)
-
-1. Hardware prerequisites
-
-1.1 One of the following devices:
-
-  1.1.1	Realtek card, Man ID = 0x10ec. Device ID =0x8180 (make sure it
-        mount sa2400 radio. Many cards do, many don't)
-  1.1.2 Belkin F5D6001 PCI card, Man ID = 0x1799, Device ID =0x6001
-        (Version 3)
-  1.1.3	Belkin F5D6020 Version 3 (3000) Cardbus card, , Man ID =
-        0x1799, Device ID =0x6020  NOTE: version 1 and 2 will not work
-  1.1.4 DLINK card, Man ID = 0x1799, 0x1186, Device ID =0x3300
-        (A DWL-610 is working here, but I'm not sure all these cards 
-	have rtl8180 & sa2400)
-
-2. Software prerequisites
-
-2.1 Linux 2.6.0 or greater, 2.4 might work but you'll have to do some
-    hacking.
-
-3. Instructions
-
-3.1 Get latest driver from
-    http://sourceforge.net/projects/rtl8180-sa2400 (in this example
-    we'll use rtl8180-0.9.1) and build:
-
-tar xzf rtl8180-0.9.1.tar.gz
-cd rtl8180-0.9.1
-make
-
-(naturally, substitute 0.9.1 with the current version number)
-
-  You can ignore any "no CRC" warnings.
-
-3.2 Module loading (order is important)
-
-for user convenience a ./module_load script is provided.
-Anyway if you want to do manually:
-
-sudo insmod ieee80211-r8180_crypt.ko
-# you may or may not have to do this following step, Knoppix needs it
-sudo insmod /usr/src/linux/lib/crc32.ko
-# you will also need ARC4 support in kernel or by loading module
-
-sudo insmod ieee80211_crypt_wep.ko
-sudo insmod ieee80211-r8180.ko 
-sudo insmod r8180.ko
-
-Once the above is done, you can do some checks to verify if all went
-OK:
-
-  Doing 
-
-cat /proc/modules
-
- Gives:
-
----------------------------------------
-r8180 34312 0 - Live 0xc6c55000
-ieee80211-r8180 25988 1 r8180, Live 0xc6c41000
-ieee80211_crypt_wep 9216 0 - Live 0xc6c34000
-crc32 8064 1 ieee80211_crypt_wep, Live 0xc6c31000
-ieee80211-r8180_crypt 9092 2 ieee80211-r8180,ieee80211_crypt_wep, Live 0xc6c2d000
----------------------------------------
-
-  If you do:
-
-dmesg
-
-  You should see something like:
-
----------------------------
-rtl8180: Card MAC address is XX:XX:XX:XX:XX:XX
-...
-rtl8180: driver probe completed
----------------------------
-
-In this output you should see also other detail like if you have a
-digital or analog PHY. support for the latter is experimental, please
-report..
-
-  If you do:
-
-ifconfig -a
-
-  You should see
-
----------------------------
-wlan0     Link encap:Ethernet  HWaddr XX:XX:XX:XX:XX:XX
-          BROADCAST MULTICAST  MTU:1500  Metric:1
-          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
-          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
-          collisions:0 txqueuelen:1000 
-          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
-          Interrupt:9 Base address:0x4800 
----------------------------
-
-   Doing:
-
-cat /proc/interrupts
-
-  You should see something like:
-
----------------------------
-  9:          0          ..... , wlan0
----------------------------
-Where '9' could be any number
-
-If you have a CARDBUS card, doing "cardctl ident" should say something
-like:
-
----------------------------------------
-Socket 1:
-  product info: "Realtek", "Rtl8180"
-  manfid: 0x0000, 0x024c
-  function: 6 (network)
----------------------------------------
-
-  Doing:
-
-iwconfig
-
-  Shows:
-
----------------------------
-wlan0     IEEE 802.11b  ESSID:""  Nickname:""
-          NWID:off/any  Mode:Managed  Frequency:2.462GHz  
-          Access Point: 00:11:50:0A:07:85  Bit Rate=-1.07375e+06kb/s   Tx-Power:off   
-          Sensitivity=1074102348/0  
-          Retry:off   RTS thr=-1073745104 B   Fragment thr:off
-          Power Management:off
----------------------------
-For now not all parameters are meaningful (like Sensivity).
-
-
-3.3 Setup
-
-sudo ifconfig wlan0 up
-
-  At this point, if you are near an AP or wireless router you should
-start getting interrupts:
-
-cat /proc/interrupts
-
----------------------------
-  9:        500          ...., wlan0
----------------------------
-
-The second number increments. Note that this happens also if you have
-other peripherical on the same interrupt line and you use them.
-
-  Doing:
-
-ifconfig
-
-  Shows (note RX bytes):
-
----------------------------
-wlan0     Link encap:UNSPEC  HWaddr 00-30-BD-4D-8F-9E-00-00-00-00-00-00-00-00-00-00  
-          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
-          RX packets:2170 errors:0 dropped:0 overruns:0 frame:0
-          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
-          collisions:0 txqueuelen:1000 
-          RX bytes:93343 (91.1 KiB)  TX bytes:0 (0.0 b)
-          Interrupt:9 Base address:0x4000 
----------------------------
-
-  If you do:
-
-iwlist scan
-
-  If you are in range of an AP or wireless router, you should see
-  something like:
-
----------------------------
-wlan0     Scan completed :
-          Cell 01 - Address: 00:11:50:0A:07:85
-                    ESSID:"solar"
-                    Mode:Master
-                    Frequency:2.462GHz (channel 11)
-                    Bit Rate:1Mb/s
-                    Bit Rate:2Mb/s
-                    Bit Rate:5.5Mb/s
-                    Bit Rate:11Mb/s
-                    Bit Rate:18Mb/s
-                    Bit Rate:24Mb/s
-                    Bit Rate:36Mb/s
-                    Bit Rate:54Mb/s
-                    Quality=21/100  Signal level=-28 dBm  Noise level=-256 dBm
-                    Encryption key:off
----------------------------
-
-3.4 Test
-
-  Now set your SSID:
-
-sudo iwconfig wlan0 essid solar
-
- Substitute 'solar' (my essid) with your essid.
-
-  Set your address (you may want to use different numbers here):
-
-sudo ifconfig wlan0 broadcast 192.168.0.255 netmask 255.255.255.0 192.168.0.100
-
-  Add a route, if you need it:
-
-sudo route add default gw 192.168.0.1 dev wlan0
-
-  Try pinging another host (like the wireless router itself):
-
-ping 192.168.0.1
-
-  For further usage hint (es. setting WEP key or monitor mode see README file)
-  
-3.3 Installing permanently (so the driver is loaded when you reboot).
-
-  < Not done yet >
-
-3.4 Diagnostics
-
- Some commands you can use to try to figure out what's gone wrong:
-
-lsmod
-dmesg
-ifconfig -a
-iwconfig
-cat /proc/iomem
-cat /proc/interrupts
-cardctl ident
-iwlist scan
-
- In particular dmesg output is very useful/appreciated in report
diff -ruN rtl8187l_orig/rtl8187/Makefile rtl8187l/rtl8187/Makefile
--- rtl8187l_orig/rtl8187/Makefile	2011-01-02 18:14:31.055768000 +0100
+++ rtl8187l/rtl8187/Makefile	2009-06-26 09:07:43.833291000 +0200
@@ -3,6 +3,11 @@
 CC = gcc
 KVER  := $(shell uname -r)
 MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/$(NIC_SELECT)
+KSRC := /lib/modules/$(KVER)/build
+PWD = $(shell pwd)
+INSTALL_PREFIX :=
+
+ifneq ($(shell uname -r|cut -d. -f1,2), 2.4)
 
 #EXTRA_CFLAGS += -DCONFIG_IEEE80211_NOWEP=y
 #EXTRA_CFLAGS += -DCONFIG_RTL8180_IOMAP
@@ -17,7 +22,7 @@
 #EXTRA_CFLAGS += -DLED_SHIN
 EXTRA_CFLAGS += -DRATE_ADAPTIVE
 EXTRA_CFLAGS += -DDIG
-EXTRA_CFLAGS += -DSW_ANTE_DIVERSITY
+#EXTRA_CFLAGS += -DSW_ANTE_DIVERSITY
 
 rtl8187-objs := r8187_core.o r8180_93cx6.o r8180_wx.o r8180_rtl8225.o r8180_rtl8225z2.o r8187_led.o r8180_pm.o r8180_dm.o
 
@@ -25,11 +30,6 @@
 obj-m := rtl8187.o
 
 
-KSRC := /lib/modules/$(KVER)/build
-KVER  := $(shell uname -r)
-KSRC := /lib/modules/$(KVER)/build
-PWD = $(shell pwd)
-INSTALL_PREFIX :=
 
 all: modules
 
@@ -47,3 +47,63 @@
 	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
 	rm -fr .tmp_versions
 	rm -fr Module.symvers
+	rm -fr modules.order
+	rm -fr Module.markers
+	rm -rf tags
+
+
+else #2.4kernel
+
+
+LD := ld
+KSRC := /lib/modules/$(KVER)/build
+CONFIG_FILE := $(KSRC)/include/linux/autoconf.h
+CFLAGS += -DLINUX -D__KERNEL__ -DMODULE -O2 -pipe -Wall
+CFLAGS += -I$(KSRC)/include -I.
+CFLAGS += -DMODVERSIONS -DEXPORT_SYMTAB -include $(KSRC)/include/linux/modversions.h
+CFLAGS += -DPOLLING_METHOD_FOR_RADIO
+CFLAGS += -DCONFIG_BIG_DATA_NOSCAN
+CFLAGS += -DLED
+#CFLAGS += -DLED_SHIN
+CFLAGS += -DRATE_ADAPTIVE
+CFLAGS += -DDIG
+#CFLAGS += -DSW_ANTE_DIVERSITY
+
+SMP := $(shell $(CC) $(CFLAGS) -E -dM $(CONFIG_FILE) | \
+   grep CONFIG_SMP | awk '{print $$3}')
+ifneq ($(SMP),1)
+   SMP := 0
+endif
+ifeq ($(SMP),1)
+   CFLAGS    += -D__SMP__
+endif
+BJS := ${patsubst %.c, %.o, ${wildcard *.c}}
+
+all:rtl8187.o
+rtl8187.o: \
+	r8187_core.o \
+	r8180_93cx6.o \
+	r8180_wx.o \
+	r8180_rtl8225.o \
+	r8180_rtl8225z2.o \
+	r8187_led.o \
+	r8180_dm.o
+	$(LD) -r $^ -o $@
+install:rtl8187.o
+	install -p -m 644 rtl8187.o  $(MODDESTDIR)
+	@depmod -a
+
+uninstall:
+	$(shell [ -d $(MODDESTDIR) ] && rm -fr $(MODDESTDIR))
+	@depmod -a
+
+clean:
+	rm -f *.mod.c *.mod *.o .*.cmd *.ko *~
+	rm -rf $(PWD)/tmp
+	rm -rf *~
+	rm -fr Module.symvers
+	rm -fr modules.order
+	rm -fr Module.markers
+	rm -rf tags
+
+endif
diff -ruN rtl8187l_orig/rtl8187/r8180_93cx6.c rtl8187l/rtl8187/r8180_93cx6.c
--- rtl8187l_orig/rtl8187/r8180_93cx6.c	2011-01-02 18:14:31.047507000 +0100
+++ rtl8187l/rtl8187/r8180_93cx6.c	2009-06-26 09:07:43.837541000 +0200
@@ -30,10 +30,10 @@
 	if(bit)
 		write_nic_byte(dev, EPROM_CMD,
 			       (1<<EPROM_CS_SHIFT) | \
-			       read_nic_byte(dev, EPROM_CMD)); //enable EPROM
+			       read_nic_byte(dev, EPROM_CMD)); 
 	else
 		write_nic_byte(dev, EPROM_CMD, read_nic_byte(dev, EPROM_CMD)\
-			       &~(1<<EPROM_CS_SHIFT)); //disable EPROM
+			       &~(1<<EPROM_CS_SHIFT)); 
 
 	force_pci_posting(dev);
 	udelay(EPROM_DELAY);
@@ -100,7 +100,6 @@
 	u32 ret;
 
 	ret=0;
-        //enable EPROM programming
 	write_nic_byte(dev, EPROM_CMD,
 		       (EPROM_CMD_PROGRAM<<EPROM_CMD_OPERATING_MODE_SHIFT)); 
 	force_pci_posting(dev);
@@ -130,13 +129,9 @@
 	eprom_send_bits_string(dev, read_cmd, 3);
 	eprom_send_bits_string(dev, addr_str, addr_len);
 
-	//keep chip pin D to low state while reading.
-	//I'm unsure if it is necessary, but anyway shouldn't hurt
 	eprom_w(dev, 0); 
 	
 	for(i=0;i<16;i++){	
-		//eeprom needs a clk cycle between writing opcode&adr 
-		//and reading data. (eeprom outs a dummy 0)
 		eprom_ck_cycle(dev);
 		ret |= (eprom_r(dev)<<(15-i));
 	}
@@ -144,7 +139,6 @@
 	eprom_cs(dev, 0);
 	eprom_ck_cycle(dev);
 
-	//disable EPROM programming
 	write_nic_byte(dev, EPROM_CMD,
 		       (EPROM_CMD_NORMAL<<EPROM_CMD_OPERATING_MODE_SHIFT)); 
 	return ret;
diff -ruN rtl8187l_orig/rtl8187/r8180_93cx6.h rtl8187l/rtl8187/r8180_93cx6.h
--- rtl8187l_orig/rtl8187/r8180_93cx6.h	2011-01-02 18:14:31.051505000 +0100
+++ rtl8187l/rtl8187/r8180_93cx6.h	2009-06-26 09:07:43.837541000 +0200
@@ -22,8 +22,6 @@
  * Contact Information:
  * Jerry chuang <wlanfae@realtek.com>
 ******************************************************************************/
-//This files contains card eeprom (93c46 or 93c56) programming routines*/
-//memory is addressed by WORDS*/
 
 #include "r8187.h"
 #include "r8180_hw.h"
@@ -52,4 +50,4 @@
 
 
 
-u32 eprom_read(struct net_device *dev,u32 addr); //reads a 16 bits word
+u32 eprom_read(struct net_device *dev,u32 addr); 
diff -ruN rtl8187l_orig/rtl8187/r8180_dm.c rtl8187l/rtl8187/r8180_dm.c
--- rtl8187l_orig/rtl8187/r8180_dm.c	2011-01-02 18:14:31.043506000 +0100
+++ rtl8187l/rtl8187/r8180_dm.c	2009-06-26 09:07:43.837541000 +0200
@@ -22,9 +22,6 @@
 #include "r8180_hw.h"
 #include "r8180_rtl8225.h"
 
-//================================================================================
-//	Local Constant.
-//================================================================================
 #define Z1_HIPWR_UPPER_TH			99
 #define Z1_HIPWR_LOWER_TH			70	
 #define Z2_HIPWR_UPPER_TH			99
@@ -39,14 +36,10 @@
 		return false;
 
 	if(priv->card_8187 == NIC_8187B) {
-		//
-		// We need to schedule dig workitem on either of the below mechanisms.
-		// By Bruce, 2007-06-01.
-		//
 		if(!priv->bDigMechanism && !priv->bCCKThMechanism)
 			return false;
 
-		if(priv->CurrentOperaRate < 36) // Schedule Dig under all OFDM rates. By Bruce, 2007-06-01.
+		if(priv->CurrentOperaRate < 36) 
 			return false;
 	} else { 
 		if(!priv->bDigMechanism)
@@ -59,23 +52,15 @@
 }
 
 
-//
-//	Description:
-//		Implementation of DIG for Zebra and Zebra2.	
-//
 void DIG_Zebra(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	//PHAL_DATA_8187	pHalData = GetHalData8187(Adapter);
 	u16			CCKFalseAlarm, OFDMFalseAlarm;
 	u16			OfdmFA1, OfdmFA2;
-	int			InitialGainStep = 7; // The number of initial gain stages.
-	int			LowestGainStage = 4; // The capable lowest stage of performing dig workitem.
+	int			InitialGainStep = 7; 
+	int			LowestGainStage = 4; 
 
-//	printk("---------> DIG_Zebra()\n");
 
-	//Read only 1 byte because of HW bug. This is a temporal modification. Joseph
-	// Modify by Isaiah 2006-06-27
 	if(priv->card_8187_Bversion == VERSION_8187B_B)
 	{
 		CCKFalseAlarm = 0;
@@ -88,29 +73,25 @@
 		CCKFalseAlarm = (u16)(priv->FalseAlarmRegValue & 0x0000ffff);
 		OFDMFalseAlarm = (u16)((priv->FalseAlarmRegValue >> 16) & 0x0000ffff);
 		OfdmFA1 =  0x15;
-		//OfdmFA2 =  0xC00;
 		OfdmFA2 = ((u16)(priv->RegDigOfdmFaUpTh)) << 8;
 	}	
 
-//	printk("DIG**********CCK False Alarm: %#X \n",CCKFalseAlarm);
-//	printk("DIG**********OFDM False Alarm: %#X \n",OFDMFalseAlarm);
 
 
 
-	// The number of initial gain steps is different, by Bruce, 2007-04-13.
 	if(priv->card_8187 == NIC_8187) {
-		if (priv->InitialGain == 0 ) //autoDIG
+		if (priv->InitialGain == 0 ) 
 		{
 			switch( priv->rf_chip)
 			{
 				case RF_ZEBRA:
-					priv->InitialGain = 5; // m74dBm;
+					priv->InitialGain = 5; 
 					break;
 				case RF_ZEBRA2:
-					priv->InitialGain = 4; // m78dBm;
+					priv->InitialGain = 4; 
 					break;
 				default:
-					priv->InitialGain = 5; // m74dBm;
+					priv->InitialGain = 5; 
 					break;
 			}
 		}
@@ -121,16 +102,16 @@
 	} 
 	else 
 	{
-		if (priv->InitialGain == 0 ) //autoDIG
-		{ // Advised from SD3 DZ, by Bruce, 2007-06-05.
-			priv->InitialGain = 4; // In 87B, m74dBm means State 4 (m82dBm)
+		if (priv->InitialGain == 0 ) 
+		{ 
+			priv->InitialGain = 4; 
 		}
 		if(priv->card_8187_Bversion != VERSION_8187B_B)
-		{ // Advised from SD3 DZ, by Bruce, 2007-06-05.
+		{ 
 			OfdmFA1 =  0x20;
 		}
 		InitialGainStep = 8;
-		LowestGainStage = priv->RegBModeGainStage; // Lowest gain stage.
+		LowestGainStage = priv->RegBModeGainStage; 
 	}
 
 	if (OFDMFalseAlarm > OfdmFA1)
@@ -140,15 +121,10 @@
 			priv->DIG_NumberFallbackVote++;
 			if (priv->DIG_NumberFallbackVote >1)
 			{
-				//serious OFDM  False Alarm, need fallback
-				// By Bruce, 2007-03-29.
-				// if (pHalData->InitialGain < 7) // In 87B, m66dBm means State 7 (m74dBm)
 				if (priv->InitialGain < InitialGainStep)
 				{
 					priv->InitialGain = (priv->InitialGain + 1);
-					//printk("DIG**********OFDM False Alarm: %#X,  OfdmFA1: %#X, OfdmFA2: %#X\n", OFDMFalseAlarm, OfdmFA1, OfdmFA2);
-					//printk("DIG+++++++ fallback OFDM:%d \n", priv->InitialGain);
-					UpdateInitialGain(dev); // 2005.01.06, by rcnjko.
+					UpdateInitialGain(dev); 
 				}
 				priv->DIG_NumberFallbackVote = 0;
 				priv->DIG_NumberUpgradeVote=0;
@@ -161,7 +137,7 @@
 		}
 		priv->DIG_NumberUpgradeVote=0;		
 	}
-	else	//OFDM False Alarm < 0x15
+	else	
 	{
 		if (priv->DIG_NumberFallbackVote)
 			priv->DIG_NumberFallbackVote--;
@@ -169,26 +145,18 @@
 
 		if (priv->DIG_NumberUpgradeVote>9)
 		{
-			if (priv->InitialGain > LowestGainStage) // In 87B, m78dBm means State 4 (m864dBm)
+			if (priv->InitialGain > LowestGainStage) 
 			{
 				priv->InitialGain = (priv->InitialGain - 1);
-				//printk("DIG**********OFDM False Alarm: %#X,  OfdmFA1: %#X, OfdmFA2: %#X\n", OFDMFalseAlarm, OfdmFA1, OfdmFA2);
-				//printk("DIG--------- Upgrade OFDM:%d \n", priv->InitialGain);
-				UpdateInitialGain(dev); // 2005.01.06, by rcnjko.
+				UpdateInitialGain(dev); 
 			}
 			priv->DIG_NumberFallbackVote = 0;
 			priv->DIG_NumberUpgradeVote=0;
 		}
 	}
 
-//	printk("DIG+++++++ OFDM:%d\n", priv->InitialGain);	
-//	printk("<--------- DIG_Zebra()\n");
 }
 
-//
-//	Description:
-//		Dispatch DIG implementation according to RF. 	
-//
 void DynamicInitGain(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -196,8 +164,7 @@
 	switch(priv->rf_chip)
 	{
 		case RF_ZEBRA:
-		case RF_ZEBRA2:  // [AnnieWorkaround] For Zebra2, 2005-08-01.
-		//case RF_ZEBRA4:
+		case RF_ZEBRA2:  
 			DIG_Zebra(dev);
 			break;
 		
@@ -207,11 +174,6 @@
 	}
 }
 
-// By Bruce, 2007-03-29.
-//
-//	Description:
-//		Dispatch CCK Power Detection implementation according to RF.	
-//
 void DynamicCCKThreshold(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -219,12 +181,10 @@
 	u16			CCK_Lw_Th;
 	u16			CCKFalseAlarm;
 
-//	printk("=====>DynamicCCKThreshold()\n");
 
 	CCK_Up_Th = priv->CCKUpperTh;
 	CCK_Lw_Th = priv->CCKLowerTh;	
-	CCKFalseAlarm = (u16)((priv->FalseAlarmRegValue & 0x0000ffff) >> 8); // We only care about the higher byte.	
-	//printk("DynamicCCKThreshold(): CCK Upper Threshold: 0x%02X, Lower Threshold: 0x%02X, CCKFalseAlarmHighByte: 0x%02X\n", CCK_Up_Th, CCK_Lw_Th, CCKFalseAlarm);
+	CCKFalseAlarm = (u16)((priv->FalseAlarmRegValue & 0x0000ffff) >> 8); 
 
 	if(priv->StageCCKTh < 3 && CCKFalseAlarm >= CCK_Up_Th)
 	{
@@ -237,45 +197,31 @@
 		UpdateCCKThreshold(dev);
 	}
 	
-//	printk("<=====DynamicCCKThreshold()\n");
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8180_hw_dig_wq (struct work_struct *work)
 {
-//      struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
-//      struct ieee80211_device * ieee = (struct ieee80211_device*)
-//                                             container_of(work, struct ieee80211_device, watch_dog_wq);
         struct delayed_work *dwork = container_of(work,struct delayed_work,work);
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_dig_wq);
         struct net_device *dev = ieee->dev;
 #else
 void rtl8180_hw_dig_wq(struct net_device *dev)
 {
-	// struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-	// Read CCK and OFDM False Alarm.
 	if(priv->card_8187_Bversion == VERSION_8187B_B) {
-		// Read only 1 byte because of HW bug. This is a temporal modification. Joseph
-		// Modify by Isaiah 2006-06-27
 		priv->FalseAlarmRegValue = (u32)read_nic_byte(dev, (OFDM_FALSE_ALARM+1));
 	} else {
 		priv->FalseAlarmRegValue = read_nic_dword(dev, CCK_FALSE_ALARM);
 	}
 
-	// Adjust Initial Gain dynamically.
 	if(priv->bDigMechanism) {
 		DynamicInitGain(dev);
 	}
 
-	//
-	// Move from DynamicInitGain to be independent of the OFDM DIG mechanism, by Bruce, 2007-06-01.
-	//
 	if(priv->card_8187 == NIC_8187B) {
-		// By Bruce, 2007-03-29.
-		// Dynamically update CCK Power Detection Threshold.
 		if(priv->bCCKThMechanism)
 		{
 			DynamicCCKThreshold(dev);
@@ -294,28 +240,11 @@
 		break;
 
 	case RF_ZEBRA2:
-	//case RF_ZEBRA4:
 		rtl8225z2_SetTXPowerLevel(dev,chan);
 		break;
 	}
 }
 
-//
-//	Description:
-//		Check if input power signal strength exceeds maximum input power threshold 
-//		of current HW. 
-//		If yes, we set our HW to high input power state:
-//			RX: always force TR switch to SW Tx mode to reduce input power. 
-//			TX: turn off smaller Tx output power (see RtUsbCheckForHang).
-//
-//		If no, we restore our HW to normal input power state:
-///			RX: restore TR switch to HW controled mode.
-//			TX: restore TX output power (see RtUsbCheckForHang).
-//
-//	TODO: 
-//		1. Tx power control shall not be done in Platform-dependent timer (e.g. RtUsbCheckForHang). 
-//		2. Allow these threshold adjustable by RF SD.
-//
 void DoRxHighPower(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -325,26 +254,16 @@
 	u16		RSSIHiPwrUpperTh = 0;
 	u16		RSSIHiPwrLowerTh = 0;	
 
-	//87S remove TrSwitch mechanism
 	if((priv->card_8187 == NIC_8187B)||(priv->card_8187 == NIC_8187)) {
 
-//		printk("----> DoRxHighPower()\n");
 
-		//
-		// Get current TR switch setting.
-		//
-		//Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_TR_SWITCH, (pu1Byte)(&TrSwState));
 		TrSwState = priv->TrSwitchState;
 
-		//
-		// Determine threshold according to RF type.
-		//
 		switch(priv->rf_chip)
 		{
 			case RF_ZEBRA:
 				HiPwrUpperTh = Z1_HIPWR_UPPER_TH;
 				HiPwrLowerTh = Z1_HIPWR_LOWER_TH;
-				//printk("DoRxHighPower(): RF_ZEBRA, Upper Threshold: %d LOWER Threshold: %d\n", HiPwrUpperTh, HiPwrLowerTh);
 				break;	
 
 			case RF_ZEBRA2:
@@ -352,9 +271,6 @@
 					HiPwrUpperTh = Z2_HIPWR_UPPER_TH;
 					HiPwrLowerTh = Z2_HIPWR_LOWER_TH;
 				} else {
-					// By Bruce, 2007-04-11.
-					// HiPwrUpperTh = Z2_HIPWR_UPPER_TH;
-					// HiPwrLowerTh = Z2_HIPWR_LOWER_TH;
 
 					HiPwrUpperTh = priv->Z2HiPwrUpperTh;
 					HiPwrLowerTh = priv->Z2HiPwrLowerTh;
@@ -363,27 +279,19 @@
 
 					RSSIHiPwrUpperTh = priv->Z2RSSIHiPwrUpperTh;
 					RSSIHiPwrLowerTh = priv->Z2RSSIHiPwrLowerTh;
-					//printk("DoRxHighPower(): RF_ZEBRA2, Upper Threshold: %d LOWER Threshold: %d, RSSI Upper Th: %d, RSSI Lower Th: %d\n",HiPwrUpperTh, HiPwrLowerTh, RSSIHiPwrUpperTh, RSSIHiPwrLowerTh);
 				}
 				break;	
 
 			default:
-				//printk("DoRxHighPower(): Unknown RFChipID(%d), UndecoratedSmoothedSS(%d), TrSwState(%d)!!!\n", priv->rf_chip, priv->UndecoratedSmoothedSS, TrSwState);
 				return;
 				break;	
 		}
 
-		//printk(">>>>>>>>>>Set TR switch to software control, UndecoratedSmoothedSS:%d, CurCCKRSSI = %d\n", priv->UndecoratedSmoothedSS, priv->CurCCKRSSI);
 		if((priv->card_8187 == NIC_8187)) {
-			//
-			// Perform Rx part High Power Mechanism by UndecoratedSmoothedSS.
-			//
 			if (priv->UndecoratedSmoothedSS > HiPwrUpperTh)
-			{ //  High input power state.
+			{ 
 				if( priv->TrSwitchState == TR_HW_CONTROLLED )	
 				{
-	//				printk(">>>>>>>>>>Set TR switch to software control, UndecoratedSmoothedSS:%d \n",priv->UndecoratedSmoothedSS);
-					//printk(">>>>>>>>>> TR_SW_TX\n");
 					write_nic_byte(dev, RFPinsSelect, 
 							(u8)(priv->wMacRegRfPinsSelect | TR_SW_MASK_8187 ));
 					write_nic_byte(dev, RFPinsOutput, 
@@ -393,11 +301,9 @@
 				}
 			}
 			else if (priv->UndecoratedSmoothedSS < HiPwrLowerTh)
-			{ // Normal input power state. 
+			{ 
 				if( priv->TrSwitchState == TR_SW_TX)	
 				{
-	//				printk("<<<<<<<<<<<Set TR switch to hardware control UndecoratedSmoothedSS:%d \n",priv->UndecoratedSmoothedSS);
-					//printk("<<<<<<<<<< TR_HW_CONTROLLED\n");
 					write_nic_byte(dev, RFPinsOutput, (u8)(priv->wMacRegRfPinsOutput));
 					write_nic_byte(dev, RFPinsSelect, (u8)(priv->wMacRegRfPinsSelect));
 					priv->TrSwitchState = TR_HW_CONTROLLED;
@@ -405,16 +311,11 @@
 				}
 			}
 		}else {
-			//printk("=====>TrSwState = %s\n", (TrSwState==TR_HW_CONTROLLED)?"TR_HW_CONTROLLED":"TR_SW_TX");
-			//printk("UndecoratedSmoothedSS:%d, CurCCKRSSI = %d\n",priv->UndecoratedSmoothedSS, priv->CurCCKRSSI);
-			// Asked by SD3 DZ, by Bruce, 2007-04-12.
 			if(TrSwState == TR_HW_CONTROLLED)
 			{
 				if((priv->UndecoratedSmoothedSS > HiPwrUpperTh) ||
 						(priv->bCurCCKPkt && (priv->CurCCKRSSI > RSSIHiPwrUpperTh)))
 				{
-	//				printk(">>>>>>>>>>Set TR switch to software control, UndecoratedSmoothedSS:%d, CurCCKRSSI = %d\n", priv->UndecoratedSmoothedSS, priv->CurCCKRSSI);
-					//printk(">>>>>>>>>> TR_SW_TX\n");
 					write_nic_byte(dev, RFPinsSelect, (u8)(priv->wMacRegRfPinsSelect|TR_SW_MASK_8187 ));
 					write_nic_byte(dev, RFPinsOutput, 
 						(u8)((priv->wMacRegRfPinsOutput&(~TR_SW_MASK_8187))|TR_SW_MASK_TX_8187));
@@ -427,84 +328,61 @@
 				if((priv->UndecoratedSmoothedSS < HiPwrLowerTh) &&
 						(!priv->bCurCCKPkt || priv->CurCCKRSSI < RSSIHiPwrLowerTh))
 				{
-	//				printk("<<<<<<<<<<<Set TR switch to hardware control UndecoratedSmoothedSS:%d, CurCCKRSSI = %d \n", priv->UndecoratedSmoothedSS, priv->CurCCKRSSI);
 
-					//printk("<<<<<<<<<< TR_HW_CONTROLLED\n");
 					write_nic_byte(dev, RFPinsOutput, (u8)(priv->wMacRegRfPinsOutput));
 					write_nic_byte(dev, RFPinsSelect, (u8)(priv->wMacRegRfPinsSelect));
 					priv->TrSwitchState = TR_HW_CONTROLLED;
 					priv->bToUpdateTxPwr = true;
 				}
 			}
-//			printk("<=======TrSwState = %s\n", (TrSwState==TR_HW_CONTROLLED)?"TR_HW_CONTROLLED":"TR_SW_TX");
 		}
-//		printk("<---- DoRxHighPower()\n");
 	}
 }
 
 
-//
-//	Description:
-//		Callback function of UpdateTxPowerWorkItem.
-//		Because of some event happend, e.g. CCX TPC, High Power Mechanism, 
-//		We update Tx power of current channel again. 
-//
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8180_tx_pw_wq (struct work_struct *work)
 {
-//      struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
-//      struct ieee80211_device * ieee = (struct ieee80211_device*)
-//                                             container_of(work, struct ieee80211_device, watch_dog_wq);
         struct delayed_work *dwork = container_of(work,struct delayed_work,work);
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,tx_pw_wq);
         struct net_device *dev = ieee->dev;
 #else
 void rtl8180_tx_pw_wq(struct net_device *dev)
 {
-	// struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
 
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-//	printk("----> UpdateTxPowerWorkItemCallback()\n");
 	
 	if(priv->bToUpdateTxPwr)
 	{
-		//printk("DoTxHighPower(): schedule UpdateTxPowerWorkItem......\n");
 		priv->bToUpdateTxPwr = false;
 		SetTxPowerLevel8187(dev, priv->chan);
 	}
 	
 	DoRxHighPower(dev);	
-//	printk("<---- UpdateTxPowerWorkItemCallback()\n");
 }
 
-//
-//	Description:
-//		Return TRUE if we shall perform High Power Mecahnism, FALSE otherwise.	
-//
 bool CheckHighPower(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device *ieee = priv->ieee80211;
-//	printk("===> %s\n", __func__);
 	if(!priv->bRegHighPowerMechanism)
 	{
 		return false;
 	}
 		
-	if((ieee->state == IEEE80211_LINKED_SCANNING))//||(ieee->state == IEEE80211_MESH_SCANNING))
+	if((ieee->state == IEEE80211_LINKED_SCANNING))
 	{
 		return false;
 	}
-//	printk("<=== %s\n", __func__);
 
 	return true;
 }
 
 #ifdef SW_ANTE_DIVERSITY
 
-#define ANTENNA_DIVERSITY_TIMER_PERIOD          1000 // 1000 m
+#define ANTENNA_DIVERSITY_TIMER_PERIOD          1000 
 
 void
 SwAntennaDiversityRxOk8185(
@@ -514,7 +392,6 @@
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 
-	//printk("+SwAntennaDiversityRxOk8185: RxSs: %d\n", SignalStrength);
 
 	priv->AdRxOkCnt++;
 
@@ -523,21 +400,16 @@
 		priv->AdRxSignalStrength = ((priv->AdRxSignalStrength*7) + (SignalStrength*3)) / 10;
 	}
 	else
-	{ // Initialization case.
+	{ 
 		priv->AdRxSignalStrength = SignalStrength;
 	}
         
-        //printk("====>pkt rcvd by %d\n", priv->LastRxPktAntenna);
-	if( priv->LastRxPktAntenna ) //Main antenna.	
+	if( priv->LastRxPktAntenna ) 
 		priv->AdMainAntennaRxOkCnt++;	
-	else	 // Aux antenna.
+	else	 
 		priv->AdAuxAntennaRxOkCnt++;
-	//printk("-SwAntennaDiversityRxOk8185: AdRxOkCnt: %d AdRxSignalStrength: %d\n", priv->AdRxOkCnt, priv->AdRxSignalStrength);
 }
 
-//
-//	Description: Change Antenna Switch.
-//
 bool
 SetAntenna8185(
 	struct net_device *dev,
@@ -547,31 +419,24 @@
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	bool bAntennaSwitched = false;
 
-//	printk("+SetAntenna8185(): Antenna is switching to: %d \n", u1bAntennaIndex);
 
 	switch(u1bAntennaIndex)
 	{
-	case 0://main antenna
+	case 0:
 		switch(priv->rf_chip)
 		{
 		case RF_ZEBRA:
 		case RF_ZEBRA2:
-		//case RF_ZEBRA4:
-			// Rx CCK .
-			//PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x01009b90); // Config CCK RX antenna.
-			//PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x90a6); // Config OFDM RX antenna.
 			write_nic_byte(dev, 0x7f, ((0x01009b90 & 0xff000000) >> 24)); 
 			write_nic_byte(dev, 0x7e, ((0x01009b90 & 0x00ff0000) >> 16)); 
 			write_nic_byte(dev, 0x7d, ((0x01009b90 & 0x0000ff00) >> 8)); 
 			write_nic_byte(dev, 0x7c, ((0x01009b90 & 0x000000ff) >> 0)); 
 
-			// Rx OFDM.
 			write_nic_byte(dev, 0x7f, ((0x000090a6 & 0xff000000) >> 24)); 
 			write_nic_byte(dev, 0x7e, ((0x000090a6 & 0x00ff0000) >> 16)); 
 			write_nic_byte(dev, 0x7d, ((0x000090a6 & 0x0000ff00) >> 8)); 
 			write_nic_byte(dev, 0x7c, ((0x000090a6 & 0x000000ff) >> 0)); 
-			// Tx Antenna.
-			write_nic_byte(dev, ANTSEL, 0x03); // Config TX antenna.
+			write_nic_byte(dev, ANTSEL, 0x03); 
                         bAntennaSwitched = true;
 			break;
 
@@ -586,20 +451,16 @@
 		{
 		case RF_ZEBRA:
 		case RF_ZEBRA2:
-		//case RF_ZEBRA4:
-			// Rx CCK.
 			write_nic_byte(dev, 0x7f, ((0x0100db90 & 0xff000000) >> 24)); 
 			write_nic_byte(dev, 0x7e, ((0x0100db90 & 0x00ff0000) >> 16)); 
 			write_nic_byte(dev, 0x7d, ((0x0100db90 & 0x0000ff00) >> 8)); 
 			write_nic_byte(dev, 0x7c, ((0x0100db90 & 0x000000ff) >> 0)); 
 
-			// Rx OFDM.
 			write_nic_byte(dev, 0x7f, ((0x000010a6 & 0xff000000) >> 24)); 
 			write_nic_byte(dev, 0x7e, ((0x000010a6 & 0x00ff0000) >> 16)); 
 			write_nic_byte(dev, 0x7d, ((0x000010a6 & 0x0000ff00) >> 8)); 
 			write_nic_byte(dev, 0x7c, ((0x000010a6 & 0x000000ff) >> 0)); 
-			// Tx Antenna.
-			write_nic_byte(dev, ANTSEL, 0x00); // Config TX antenna.
+			write_nic_byte(dev, ANTSEL, 0x00); 
 			bAntennaSwitched = true;
 			break;
 
@@ -619,14 +480,10 @@
 		priv->CurrAntennaIndex = u1bAntennaIndex;
 	}
 
-//	printk("-SetAntenna8185(): return (%#X)\n", bAntennaSwitched);
 
 	return bAntennaSwitched;
 }
 
-//
-//	Description: Toggle Antenna switch.
-//
 bool
 SwitchAntenna(
 	struct net_device *dev
@@ -652,160 +509,89 @@
 	return bResult;
 }
 
-//
-//	Description:
-//		Engine of SW Antenna Diversity mechanism.
-//		Since 8187 has no Tx part information, 
-//		this implementation is only dependend on Rx part information. 
-//
-//	2006.04.17, by rcnjko.
-//
 void
 SwAntennaDiversity(
 	struct net_device *dev
 	)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	//bool   bSwCheckSS=false;
-	bool   bSwCheckSS=true;//open the SignalStrength check if not switched by rx ok pkt.
+	bool   bSwCheckSS=true;
 
-//	printk("+SwAntennaDiversity(): CurrAntennaIndex: %d\n", priv->CurrAntennaIndex);
-//	printk("AdTickCount is %d\n",priv->AdTickCount);
-//by amy 080312
 	if(bSwCheckSS)
 	{
 		priv->AdTickCount++;
 	
-		//printk("(1) AdTickCount: %d, AdCheckPeriod: %d\n", priv->AdTickCount, priv->AdCheckPeriod);
-		//printk("(2) AdRxSignalStrength: %ld, AdRxSsThreshold: %ld\n", priv->AdRxSignalStrength, priv->AdRxSsThreshold);
 	}
-//	priv->AdTickCount++;//-by amy 080312
 	
-	// Case 1. No Link.
 	if(priv->ieee80211->state != IEEE80211_LINKED)
 	{
-		//printk("SwAntennaDiversity(): Case 1. No Link.\n");
 
 		priv->bAdSwitchedChecking = false;
-		// I switch antenna here to prevent any one of antenna is broken before link established, 2006.04.18, by rcnjko..
 		SwitchAntenna(dev);
 	}
-	// Case 2. Linked but no packet received.
 	else if(priv->AdRxOkCnt == 0)
 	{
-		//printk("SwAntennaDiversity(): Case 2. Linked but no packet received.\n");
 
 		priv->bAdSwitchedChecking = false;
 		SwitchAntenna(dev);
 	}
-	// Case 3. Evaluate last antenna switch action and undo it if necessary.
 	else if(priv->bAdSwitchedChecking == true)
 	{
-		//printk("SwAntennaDiversity(): Case 3. Evaluate last antenna switch action.\n");
 
 		priv->bAdSwitchedChecking = false;
 
-		// Adjust Rx signal strength threashold.
 		priv->AdRxSsThreshold = (priv->AdRxSignalStrength + priv->AdRxSsBeforeSwitched) / 2;
 
 		priv->AdRxSsThreshold = (priv->AdRxSsThreshold > priv->AdMaxRxSsThreshold) ?	
 					priv->AdMaxRxSsThreshold: priv->AdRxSsThreshold;
 		if(priv->AdRxSignalStrength < priv->AdRxSsBeforeSwitched)
-		{ // Rx signal strength is not improved after we swtiched antenna. => Swich back.
-			//printk("SwAntennaDiversity(): Rx Signal Strength is not improved, CurrRxSs: %ld, LastRxSs: %ld\n", 
-			//	priv->AdRxSignalStrength, priv->AdRxSsBeforeSwitched);
+		{ 
                         
-                        //by amy 080312
-			// Increase Antenna Diversity checking period due to bad decision.
 			priv->AdCheckPeriod *= 2;
-                        //by amy 080312
-                        //
-			// Increase Antenna Diversity checking period.
 			if(priv->AdCheckPeriod > priv->AdMaxCheckPeriod)
 				priv->AdCheckPeriod = priv->AdMaxCheckPeriod;
 	
-			// Wrong deceision => switch back.
 			SwitchAntenna(dev);
 		}
 		else
-		{ // Rx Signal Strength is improved. 
-			//printk("SwAntennaDiversity(): Rx Signal Strength is improved, CurrRxSs: %ld, LastRxSs: %ld\n", 
-			//	priv->AdRxSignalStrength, priv->AdRxSsBeforeSwitched);
+		{ 
 
-			// Reset Antenna Diversity checking period to its min value.
 			priv->AdCheckPeriod = priv->AdMinCheckPeriod;
 		}
 
-		//printk("SwAntennaDiversity(): AdRxSsThreshold: %ld, AdCheckPeriod: %d\n",
-			//priv->AdRxSsThreshold, priv->AdCheckPeriod);
 	}
-	// Case 4. Evaluate if we shall switch antenna now.
-	// Cause Table Speed is very fast in TRC Dell Lab, we check it every time. 
-	else// if(priv->AdTickCount >= priv->AdCheckPeriod)//-by amy 080312
+	else
 	{
-		//printk("SwAntennaDiversity(): Case 4. Evaluate if we shall switch antenna now.\n");
 
 		priv->AdTickCount = 0;
 
-		//
-		// <Roger_Notes> We evaluate RxOk counts for each antenna first and than 
-		// evaluate signal strength. 
-		// The following operation can overcome the disability of CCA on both two antennas
-		// When signal strength was extremely low or high.
-		// 2008.01.30.
-		// 
 		
-		//
-		// Evaluate RxOk count from each antenna if we shall switch default antenna now.
-		// Added by Roger, 2008.02.21.
                 
-                //{by amy 080312
 		if((priv->AdMainAntennaRxOkCnt < priv->AdAuxAntennaRxOkCnt) && (priv->CurrAntennaIndex == 0))
-		{ // We set Main antenna as default but RxOk count was less than Aux ones.
+		{ 
 
-			//printk("SwAntennaDiversity(): Main antenna %d RxOK is poor, AdMainAntennaRxOkCnt: %d, AdAuxAntennaRxOkCnt: %d\n",priv->CurrAntennaIndex, priv->AdMainAntennaRxOkCnt, priv->AdAuxAntennaRxOkCnt);
 			
-			// Switch to Aux antenna.
 			SwitchAntenna(dev);	
 			priv->bHWAdSwitched = true;
 		}
 		else if((priv->AdAuxAntennaRxOkCnt < priv->AdMainAntennaRxOkCnt) && (priv->CurrAntennaIndex == 1))
-		{ // We set Aux antenna as default but RxOk count was less than Main ones.
+		{ 
 
-			//printk("SwAntennaDiversity(): Aux antenna %d RxOK is poor, AdMainAntennaRxOkCnt: %d, AdAuxAntennaRxOkCnt: %d\n",priv->CurrAntennaIndex, priv->AdMainAntennaRxOkCnt, priv->AdAuxAntennaRxOkCnt);
 			
-			// Switch to Main antenna.
 			SwitchAntenna(dev);
 			priv->bHWAdSwitched = true;
 		}
 		else
-		{// Default antenna is better.
+		{
 
-			//printk("SwAntennaDiversity(): Current Antenna %d is better., AdMainAntennaRxOkCnt: %d, AdAuxAntennaRxOkCnt: %d\n",priv->CurrAntennaIndex, priv->AdMainAntennaRxOkCnt, priv->AdAuxAntennaRxOkCnt);
 
-			// Still need to check current signal strength.
 			priv->bHWAdSwitched = false;	
 		}
-		//
-		// <Roger_Notes> We evaluate Rx signal strength ONLY when default antenna 
-		// didn't changed by HW evaluation. 
-		// 2008.02.27.
-		//
-		// [TRC Dell Lab] SignalStrength is inaccuracy. Isaiah 2008-03-05 
-		// For example, Throughput of aux is better than main antenna(about 10M v.s 2M), 
-		// but AdRxSignalStrength is less than main. 
-		// Our guess is that main antenna have lower throughput and get many change 
-		// to receive more CCK packets(ex.Beacon) which have stronger SignalStrength.
-		//
 		if( (!priv->bHWAdSwitched) && (bSwCheckSS))
 		{
-                //by amy 080312}
 
-                // Evaluate Rx signal strength if we shall switch antenna now.
                 if(priv->AdRxSignalStrength < priv->AdRxSsThreshold)
-                { // Rx signal strength is weak => Switch Antenna.
-                    //printk("SwAntennaDiversity(): Rx Signal Strength is weak, CurrRxSs: %ld, RxSsThreshold: %ld\n", 
-                      //      priv->AdRxSignalStrength, priv->AdRxSsThreshold);	
+                { 
 
                     priv->AdRxSsBeforeSwitched = priv->AdRxSignalStrength; 
                     priv->bAdSwitchedChecking = true;
@@ -813,21 +599,17 @@
                     SwitchAntenna(dev);
                 }
                 else
-                { // Rx signal strength is OK. 
-			//printk("SwAntennaDiversity(): Rx Signal Strength is OK, CurrRxSs: %ld, RxSsThreshold: %ld\n", 
-			//	priv->AdRxSignalStrength, priv->AdRxSsThreshold);
+                { 
 
 			priv->bAdSwitchedChecking = false;
-			// Increase Rx signal strength threashold if necessary.
-			if(	(priv->AdRxSignalStrength > (priv->AdRxSsThreshold + 10)) && // Signal is much stronger than current threshold
-				priv->AdRxSsThreshold <= priv->AdMaxRxSsThreshold) // Current threhold is not yet reach upper limit.
+			if(	(priv->AdRxSignalStrength > (priv->AdRxSsThreshold + 10)) && 
+				priv->AdRxSsThreshold <= priv->AdMaxRxSsThreshold) 
 			{
 				priv->AdRxSsThreshold = (priv->AdRxSsThreshold + priv->AdRxSignalStrength) / 2;
 				priv->AdRxSsThreshold = (priv->AdRxSsThreshold > priv->AdMaxRxSsThreshold) ?
-							priv->AdMaxRxSsThreshold: priv->AdRxSsThreshold;//+by amy 080312
+							priv->AdMaxRxSsThreshold: priv->AdRxSsThreshold;
 			}
 
-			// Reduce Antenna Diversity checking period if possible. 
 			if( priv->AdCheckPeriod > priv->AdMinCheckPeriod )
 			{
 				priv->AdCheckPeriod /= 2; 
@@ -835,22 +617,18 @@
 		}
 		}
 	}
-//by amy 080312
-	// Reset antenna diversity Rx related statistics.
 	priv->AdRxOkCnt = 0;
 	priv->AdMainAntennaRxOkCnt = 0;
 	priv->AdAuxAntennaRxOkCnt = 0;
-//by amy 080312
 
-//	priv->AdRxOkCnt = 0;//-by amy 080312
 
-	//printk("-SwAntennaDiversity()\n");
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void SwAntennaWorkItemCallback(struct work_struct *work)
 {
-	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, SwAntennaWorkItem.work);
+	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
+        struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,SwAntennaWorkItem);
 	struct net_device *dev = ieee->dev;
 #else
 void SwAntennaWorkItemCallback(struct net_device *dev)
@@ -859,9 +637,6 @@
 	SwAntennaDiversity(dev);
 }
 
-//
-//	Description: Timer callback function of SW Antenna Diversity.
-//
 void
 SwAntennaDiversityTimerCallback(
 	struct net_device *dev
@@ -870,34 +645,33 @@
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	RT_RF_POWER_STATE rtState;
 	
-	//printk("+SwAntennaDiversityTimerCallback()\n");
 
-	//
-	// We do NOT need to switch antenna while RF is off.
-	// 2007.05.09, added by Roger.
-	//
 	rtState = priv->eRFPowerState;
 	do{
 		if (rtState == eRfOff)
 		{	
-//			printk("SwAntennaDiversityTimer - RF is OFF.\n");
 			break;
 		}  	
 		else if (rtState == eRfSleep)
 		{	
-			// Don't access BB/RF under Disable PLL situation.
-			//RT_TRACE((COMP_RF|COMP_ANTENNA), DBG_LOUD, ("SwAntennaDiversityTimerCallback(): RF is Sleep => skip it\n"));
 			break;
 		}  
 		
-	        queue_work(priv->ieee80211->wq,(void *)&priv->ieee80211->SwAntennaWorkItem);
+#ifdef SW_ANTE_DIVERSITY
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20) 
+		queue_delayed_work(priv->ieee80211->wq,&priv->ieee80211->SwAntennaWorkItem,0);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		queue_work(priv->ieee80211->wq,(void *)&priv->ieee80211->SwAntennaWorkItem);
+#else
+		schedule_task(&priv->ieee80211->SwAntennaWorkItem);
+#endif	
+#endif
 
 	}while(false);
 
 	if(priv->up)
 	{
-		priv->SwAntennaDiversityTimer.expires = jiffies + MSECS(ANTENNA_DIVERSITY_TIMER_PERIOD);
-		add_timer(&priv->SwAntennaDiversityTimer);
+		mod_timer(&priv->SwAntennaDiversityTimer, jiffies + MSECS(ANTENNA_DIVERSITY_TIMER_PERIOD));
 	}
 
 }
diff -ruN rtl8187l_orig/rtl8187/r8180_dm.h rtl8187l/rtl8187/r8180_dm.h
--- rtl8187l_orig/rtl8187/r8180_dm.h	2011-01-02 18:14:31.047507000 +0100
+++ rtl8187l/rtl8187/r8180_dm.h	2009-06-26 09:07:43.837541000 +0200
@@ -40,7 +40,6 @@
 
 
 
-//by lzm for antenna
 #ifdef SW_ANTE_DIVERSITY
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void SwAntennaWorkItemCallback(struct work_struct *work);
@@ -49,7 +48,7 @@
 #endif
 void SwAntennaDiversityRxOk8185(struct net_device *dev, u8 SignalStrength);
 void SwAntennaDiversityTimerCallback(struct net_device *dev);
-#endif //R8180_PM_H
+#endif 
 #endif
 
 #endif
diff -ruN rtl8187l_orig/rtl8187/r8180_hw.h rtl8187l/rtl8187/r8180_hw.h
--- rtl8187l_orig/rtl8187/r8180_hw.h	2011-01-02 18:14:31.055768000 +0100
+++ rtl8187l/rtl8187/r8180_hw.h	2009-06-26 09:07:43.837541000 +0200
@@ -23,13 +23,10 @@
  * Jerry chuang <wlanfae@realtek.com>
 ******************************************************************************/
 
-// Mariusz Matuszek added full registers definition with Realtek's name */
 
-// this file contains register definitions for the rtl8187 MAC controller */
 #ifndef R8180_HW
 #define R8180_HW
 
-//by amy for power save
 #define RF_CHANGE_BY_SW BIT31
 #define RF_CHANGE_BY_HW BIT30
 #define RF_CHANGE_BY_PS BIT29
@@ -39,28 +36,25 @@
 
 #define ANAPARM_ON ANAPARM_ASIC_ON
 #define ANAPARM2_ON ANAPARM2_ASIC_ON
-#define TFPC			0x5C			// Tx FIFO Packet Count for BK, BE, VI, VO queues (2 bytes)
-#define Config4_PowerOff		BIT6			// Turn ON/Off RF Power(RFMD)
+#define TFPC			0x5C			
+#define Config4_PowerOff		BIT6			
 #define ANAPARM_OFF 0x51480658
 #define ANAPARM2_OFF 0x72003f70
-//by amy for power save
 
 typedef	enum _RF_TYPE_8187{
 	RF_TYPE_MIN,
 	RF_ZEBRA = 5,
-	RF_ZEBRA2,		// added by Annie, 2005-08-01.
+	RF_ZEBRA2,		
 	RF_TYPE_MAX,
 }RF_TYPE_8187,*PRF_TYPE_8187;
 
 
 typedef enum _VERSION_8187{
-	// RTL8187
-	VERSION_8187_B, // B-cut
-	VERSION_8187_D, // D-cut
-	// RTL8187B
-	VERSION_8187B_B, // B-cut
-	VERSION_8187B_D,  //D-cut   //added 2007-9-14
-	VERSION_8187B_E,  //E-cut   //added 2007-9-14
+	VERSION_8187_B, 
+	VERSION_8187_D, 
+	VERSION_8187B_B, 
+	VERSION_8187B_D,  
+	VERSION_8187B_E,  
 }VERSION_8187,*PVERSION_8187;
 
 #define GPO				0xFF90
@@ -79,7 +73,6 @@
 
 
 #define MAX_TX_URB 16
-//#define MAX_RX_URB 3
 #define MAX_RX_URB 1
 #define RX_URB_SIZE 0x9c4
 #define TX_URB_SIZE 0x9c4
@@ -153,7 +146,7 @@
 #define INTA_RXCRCERR (1<<1)
 #define INTA_RXOK (1)
 #define INTA_MASK 0x3c
-#define RXRING_ADDR 0xe4 // page 0
+#define RXRING_ADDR 0xe4 
 #define PGSELECT 0x5e
 #define PGSELECT_PG_SHIFT 0
 #define RX_CONF 0x44
@@ -224,7 +217,7 @@
 #define PHY_CONFIG 0x80
 #define PHY_ADR 0x7c
 #define PHY_READ 0x7e
-#define CARRIER_SENSE_COUNTER 0x79 //byte
+#define CARRIER_SENSE_COUNTER 0x79 
 #define SECURITY 0x5f
 #define SECURITY_WEP_TX_ENABLE_SHIFT 1
 #define SECURITY_WEP_RX_ENABLE_SHIFT 0
@@ -238,7 +231,6 @@
 #define CONFIG0_WEP104_SHIFT 6
 #define AGCRESET_SHIFT 5
 
-//by lzm for antenna
 #ifdef SW_ANTE_DIVERSITY
 #define RF_PARAM 0x19
 #define RF_PARAM_DIGPHY_SHIFT 0
@@ -247,22 +239,15 @@
 #define EEPROM_CONFIG2                                  0x18
 #define EEPROM_CS_THRESHOLD                             0x2F
 #define EEPROM_RF_PARAM                         0x08
-//// BIT[8-9] is for SW Antenna Diversity. Only the value EEPROM_SW_AD_ENABLE means enable, other values are diable.
 #define EEPROM_SW_AD_MASK                       0x0300
 #define EEPROM_SW_AD_ENABLE                     0x0100
-//// BIT[10-11] determine if Antenna 1 is the Default Antenna. Only the value EEPROM_DEF_ANT_1 means TRUE, other values are FALSE.
 #define EEPROM_DEF_ANT_MASK                     0x0C00
 #define EEPROM_DEF_ANT_1                        0x0400
 
-#define RCR_EnCS1			BIT29				// enable carrier sense method 1
-#define RCR_EnCS2			BIT30				// enable carrier sense method 2
+#define RCR_EnCS1			BIT29				
+#define RCR_EnCS2			BIT30				
 #endif
-//
 
-// 
-//  Operational registers offsets in PCI (I/O) space. 
-//  RealTek names are used.
-// 
 
 #define IDR0 0x0000
 #define IDR1 0x0001
@@ -271,7 +256,6 @@
 #define IDR4 0x0004
 #define IDR5 0x0005
 
-// 0x0006 - 0x0007 - reserved */
 
 #define MAR0 0x0008
 #define MAR1 0x0009
@@ -282,7 +266,6 @@
 #define MAR6 0x000E
 #define MAR7 0x000F
 
-// 0x0010 - 0x0017 - reserved */
 
 #define TSFTR 0x0018
 #define TSFTR_END 0x001F
@@ -300,11 +283,9 @@
 #define BSSID 0x002E
 #define BSSID_END 0x0033
 
-// 0x0034 - 0x0034 - reserved */
 
 #define CR 0x0037
 
-// 0x0038 - 0x003B - reserved */
 
 #define IMR 0x003C
 #define IMR_END 0x003D
@@ -340,13 +321,11 @@
 
 #define TESTR 0x005B
 
-// 0x005C - 0x005D - reserved */
 
 #define PSR 0x005E
 
 #define SCR 0x005F
 
-// 0x0060 - 0x006F - reserved */
 
 #define BcnItv 0x0070
 #define BcnItv_END 0x0071
@@ -364,7 +343,6 @@
 
 #define CRCount 0x0079
 
-// 0x007A - 0x007B - reserved */
 
 #define PhyAddr 0x007C
 #define PhyDataW 0x007D
@@ -373,7 +351,6 @@
 #define PhyCFG 0x0080
 #define PhyCFG_END 0x0083
 
-// following are for rtl8185 */
 #define RFPinsOutput 0x80
 #define RFPinsEnable 0x82
 #define RF_TIMING 0x8c 
@@ -410,10 +387,6 @@
 #define MAX_RESP_RATE_SHIFT 4
 #define MIN_RESP_RATE_SHIFT 0
 #define RATE_FALLBACK 0xbe
-//
-// 0x0084 - 0x00D3 is selected to page 1 when PSEn bit (bit0, PSR) 
-// is set to 1
-// 
 
 #define Wakeup0 0x0084
 #define Wakeup0_END 0x008B
@@ -447,16 +420,10 @@
 #define CRC4 0x00CC
 #define CRC4_END 0x00CD
 
-// 0x00CE - 0x00D3 - reserved */
 
 
 
-//
-// 0x0084 - 0x00D3 is selected to page 0 when PSEn bit (bit0, PSR) 
-// is set to 0
-// 
 
-// 0x0084 - 0x008F - reserved */
 
 #define DK0 0x0090
 #define DK0_END 0x009F
@@ -467,30 +434,24 @@
 #define DK3 0x00C0
 #define DK3_END 0x00CF
 
-// 0x00D0 - 0x00D3 - reserved */
-//for 87B
 #define CCK_FALSE_ALARM         0x00D0
 #define OFDM_FALSE_ALARM        0x00D2
 
-// 0x00D4 - 0x00D7 - reserved */
 
 #define CONFIG5 0x00D8
 
 #define TPPoll 0x00D9
 
-// 0x00DA - 0x00DB - reserved */
 
 #define CWR 0x00DC
 #define CWR_END 0x00DD
 
 #define RetryCTR 0x00DE
 
-// 0x00DF - 0x00E3 - reserved */
 
 #define RDSAR 0x00E4
 #define RDSAR_END 0x00E7
 
-// 0x00E8 - 0x00EF - reserved */
 
 
 #define FER 0x00F0
@@ -507,12 +468,6 @@
 
 
 
-//
-// Bitmasks for specific register functions. 
-// Names are derived from the register name and function name.
-// // <REGISTER>_<FUNCTION>[<bit>]
-// // this leads to some awkward names...
-// 
 
 #define BRSR_BPLCP  ((1<< 8))
 #define BRSR_MBR    ((1<< 1)|(1<< 0))
@@ -569,7 +524,7 @@
 #define TCR_HWVERID_MASK ((1<<27)|(1<<26)|(1<<25))
 #define TCR_HWVERID_SHIFT 25
 #define TCR_SWPLCPLEN     ((1<<24))
-#define TCR_PLCP_LEN TCR_SAT // rtl8180
+#define TCR_PLCP_LEN TCR_SAT 
 #define TCR_MXDMA_MASK   ((1<<23)|(1<<22)|(1<<21)) 
 #define TCR_MXDMA_1024 6
 #define TCR_MXDMA_2048 7
@@ -582,7 +537,7 @@
 #define TCR_CRC     ((1<<16))
 #define TCR_DPRETRY_MASK   ((1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8))
 #define TCR_RTSRETRY_MASK   ((1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<7))
-#define TCR_PROBE_NOTIMESTAMP_SHIFT 29 //rtl8185
+#define TCR_PROBE_NOTIMESTAMP_SHIFT 29 
 
 #define RCR_ONLYERLPKT ((1<<31))
 #define RCR_CS_SHIFT   29
@@ -723,9 +678,6 @@
 #define FFER_GWAKE   ((1<< 4))
 
 #define Tally_Cnt    0xFFFA
-//----------------------------------------------------------------------------
-////       8187B RF pins related setting                          (offset 0xFF80-0xFF87,)
-////----------------------------------------------------------------------------
 #define TR_SW_MASK_TX_8187 BIT5 
 #define TR_SW_MASK_RX_8187 BIT6
 #define TR_SW_MASK_8187 (TR_SW_MASK_TX_8187 | TR_SW_MASK_RX_8187)
diff -ruN rtl8187l_orig/rtl8187/r8180_pm.c rtl8187l/rtl8187/r8180_pm.c
--- rtl8187l_orig/rtl8187/r8180_pm.c	2011-01-02 18:14:31.047507000 +0100
+++ rtl8187l/rtl8187/r8180_pm.c	2009-06-26 09:07:43.837541000 +0200
@@ -40,7 +40,6 @@
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = usb_get_intfdata(intf);
 #else
-//	struct net_device *dev = (struct net_device *)ptr;
 #endif
 
 	if(dev)
@@ -61,7 +60,6 @@
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = usb_get_intfdata(intf);
 #else
-	//struct net_device *dev = (struct net_device *)ptr;
 #endif
 
 	if(dev)
@@ -85,7 +83,6 @@
 		
 	printk(KERN_NOTICE "r8180 enable wake call (state %u, enable %d).\n", 
 	       state, enable);
-	//return(-EAGAIN);
 	return 0;
 }
 
@@ -94,4 +91,4 @@
 #define rtl8187_suspend NULL
 #define rtl8187_suspend NULL
 
-#endif //CONFIG_PM
+#endif 
diff -ruN rtl8187l_orig/rtl8187/r8180_pm.h rtl8187l/rtl8187/r8180_pm.h
--- rtl8187l_orig/rtl8187/r8180_pm.h	2011-01-02 18:14:31.051505000 +0100
+++ rtl8187l/rtl8187/r8180_pm.h	2009-06-26 09:07:43.837541000 +0200
@@ -36,6 +36,6 @@
 int rtl8187_resume (struct usb_interface *intf);
 int rtl8180_enable_wake (struct pci_dev *dev, u32 state, int enable);
 
-#endif //R8180_PM_H
+#endif 
 
-#endif // CONFIG_PM
+#endif 
diff -ruN rtl8187l_orig/rtl8187/r8180_rtl8225.c rtl8187l/rtl8187/r8180_rtl8225.c
--- rtl8187l_orig/rtl8187/r8180_rtl8225.c	2011-01-02 18:14:31.051505000 +0100
+++ rtl8187l/rtl8187/r8180_rtl8225.c	2009-06-26 09:07:43.837541000 +0200
@@ -35,25 +35,24 @@
 };
 
 u8 rtl8225_gain[]={
-	0x23,0x88,0x7c,0xa5,// -82dbm 
-	0x23,0x88,0x7c,0xb5,// -82dbm 
-	0x23,0x88,0x7c,0xc5,// -82dbm 
-	0x33,0x80,0x79,0xc5,// -78dbm 
-	0x43,0x78,0x76,0xc5,// -74dbm 
-	0x53,0x60,0x73,0xc5,// -70dbm 
-	0x63,0x58,0x70,0xc5,// -66dbm 
+	0x23,0x88,0x7c,0xa5,
+	0x23,0x88,0x7c,0xb5,
+	0x23,0x88,0x7c,0xc5,
+	0x33,0x80,0x79,0xc5,
+	0x43,0x78,0x76,0xc5,
+	0x53,0x60,0x73,0xc5,
+	0x63,0x58,0x70,0xc5,
 };
 
 #if 0
 u8 rtl8225_init_gain[]={
-	//0x00,0x00,0x00,0x00,//0x00,0x00,0x00,0x00,
-	0x33,0x80,0x6c,0xc5,//0x00,0x49,0x06,0xb5,//Gain = 0 ~ -78dbm
-	0x43,0x78,0x69,0xc5,//0x00,0x45,0x06,0xb1,//Gain = 1 ~ -74dbm
-	0x53,0x60,0x66,0xc5,//0x00,0x41,0x06,0xab,//Gain = 2 ~ -70dbm
-	0x63,0x58,0x63,0xc5,//0x00,0x3d,0x06,0xa5,//Gain = 3 ~ -66dbm
-	0x73,0x50,0x62,0xc5,//0x00,0x39,0x06,0xa1,//Gain = 4 ~ -62dbm
-	0x83,0x43,0x61,0xc5,//0x00,0x35,0x06,0x9b,//Gain = 5 ~ -58dbm
-	0x93,0x38,0x5a,0xc5,//0x00,0x31,0x06,0x99,//Gain = 6 ~ -54dbm
+	0x33,0x80,0x6c,0xc5,
+	0x43,0x78,0x69,0xc5,
+	0x53,0x60,0x66,0xc5,
+	0x63,0x58,0x63,0xc5,
+	0x73,0x50,0x62,0xc5,
+	0x83,0x43,0x61,0xc5,
+	0x93,0x38,0x5a,0xc5,
 };
 #endif
 
@@ -155,22 +154,21 @@
 };
 
 u32 rtl8225_chan[] = {
-	0,	//dummy channel 0
-	0x085c, //1	 
-	0x08dc, //2  
-	0x095c, //3  
-	0x09dc, //4  
-	0x0a5c, //5  
-	0x0adc, //6  
-	0x0b5c, //7  
-	0x0bdc, //8  
-	0x0c5c, //9 
-	0x0cdc, //10  
-	0x0d5c, //11  
-	0x0ddc, //12  
-	0x0e5c, //13 
-	//0x0f5c, //14
-	0x0f72, // 14  
+	0,	
+	0x085c, 
+	0x08dc, 
+	0x095c, 
+	0x09dc, 
+	0x0a5c, 
+	0x0adc, 
+	0x0b5c, 
+	0x0bdc, 
+	0x0c5c, 
+	0x0cdc, 
+	0x0d5c, 
+	0x0ddc, 
+	0x0e5c, 
+	0x0f72, 
 };
 
 void rtl8225_set_gain(struct net_device *dev, short gain)
@@ -212,7 +210,6 @@
 	write_phy_ofdm(dev, 0x23, rtl8225_gain[gain * 4 + 1]);
 	write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 4 + 2]);
 	write_phy_ofdm(dev, 0x1d, rtl8225_gain[gain * 4 + 3]);
-	//rtl8225_set_gain_usb(dev, gain);	
 }
 #endif
 
@@ -223,27 +220,23 @@
 
         struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
         struct usb_device *udev = priv->udev;
-        //u8 bit;
         u16                             wReg80, wReg82, wReg84;
 
         wReg80 = read_nic_word(dev, 0x80);
         wReg80 &= 0xfff3;
         wReg82 = read_nic_word(dev, 0x82);
         wReg84 = read_nic_word(dev, 0x84);
-        // <RJ_NOTE> 3-wire should be controled by HW when we finish SW 3-wire programming. 2005.08.10, by rcnjko.
         wReg84 &= 0xfff0;
 
-        // We must set SW enabled before terminating HW 3-wire, 2005.07.29, by rcnjko.
-        write_nic_word(dev, 0x82, (wReg82|0x0007));     // Set To Output Enable
-        write_nic_word(dev, 0x84, (wReg84|0x0007));     // Set To SW Switch
+        write_nic_word(dev, 0x82, (wReg82|0x0007));     
+        write_nic_word(dev, 0x84, (wReg84|0x0007));     
         force_pci_posting(dev);
-        udelay(10); //
+        udelay(10); 
 
-        write_nic_word(dev, 0x80, (BB_HOST_BANG_EN|wReg80)); // Set SI_EN (RFLE)
+        write_nic_word(dev, 0x80, (BB_HOST_BANG_EN|wReg80)); 
         force_pci_posting(dev);
         udelay(2);
-        //twreg.struc.enableB = 0;
-        write_nic_word(dev, 0x80, (wReg80)); // Clear SI_EN (RFLE)
+        write_nic_word(dev, 0x80, (wReg80)); 
         force_pci_posting(dev);
         udelay(10);
 
@@ -256,7 +249,7 @@
         udelay(10);
 
         write_nic_word(dev, 0x80, (wReg80|0x0004));
-        write_nic_word(dev, 0x84, (wReg84|0x0000));// Set To SW Switch
+        write_nic_word(dev, 0x84, (wReg84|0x0000));
 
         if(priv->card_type == USB)
                 mdelay(2);
@@ -283,7 +276,7 @@
 	force_pci_posting(dev);
 	udelay(10);
 	
-	write_nic_word(dev, RFPinsOutput, out | BB_HOST_BANG_EN );//| 0x1fff);
+	write_nic_word(dev, RFPinsOutput, out | BB_HOST_BANG_EN );
 	
 	force_pci_posting(dev);
 	udelay(2);
@@ -377,14 +370,13 @@
 	
 	if(priv->card_type == USB){
 		max_cck_power_level = 11;
-		max_ofdm_power_level = 25; //  12 -> 25
+		max_ofdm_power_level = 25; 
 		min_ofdm_power_level = 10;
 	}else{
 		max_cck_power_level = 35;
 		max_ofdm_power_level = 35;
 		min_ofdm_power_level = 0;
 	}
-	// CCK power setting */
 	if(cck_power_level > max_cck_power_level)
 		cck_power_level = max_cck_power_level;
 	GainIdx=cck_power_level % 6;
@@ -395,13 +387,7 @@
 	else 
 		cck_power_table = rtl8225_tx_power_cck;
 	
-//	if(priv->card_8185 == 1 && priv->card_8185_Bversion ){
-		//Ver B*/
-//		write_nic_byte(dev, TX_GAIN_CCK, rtl8225_tx_gain_cck_ofdm[GainSetting]);
-//	}else{
-		//Ver C - D */
 	write_nic_byte(dev, TX_GAIN_CCK, rtl8225_tx_gain_cck_ofdm[GainSetting]>>1);
-//	}
 	
 	for(i=0;i<8;i++){
 	
@@ -409,42 +395,26 @@
 		write_phy_cck(dev, 0x44 + i, power);
 	}
 	
-	// FIXME Is this delay really needeed ? */
 	force_pci_posting(dev);
 	mdelay(1);
 	
-	// OFDM power setting */
-//  Old:
-//	if(ofdm_power_level > max_ofdm_power_level)
-//		ofdm_power_level = 35;
-//	ofdm_power_level += min_ofdm_power_level;
-//  Latest:
 	if(ofdm_power_level > (max_ofdm_power_level - min_ofdm_power_level))
 		ofdm_power_level = max_ofdm_power_level;
 	else
 		ofdm_power_level += min_ofdm_power_level;
 	if(ofdm_power_level > 35)
 		ofdm_power_level = 35;
-//
 	
 	GainIdx=ofdm_power_level % 6;
 	GainSetting=ofdm_power_level / 6;
 #if 1 	
-//	if(priv->card_type == USB){
 		rtl8185_set_anaparam2(dev,RTL8225_ANAPARAM2_ON);
 	
 		write_phy_ofdm(dev,2,0x42);
 		write_phy_ofdm(dev,6,0);
 		write_phy_ofdm(dev,8,0);	
-//	}
 #endif
-//	if(priv->card_8185 == 1 && priv->card_8185_Bversion){
-//		//Ver B*/
-//		write_nic_byte(dev, TX_GAIN_OFDM, rtl8225_tx_gain_cck_ofdm[GainSetting]);
-//	}else{
-		//Ver C - D */
 	write_nic_byte(dev, TX_GAIN_OFDM, rtl8225_tx_gain_cck_ofdm[GainSetting]>>1);
-//	}
 				
 			
 	power = rtl8225_tx_power_ofdm[GainIdx];
@@ -454,10 +424,8 @@
 	
 	force_pci_posting(dev);
 	mdelay(1);
-	//write_nic_byte(dev, TX_AGC_CONTROL,4);
 }
 #if 0
-// switch between mode B and G */
 void rtl8225_set_mode(struct net_device *dev, short modeb)
 {
 	write_phy_ofdm(dev, 0x15, (modeb ? 0x0 : 0x40));
@@ -479,29 +447,27 @@
 	force_pci_posting(dev);
 	mdelay(10);
 	
-	write_nic_byte(dev,SIFS,0x22);// SIFS: 0x22
+	write_nic_byte(dev,SIFS,0x22);
 	
 	if(gset)
-		write_nic_byte(dev,DIFS,20); //DIFS: 20 
+		write_nic_byte(dev,DIFS,20); 
 	else
-		write_nic_byte(dev,DIFS,0x24); //DIFS: 36 
+		write_nic_byte(dev,DIFS,0x24); 
 	
 	if(priv->ieee80211->state == IEEE80211_LINKED &&
 		ieee80211_is_shortslot(priv->ieee80211->current_network))
-		write_nic_byte(dev,SLOT,0x9); //SLOT: 9
+		write_nic_byte(dev,SLOT,0x9); 
 		
 	else
-		write_nic_byte(dev,SLOT,0x14); //SLOT: 20 (0x14)
+		write_nic_byte(dev,SLOT,0x14); 
 		
 	
 	if(gset){
-		write_nic_byte(dev,EIFS,91 - 20); // EIFS: 91 (0x5B)
-		write_nic_byte(dev,CW_VAL,0x73); //CW VALUE: 0x37
-		//DMESG("using G net params");
+		write_nic_byte(dev,EIFS,91 - 20); 
+		write_nic_byte(dev,CW_VAL,0x73); 
 	}else{
-		write_nic_byte(dev,EIFS,91 - 0x24); // EIFS: 91 (0x5B)
-		write_nic_byte(dev,CW_VAL,0xa5); //CW VALUE: 0x37
-		//DMESG("using B net params");
+		write_nic_byte(dev,EIFS,91 - 0x24); 
+		write_nic_byte(dev,CW_VAL,0xa5); 
 	}
 
 
@@ -509,46 +475,13 @@
 
 void rtl8225_rf_sleep(struct net_device *dev)
 {
-//because of ps mode issue , these code omitted temporarily
-//#ifdef TONY_TRACK
-//	DMESG("enter rtl8225_rf_sleep!\n");
-//#endif
-	//int i;
-	//write_nic_byte(dev,CR9346,read_nic_byte(dev,CR9346)|0xC0);
-	//write_nic_byte(dev,CONFIG3,(read_nic_byte(dev,CONFIG3)|0x40));
-	//for (i=0;i<500;i++) {
-	//	if (read_nic_byte(dev,0xff12)==0)
-	//		break;
-	//	else 
-	//		mdelay(10);
-	//}
-	//printk(KERN_INFO "isleep %d!\n",i);
-	//write_rtl8225(dev,0x4,0xdff);
-	//write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)|0x60);
-	//write_nic_dword(dev,0xff94,0x3d000002);
-	//write_nic_byte(dev,CONFIG3,read_nic_byte(dev,CONFIG3)&(~0x40));
-	//write_nic_byte(dev,CR9346,read_nic_byte(dev,CR9346)&(~0xC0));
-	//printk(KERN_INFO "leave rtl8225_rf_sleep!\n");
 
 } 
 
 void rtl8225_rf_wakeup(struct net_device *dev) 
 {
-//because of ps mode issue , these code omitted temporarily
-//#ifdef TONY_TRACK
-//	DMESG("enter rtl8225_rf_wakeup!\n");
-//#endif	
-
-	//int i;
-	//write_nic_byte(dev,CR9346,read_nic_byte(dev,CR9346)|0xC0);
-	//write_nic_byte(dev,CONFIG3,(read_nic_byte(dev,CONFIG3)|0x40));
-	//write_nic_dword(dev,0xff94,0x3dc00002);
-	//write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)&(~0x60));
-	//write_rtl8225(dev,0x4,0x9ff);
-	//write_nic_byte(dev,CONFIG3,read_nic_byte(dev,CONFIG3)&(~0x40));
-	//write_nic_byte(dev,CR9346,read_nic_byte(dev,CR9346)&(~0xC0));
 
-	//printk(KERN_INFO "leave rtl8225_rf_wakeup!\n");
+
 	
 }
 
@@ -558,17 +491,14 @@
 	
 	rtl8185_rf_pins_enable(dev);
 	
-	//if(priv->card_8185 == 2 && priv->enable_gpio0 ) // version D */
-	//write_nic_word(dev, RFPinsSelect, 0x88);
-	//else
-	write_nic_word(dev, RFPinsSelect, 0x88 | SW_CONTROL_GPIO); // 0x488 | SW_CONTROL_GPIO */
+	write_nic_word(dev, RFPinsSelect, 0x88 | SW_CONTROL_GPIO); 
 	
 	write_nic_byte(dev, GP_ENABLE, 0);
 	
 	force_pci_posting(dev);
 	mdelay(200);
 	
-	write_nic_word(dev, GP_ENABLE, 0xff & (~(1<<6))); // bit 6 is for RF on/off detection */
+	write_nic_word(dev, GP_ENABLE, 0xff & (~(1<<6))); 
 
 	
 }
@@ -588,7 +518,6 @@
 	write_nic_byte(dev,GP_ENABLE,0);
 
 			
-	// Config BB & RF */	
 	write_nic_word(dev, RFPinsOutput, 0x80);
 
 	write_nic_word(dev, RFPinsSelect, 0x80);
@@ -626,22 +555,22 @@
 	write_nic_word(dev, BRSR, 0xffff); 
 
 	#if 0
-	if(priv->card_8185 == 1){// version C or B */
-		if(priv->card_8185_Bversion)  // version B*/
+	if(priv->card_8185 == 1){
+		if(priv->card_8185_Bversion)  
 			write_nic_dword(dev, RF_PARA, 0x44);
-		else    // version C */
+		else    
 			write_nic_dword(dev, RF_PARA, 0x100044);
-	}else{ // version D */
+	}else{ 
 		if(priv->enable_gpio0)	
 			write_nic_dword(dev, RF_PARA, 0x20100044);  
-		else // also USB */
+		else 
 			write_nic_dword(dev, RF_PARA, 0x100044);
 	}
 	#endif
 	
 	write_nic_dword(dev, RF_PARA, 0x100044);
 	
-	#if 1  //0->1
+	#if 1  
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 	write_nic_byte(dev, CONFIG3, 0x44);
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
@@ -672,11 +601,9 @@
 	
 	#if 0
 	}else if(priv->phy_ver == 1){
-		// version A */
 		write_rtl8225(dev, 0x5, 0xbc0 + 2);
 	}else{
 	#endif
-	// version B & C */
 	
 	if(priv->card_type == USB)
 		write_rtl8225(dev, 0x5, 0xbc0);
@@ -686,7 +613,6 @@
 		write_rtl8225(dev, 0x5, 0xbc0 + (6<<3));
 
 	 mdelay(1);
-//	}
 	
 	write_rtl8225(dev, 0x6, 0xae6);  mdelay(1);
 
@@ -710,32 +636,23 @@
 	write_rtl8225(dev, 0xf, 0x914); 
 	
 	if(priv->card_type == USB){
-		//force_pci_posting(dev);
 		mdelay(100);
 	}
 	
 	write_rtl8225(dev, 0x2, 0xc4d);
 	
 	if(priv->card_type == USB){
-	//	force_pci_posting(dev);
 		mdelay(200);
 		
 		write_rtl8225(dev, 0x2, 0x44d);
 		
-	//	force_pci_posting(dev);
 		mdelay(100);
 		
-	}//End of if(priv->card_type == USB)
-	// FIXME!! rtl8187 we have to check if calibrarion
-	// is successful and eventually cal. again (repeat
-	// the two write on reg 2)
-	//
+	}
 	force_pci_posting(dev);
 	
-	mdelay(100); //200 for 8187 
+	mdelay(100); 
 	
-	//if(priv->card_type != USB) // maybe not needed even for 8185 */
-//	write_rtl8225(dev, 0x7, rtl8225_chan[channel]); 
 	
 	write_rtl8225(dev, 0x0, 0x127);
 	
@@ -744,11 +661,9 @@
 		
 		#if 0
 		if(priv->phy_ver == 1) 
-			// version A */
 			write_rtl8225(dev, 0x2, rtl8225a_rxgain[i]);
 		else
 		#endif
-		// version B & C & D*/
 		
 		write_rtl8225(dev, 0x2, rtl8225bcd_rxgain[i]);
 	}
@@ -756,16 +671,6 @@
 	write_rtl8225(dev, 0x0, 0x27);
 
 
-//	//if(priv->card_type != USB){
-//		write_rtl8225(dev, 0x2, 0x44d);
-//		write_rtl8225(dev, 0x7, rtl8225_chan[channel]);
-//		write_rtl8225(dev, 0x2, 0x47d);
-//		
-//		force_pci_posting(dev);
-//		mdelay(100);
-//		
-//		write_rtl8225(dev, 0x2, 0x44d);
-//	//}
 	
 	write_rtl8225(dev, 0x0, 0x22f);   
 	
@@ -800,26 +705,19 @@
 		write_phy_ofdm(dev, 0xa, 0x9);
 	}else{
 		if(priv->card_8185 == 1 && priv->card_8185_Bversion){ 
-			// Ver B
 			* maybe later version can accept this also? 
 			*/
 			write_phy_ofdm(dev, 0xa, 0x6);
 			write_phy_ofdm(dev, 0x18, 0x6f);
 		}else{
 	#endif
-			// ver C & D */
 	write_phy_ofdm(dev, 0xa, 0x9); mdelay(1);
 
-	//write_phy_ofdm(dev, 0x18, 0xef); 
-	//	}
-	//}
 	write_phy_ofdm(dev, 0xb, 0x80); mdelay(1);
 
 	write_phy_ofdm(dev, 0xc, 0x1);mdelay(1);
 
 	
-	//if(priv->card_type != USB)
-	//write_phy_ofdm(dev, 0xd, 0x33); // <>
 		
 	write_phy_ofdm(dev, 0xe, 0xd3);mdelay(1);
 
@@ -827,34 +725,24 @@
 	#if 0
 	if(priv->card_8185 == 1){
 		if(priv->card_8185_Bversion)
-			write_phy_ofdm(dev, 0xf, 0x20);//ver B*/
+			write_phy_ofdm(dev, 0xf, 0x20);
 		else
-			write_phy_ofdm(dev, 0xf, 0x28);//ver C*/
+			write_phy_ofdm(dev, 0xf, 0x28);
 	}else{
 	#endif
 	write_phy_ofdm(dev, 0xf, 0x38);mdelay(1);
-//ver D & 8187*/
-//	}
 	
-//	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-//		write_phy_ofdm(dev, 0x10, 0x04);//ver B*/
-//	else
 	write_phy_ofdm(dev, 0x10, 0x84);mdelay(1);
-//ver C & D & 8187*/
 	
 	write_phy_ofdm(dev, 0x11, 0x06);mdelay(1);
-//agc resp time 700*/
 
 	
-//	if(priv->card_8185 == 2){
-	// Ver D & 8187*/
 	write_phy_ofdm(dev, 0x12, 0x20);mdelay(1);
 
 	write_phy_ofdm(dev, 0x13, 0x20);mdelay(1);
 
 #if 0
 	}else{
-		// Ver B & C*/
 		write_phy_ofdm(dev, 0x12, 0x0);
 		write_phy_ofdm(dev, 0x13, 0x0);
 	}
@@ -864,8 +752,6 @@
 	write_phy_ofdm(dev, 0x16, 0x0); mdelay(1);
 	write_phy_ofdm(dev, 0x17, 0x40); mdelay(1);
 	
-//	if (priv->card_type == USB)
-//		write_phy_ofdm(dev, 0x18, 0xef);
 	
 	write_phy_ofdm(dev, 0x18, 0xef);mdelay(1);
  
@@ -873,36 +759,26 @@
 	write_phy_ofdm(dev, 0x19, 0x19); mdelay(1);
 	write_phy_ofdm(dev, 0x1a, 0x20); mdelay(1);
 	
-//	if (priv->card_type != USB){
-//		if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-//			write_phy_ofdm(dev, 0x1b, 0x66); // Ver B */
-//		else
 	write_phy_ofdm(dev, 0x1b, 0x76);mdelay(1);
- // Ver C & D */ //FIXME:MAYBE not needed
-//	}
 	
 	write_phy_ofdm(dev, 0x1c, 0x4);mdelay(1);
 
 #if 0	
 	if(priv->card_8185 == 1){
 		if(priv->card_8185_Bversion){
-			//ver B*/
 			write_phy_ofdm(dev, 0x1e, 0x95);
 			write_phy_ofdm(dev, 0x1f, 0x55);
 		}else{
-			//ver C*/
 			write_phy_ofdm(dev, 0x1e, 0x90);
 			write_phy_ofdm(dev, 0x1f, 0x34);
 			
 		}
 	}else{
 #endif
-		//ver D & 8187*/
 	write_phy_ofdm(dev, 0x1e, 0x95);mdelay(1);
 
 	write_phy_ofdm(dev, 0x1f, 0x75);	mdelay(1);
 
-//	}
 	
 	write_phy_ofdm(dev, 0x20, 0x1f);mdelay(1);
 
@@ -910,29 +786,19 @@
 	
 	write_phy_ofdm(dev, 0x22, 0x16);mdelay(1);
 
-//	if(priv->card_type != USB)
-	//write_phy_ofdm(dev, 0x23, 0x43); //FIXME maybe not needed // <>
 	
 	write_phy_ofdm(dev, 0x24, 0x46); mdelay(1);
 	write_phy_ofdm(dev, 0x25, 0x20); mdelay(1);
 	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1);
 #if 0
 	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-		write_phy_ofdm(dev, 0x27, 0x08); // Ver B. might work also fo ver C&D ?*/ 
+		write_phy_ofdm(dev, 0x27, 0x08); 
 	else
 #endif
 	write_phy_ofdm(dev, 0x27, 0x88); mdelay(1);
-// Ver C & D & 8187*/
 	
-	// <> Set init. gain to m74dBm.
 	
 	rtl8225_set_gain(dev,4);
-	//write_phy_ofdm(dev, 0x0d, 0x43);	 mdelay(1);
-	//write_phy_ofdm(dev, 0x1b, 0x76);	 mdelay(1);
-	//write_phy_ofdm(dev, 0x1d, 0xc5);	 mdelay(1);
-	//write_phy_ofdm(dev, 0x23, 0x78);	 mdelay(1);
-	//if(priv->card_type == USB);
-	//	rtl8225_set_gain_usb(dev, 1); // FIXME this '2' is random */
 		
 	write_phy_cck(dev, 0x0, 0x98); mdelay(1);
 	write_phy_cck(dev, 0x3, 0x20); mdelay(1);
@@ -941,11 +807,10 @@
 	write_phy_cck(dev, 0x6, 0xfc); mdelay(1);
 #if 0	
 	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-		write_phy_cck(dev, 0x7, 0xd8); // Ver B */
+		write_phy_cck(dev, 0x7, 0xd8); 
 	else
 #endif
 	write_phy_cck(dev, 0x7, 0x78);mdelay(1);
- // Ver C & D & 8187*/
 
 	write_phy_cck(dev, 0x8, 0x2e);mdelay(1);
 
@@ -954,15 +819,15 @@
 	write_phy_cck(dev, 0x12, 0x47); mdelay(1);
 #if 0
 	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-		write_phy_cck(dev, 0x13, 0x98); // Ver B */
+		write_phy_cck(dev, 0x13, 0x98); 
 	else
 #endif
-	write_phy_cck(dev, 0x13, 0xd0); // Ver C & D & 8187*/
+	write_phy_cck(dev, 0x13, 0xd0); 
 		
 	write_phy_cck(dev, 0x19, 0x0);
 	write_phy_cck(dev, 0x1a, 0xa0);
 	write_phy_cck(dev, 0x1b, 0x8);
-	write_phy_cck(dev, 0x40, 0x86); // CCK Carrier Sense Threshold */
+	write_phy_cck(dev, 0x40, 0x86); 
 	
 	write_phy_cck(dev, 0x41, 0x8d);mdelay(1);
 
@@ -984,26 +849,14 @@
 
 	
 
-// <>
-//	// TESTR 0xb 8187
-//	write_phy_cck(dev, 0x10, 0x93);// & 0xfb);
-//	
-//	//if(priv->card_type != USB){
-//		write_phy_ofdm(dev, 0x2, 0x62);
-//		write_phy_ofdm(dev, 0x6, 0x0);
-//		write_phy_ofdm(dev, 0x8, 0x0);
-//	//}
 	
 	rtl8225_SetTXPowerLevel(dev, channel);
 	
-	write_phy_cck(dev, 0x10, 0x9b); mdelay(1); // Rx ant A, 0xdb for B */
-	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1); // Rx ant A, 0x10 for B */
+	write_phy_cck(dev, 0x10, 0x9b); mdelay(1); 
+	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1); 
 	
-	rtl8185_tx_antenna(dev, 0x3); // TX ant A, 0x0 for B */
+	rtl8185_tx_antenna(dev, 0x3); 
 	
-	// switch to high-speed 3-wire 
-	 // last digit. 2 for both cck and ofdm
-	 //
 	if(priv->card_type == USB)
 		write_nic_dword(dev, 0x94, 0x3dc00002);
 	else{
@@ -1011,17 +864,8 @@
 		rtl8185_rf_pins_enable(dev);
 	}
 
-//	if(priv->card_type != USB)
-//	rtl8225_set_gain(dev, 4); // FIXME this '1' is random */ // <>
-//	 rtl8225_set_mode(dev, 1); // FIXME start in B mode */ // <>
-//	
-//	// make sure is waken up! */
-//	write_rtl8225(dev,0x4, 0x9ff);
-//	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON); 
-//	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
 	
 	rtl8225_rf_set_chan(dev, priv->chan);
 
-	//write_nic_word(dev,BRSR,brsr);
 
 }
diff -ruN rtl8187l_orig/rtl8187/r8180_rtl8225.h rtl8187l/rtl8187/r8180_rtl8225.h
--- rtl8187l_orig/rtl8187/r8180_rtl8225.h	2011-01-02 18:14:31.055768000 +0100
+++ rtl8187l/rtl8187/r8180_rtl8225.h	2009-06-26 09:07:43.837541000 +0200
@@ -30,12 +30,8 @@
 
 #define RTL8225_ANAPARAM_ON  0xa0000a59
 
-// FIXME: OFF ANAPARAM MIGHT BE WRONG!
 #define RTL8225_ANAPARAM_OFF 0xa00beb59
 #define RTL8225_ANAPARAM2_OFF 0x840dec11
-//#define CR9346 0xff50
-//#define CONFIG3 0xff59
-//#define CONFIG4 0xff5A
 
 #define RTL8225_ANAPARAM2_ON  0x860c7312
 void rtl8225_rf_init(struct net_device *dev);
diff -ruN rtl8187l_orig/rtl8187/r8180_rtl8225z2.c rtl8187l/rtl8187/r8180_rtl8225z2.c
--- rtl8187l_orig/rtl8187/r8180_rtl8225z2.c	2011-01-02 18:14:31.043506000 +0100
+++ rtl8187l/rtl8187/r8180_rtl8225z2.c	2009-06-26 09:07:43.841770000 +0200
@@ -28,54 +28,50 @@
 #include "r8180_hw.h"
 #include "r8180_rtl8225.h"
 
-//2005.11.16
 u8 rtl8225z2_threshold[]={
         0x8d, 0x8d, 0x8d, 0x8d, 0x9d, 0xad, 0xbd,
 };
 
-//      0xd 0x19 0x1b 0x21
 u8 rtl8225z2_gain_bg[]={
-	0x23, 0x15, 0xa5, // -82-1dbm
-        0x23, 0x15, 0xb5, // -82-2dbm
-        0x23, 0x15, 0xc5, // -82-3dbm
-        0x33, 0x15, 0xc5, // -78dbm
-        0x43, 0x15, 0xc5, // -74dbm
-        0x53, 0x15, 0xc5, // -70dbm
-        0x63, 0x15, 0xc5, // -66dbm
+	0x23, 0x15, 0xa5, 
+        0x23, 0x15, 0xb5, 
+        0x23, 0x15, 0xc5, 
+        0x33, 0x15, 0xc5, 
+        0x43, 0x15, 0xc5, 
+        0x53, 0x15, 0xc5, 
+        0x63, 0x15, 0xc5, 
 };
 
 u8 rtl8225z2_gain_a[]={
-	0x13,0x27,0x5a,//,0x37,// -82dbm 
-	0x23,0x23,0x58,//,0x37,// -82dbm 
-	0x33,0x1f,0x56,//,0x37,// -82dbm 
-	0x43,0x1b,0x54,//,0x37,// -78dbm 
-	0x53,0x17,0x51,//,0x37,// -74dbm 
-	0x63,0x24,0x4f,//,0x37,// -70dbm 
-	0x73,0x0f,0x4c,//,0x37,// -66dbm 
+	0x13,0x27,0x5a,
+	0x23,0x23,0x58,
+	0x33,0x1f,0x56,
+	0x43,0x1b,0x54,
+	0x53,0x17,0x51,
+	0x63,0x24,0x4f,
+	0x73,0x0f,0x4c,
 };
 #if 0
 u32 rtl8225_chan[] = {
-	0,	//dummy channel 0
-	0x085c, //1	 
-	0x08dc, //2  
-	0x095c, //3  
-	0x09dc, //4  
-	0x0a5c, //5  
-	0x0adc, //6  
-	0x0b5c, //7  
-	0x0bdc, //8  
-	0x0c5c, //9 
-	0x0cdc, //10  
-	0x0d5c, //11  
-	0x0ddc, //12  
-	0x0e5c, //13 
-	//0x0f5c, //14
-	0x0f72, // 14  
+	0,	
+	0x085c, 
+	0x08dc, 
+	0x095c, 
+	0x09dc, 
+	0x0a5c, 
+	0x0adc, 
+	0x0b5c, 
+	0x0bdc, 
+	0x0c5c, 
+	0x0cdc, 
+	0x0d5c, 
+	0x0ddc, 
+	0x0e5c, 
+	0x0f72, 
 };
 #endif
 
 #if 0
-//-
 u16 rtl8225z2_rxgain[]={	
 	0x0400, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0408, 0x0409,
 	0x040a, 0x040b, 0x0502, 0x0503, 0x0504, 0x0505, 0x0540, 0x0541,  
@@ -110,7 +106,6 @@
 
 
 
-//2005.11.16,
 u8 ZEBRA2_CCK_OFDM_GAIN_SETTING[]={
         0x00,0x01,0x02,0x03,0x04,0x05,
         0x06,0x07,0x08,0x09,0x0a,0x0b,
@@ -121,7 +116,6 @@
 };
 
 #if 0
-//-
 u8 rtl8225_agc[]={
 	0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x98,0x97,0x96,
 	0x95,0x94,0x93,0x92,0x91,0x90,0x8f,0x8e,0x8d,0x8c,0x8b,0x8a,0x89,0x88,0x87,0x86,
@@ -134,19 +128,16 @@
 };
 #endif
 
-//-
 u8 rtl8225z2_tx_power_ofdm[]={
 	0x42,0x00,0x40,0x00,0x40
 };
 
 
-//-
 u8 rtl8225z2_tx_power_cck_ch14[]={
 	0x36,0x35,0x2e,0x1b,0x00,0x00,0x00,0x00
 };
 
 
-//-
 u8 rtl8225z2_tx_power_cck[]={
 	0x36,0x35,0x2e,0x25,0x1c,0x12,0x09,0x04
 };
@@ -158,26 +149,18 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	
 	u8 mode = priv->ieee80211->mode;
-	//mode = IEEE_G;
 	if((mode&IEEE_B) == IEEE_B || (mode&IEEE_G) == IEEE_G) {
-		//printk(KERN_WARNING "mode ag!\n");
 		rtl8225_gain = rtl8225z2_gain_bg;
 	} else {
 		rtl8225_gain = rtl8225z2_gain_a;
-		//printk(KERN_WARNING "mode a!\n");
 	}
 		
-	//write_phy_ofdm(dev, 0x0d, rtl8225_gain[gain * 3]);
-	//write_phy_ofdm(dev, 0x19, rtl8225_gain[gain * 3 + 1]);
-	//write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 3 + 2]);
-        //2005.11.17, by ch-hsu
         write_phy_ofdm(dev, 0x0d, rtl8225_gain[gain * 3]);
 	mdelay(1);
         write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 3 + 1]);
 	mdelay(1);
         write_phy_ofdm(dev, 0x1d, rtl8225_gain[gain * 3 + 2]);
 	mdelay(1);
-	//write_phy_ofdm(dev, 0x21, 0x37);
 	write_phy_ofdm(dev, 0x21, 0x17);
 	mdelay(1);
 
@@ -213,7 +196,6 @@
 	write_phy_ofdm(dev, 0x23, rtl8225_gain[gain * 4 + 1]);
 	write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 4 + 2]);
 	write_phy_ofdm(dev, 0x1d, rtl8225_gain[gain * 4 + 3]);
-	//rtl8225_set_gain_usb(dev, gain);	
 }
 #endif
 
@@ -223,8 +205,6 @@
 	u32 dataRead;
 	u32 mask;
 	u16 oval,oval2,oval3,tmp;
-//	ThreeWireReg twreg;
-//	ThreeWireReg tdata;
 	int i;
 	short bit, rw;
 	
@@ -278,8 +258,6 @@
 		mask = (low2high) ? (mask<<1) : (mask>>1);
 	}
 
-	//twreg.struc.clk = 0;
-	//twreg.struc.data = 0;
 	write_nic_word(dev, RFPinsOutput, rw|oval); udelay(2);
 	mask = (low2high) ? 0x01 : (((u32)0x01) << (12-1));
 
@@ -302,7 +280,7 @@
 	write_nic_word(dev, RFPinsOutput, BB_HOST_BANG_EN|BB_HOST_BANG_RW|oval); udelay(2);
 
 	write_nic_word(dev, RFPinsEnable, oval2);   
-	write_nic_word(dev, RFPinsSelect, oval3);   // Set To SW Switch
+	write_nic_word(dev, RFPinsSelect, oval3);   
 	write_nic_word(dev, RFPinsOutput, 0x3a0);
 
 	return dataRead;
@@ -329,7 +307,7 @@
 	force_pci_posting(dev);
 	udelay(10);
 	
-	write_nic_word(dev, RFPinsOutput, out | BB_HOST_BANG_EN );//| 0x1fff);
+	write_nic_word(dev, RFPinsOutput, out | BB_HOST_BANG_EN );
 	
 	force_pci_posting(dev);
 	udelay(2);
@@ -381,8 +359,6 @@
 {
 	short vz2 = 1;
 
-	// added by David Woo
-	// set VCO-PDN pin */
 	write_nic_word(dev, RFPinsOutput, 0x0080);
 	write_nic_word(dev, RFPinsSelect, 0x0080);
 	write_nic_word(dev, RFPinsEnable, 0x0080);
@@ -390,18 +366,15 @@
 
 	mdelay(1000);
 	
-	// sw to reg pg 1 */
 	write_rtl8225(dev, 0, 0x1b7);
 	
-	// reg 8 pg 1 = 23*/
 	if( read_rtl8225(dev, 8) != 0x588)
 		vz2 = 0;
 	
-	else	// reg 9 pg 1 = 24 */ 
+	else	
 		if( read_rtl8225(dev, 9) != 0x700)
 			vz2 = 0;
 	
-	// sw back to pg 0 */	
 	write_rtl8225(dev, 0, 0xb7);
 
 	return vz2;
@@ -442,13 +415,10 @@
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	
-//	int GainIdx;
-//	int GainSetting;
 	int i;
 	u8 power;
 	u8 *cck_power_table;
 	u8 max_cck_power_level;
-	//u8 min_cck_power_level;
 	u8 max_ofdm_power_level;
 	u8 min_ofdm_power_level;	
 	u8 cck_power_level = 0xff & priv->chtxpwr[ch];
@@ -456,11 +426,9 @@
 	
 		
 	max_cck_power_level = 15;
-	//min_cck_power_level = 0;
-	max_ofdm_power_level = 25; //  12 -> 25
+	max_ofdm_power_level = 25; 
 	min_ofdm_power_level = 10;
 	
-	// CCK power setting */
 	if(cck_power_level > max_cck_power_level)
 		cck_power_level = max_cck_power_level;
 	
@@ -481,19 +449,11 @@
 		write_phy_cck(dev, 0x44 + i, power);
 	}
 	
-	//write_nic_byte(dev, TX_GAIN_CCK, power);
-	//2005.11.17,
 	write_nic_byte(dev, TX_GAIN_CCK, ZEBRA2_CCK_OFDM_GAIN_SETTING[cck_power_level]);
 	
 	force_pci_posting(dev);
 	mdelay(1);
 	
-	// OFDM power setting */
-//  Old:
-//	if(ofdm_power_level > max_ofdm_power_level)
-//		ofdm_power_level = 35;
-//	ofdm_power_level += min_ofdm_power_level;
-//  Latest:
 	if(ofdm_power_level > (max_ofdm_power_level - min_ofdm_power_level))
 		ofdm_power_level = max_ofdm_power_level;
 	else
@@ -513,17 +473,13 @@
 	write_phy_ofdm(dev,8,0x40);	
 	
 
-	//write_nic_byte(dev, TX_GAIN_OFDM, ofdm_power_level);
-	//2005.11.17,
         write_nic_byte(dev, TX_GAIN_OFDM, ZEBRA2_CCK_OFDM_GAIN_SETTING[ofdm_power_level]);
 
 	
 	force_pci_posting(dev);
 	mdelay(1);
-	//write_nic_byte(dev, TX_AGC_CONTROL,4);
 }
 #if 0
-// switch between mode B and G */
 void rtl8225_set_mode(struct net_device *dev, short modeb)
 {
 	write_phy_ofdm(dev, 0x15, (modeb ? 0x0 : 0x40));
@@ -545,29 +501,27 @@
 	force_pci_posting(dev);
 	mdelay(10);
 	
-	write_nic_byte(dev,SIFS,0x22);// SIFS: 0x22
+	write_nic_byte(dev,SIFS,0x22);
 	
 	if(gset)
-		write_nic_byte(dev,DIFS,20); //DIFS: 20 
+		write_nic_byte(dev,DIFS,20); 
 	else
-		write_nic_byte(dev,DIFS,0x24); //DIFS: 36 
+		write_nic_byte(dev,DIFS,0x24); 
 	
 	if(priv->ieee80211->state == IEEE80211_LINKED &&
 		ieee80211_is_shortslot(priv->ieee80211->current_network))
-		write_nic_byte(dev,SLOT,0x9); //SLOT: 9
+		write_nic_byte(dev,SLOT,0x9); 
 		
 	else
-		write_nic_byte(dev,SLOT,0x14); //SLOT: 20 (0x14)
+		write_nic_byte(dev,SLOT,0x14); 
 		
 	
 	if(gset){
-		write_nic_byte(dev,EIFS,91 - 20); // EIFS: 91 (0x5B)
-		write_nic_byte(dev,CW_VAL,0x73); //CW VALUE: 0x37
-		//DMESG("using G net params");
+		write_nic_byte(dev,EIFS,91 - 20); 
+		write_nic_byte(dev,CW_VAL,0x73); 
 	}else{
-		write_nic_byte(dev,EIFS,91 - 0x24); // EIFS: 91 (0x5B)
-		write_nic_byte(dev,CW_VAL,0xa5); //CW VALUE: 0x37
-		//DMESG("using B net params");
+		write_nic_byte(dev,EIFS,91 - 0x24); 
+		write_nic_byte(dev,CW_VAL,0xa5); 
 	}
 
 
@@ -579,17 +533,14 @@
 	
 	rtl8185_rf_pins_enable(dev);
 	
-	//if(priv->card_8185 == 2 && priv->enable_gpio0 ) // version D */
-	//write_nic_word(dev, RFPinsSelect, 0x88);
-	//else
-	write_nic_word(dev, RFPinsSelect, 0x88 | SW_CONTROL_GPIO); // 0x488 | SW_CONTROL_GPIO */
+	write_nic_word(dev, RFPinsSelect, 0x88 | SW_CONTROL_GPIO); 
 	
 	write_nic_byte(dev, GP_ENABLE, 0);
 	
 	force_pci_posting(dev);
 	mdelay(200);
 	
-	write_nic_word(dev, GP_ENABLE, 0xff & (~(1<<6))); // bit 6 is for RF on/off detection */
+	write_nic_word(dev, GP_ENABLE, 0xff & (~(1<<6))); 
 
 	
 }
@@ -609,7 +560,6 @@
 	write_nic_byte(dev,GP_ENABLE,0);
 
 			
-	// Config BB & RF */	
 	write_nic_word(dev, RFPinsOutput, 0x80);
 
 	write_nic_word(dev, RFPinsSelect, 0x80);
@@ -623,58 +573,41 @@
 
 }
 #endif
-//by amy for DIG
-//
-//	Description:
-//		Update initial gain into PHY.
-//
 void
 UpdateCCKThreshold(
 	struct net_device *dev
 	)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	// Update CCK Power Detection(0x41) value.
 	switch(priv->StageCCKTh)
 	{
 	case 0:
-//		printk("Update CCK Stage 0: 88 \n");
 		write_phy_cck(dev, 0xc1, 0x88);mdelay(1);
 		break;
 		
 	case 1:
-//		printk("Update CCK Stage 1: 98 \n");
 		write_phy_cck(dev, 0xc1, 0x98);mdelay(1);
 		break;
 
 	case 2:
-//		printk("Update CCK Stage 2: C8 \n");
 		write_phy_cck(dev, 0xc1, 0xC8);mdelay(1);
 		break;
 
 	case 3:
-//		printk("Update CCK Stage 3: D8 \n");
 		write_phy_cck(dev, 0xc1, 0xD8);mdelay(1);
 		break;
 
 	default:
-//		printk("Update CCK Stage %d ERROR!\n", pHalData->StageCCKTh);
 		break;
 	}
 }
-//
-//	Description:
-//		Update initial gain into PHY.
-//
 void
 UpdateInitialGain(
 	struct net_device *dev
 	)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//u8	   u1Tmp=0;
 
-	//printk("UpdateInitialGain(): InitialGain: %d RFChipID: %d\n", priv->InitialGain, priv->rf_chip);
 
 	switch(priv->rf_chip)
 	{
@@ -683,68 +616,68 @@
 
 			switch(pHalData->InitialGain)
 			{
-				case 1: //m821dBm
+				case 1: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 1: -82 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);//initial gain = -82dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x7c9b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xa59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x88a3);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x7c9b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xa59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x88a3);	delay_ms(1);
 					break;
 					
-				case 2: //m822dBm
+				case 2: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 2: -82 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);//initial gain = -82dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x7c9b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xb59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x88a3);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x7c9b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xb59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x88a3);	delay_ms(1);
 					break;
 
-				case 3: //m823dBm
+				case 3: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 3: -82 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);//initial gain = -82dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x7c9b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x88a3);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x7c9b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x88a3);	delay_ms(1);
 					break;
 
-				case 4: //m78dBm
+				case 4: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 4: -78 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x338d);	delay_ms(1);//initial gain = -78dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x799b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x80a3);	delay_ms(1);//initial gain = -78dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x338d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x799b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x80a3);	delay_ms(1);
 					break;
 
-				case 5: //m74dBm
+				case 5: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 5: -74 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x438d);	delay_ms(1);//initial gain = -74dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x769b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x78a3);	delay_ms(1);//initial gain = -74dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x438d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x769b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x78a3);	delay_ms(1);
 					break;
 
-				case 6: //m70dBm:
+				case 6: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 6: -70 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x538d);	delay_ms(1);//initial gain = -70dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x739b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x60a3);	delay_ms(1);//initial gain = -70dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x538d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x739b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x60a3);	delay_ms(1);
 					break;
 
-				case 7: //m66dBm:
+				case 7: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 7: -66 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x638d);	delay_ms(1);//initial gain = -70dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x709b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x58a3);	delay_ms(1);//initial gain = -70dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x638d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x709b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x58a3);	delay_ms(1);
 					break;
 
-				default:	// set -74dBm
+				default:	
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 5: -74 dBm (default)\n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x438d);	delay_ms(1);//initial gain = -74dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x769b);	delay_ms(1);//RSSI offset
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x78a3);	delay_ms(1);//initial gain = -74dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x438d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x769b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x78a3);	delay_ms(1);
 					break;
 				
 			}
@@ -754,71 +687,71 @@
 			break;
 
 
-		case  RF_ZEBRA2:  // Added by Annie for Zebra2, 2005-08-01.
+		case  RF_ZEBRA2:  
 			switch(pHalData->InitialGain)
 			{
-				case 1: //m821dBm
+				case 1: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 1: -82 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);//initial gain = -82dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xa59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//Annie, 2005-04-21
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xa59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				case 2: //m822dBm
+				case 2: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 2: -82 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);//initial gain = -82dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xb59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xb59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				case 3: //m823dBm
+				case 3: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 3: -82 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);//initial gain = -82dBm					
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x238d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				case 4: //m78dBm
+				case 4: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 4: -78 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x338d);	delay_ms(1);//initial gain = -78dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x338d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				case 5: //m74dBm
+				case 5: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 5: -74 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x438d);	delay_ms(1);//initial gain = -74dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x438d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				case 6: //m70dBm:
+				case 6: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 6: -70 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x538d);	delay_ms(1);//initial gain = -70dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x538d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				case 7: //m66dBm:
+				case 7: 
 					RT_TRACE(COMP_DIG, DBG_LOUD, ("RTL8187 + 8225 Initial Gain State 7: -66 dBm \n"));
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x638d);	delay_ms(1);//initial gain = -70dBm
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x638d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, BBAddr, 0x17a1);	delay_ms(1);
 					break;
 
-				default:	// set -78dBm. Annie, 2005-12-19.
+				default:	
 					RT_TRACE(COMP_DBG, DBG_LOUD, ("RTL8187 + Zebra2 Initial Gain State 4: -78 dBm (default)\n"));
-					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0x338d);	delay_ms(1);//initial gain = -78dBm
-					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0x159b);	delay_ms(1);//Annie, 2005-04-21
-					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0xc59d);	delay_ms(1);//ofdm CS threshold
-					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0x17a1);	delay_ms(1);//initial gain = -82dBm
+					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0x338d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0x159b);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0xc59d);	delay_ms(1);
+					PlatformEFIOWrite4Byte(Adapter, 0xFF7C, 0x17a1);	delay_ms(1);
 					break;	
 			}
 			break;
@@ -826,80 +759,58 @@
 		case RF_ZEBRA:
 		case RF_ZEBRA2:
 
-			//
-			// Note: 
-			// 	Whenever we update this gain table, we should be careful about those who call it.
-			// 	Functions which call UpdateInitialGain as follows are important:
-			// 	(1)StaRateAdaptive87B
-			//	(2)DIG_Zebra
-			//	(3)ActSetWirelessMode8187 (when the wireless mode is "B" mode, we set the 
-			//		OFDM[0x17] = 0x26 to improve the Rx sensitivity).
-			//	By Bruce, 2007-06-01.
-			//
-
-			//
-			// SD3 C.M. Lin Initial Gain Table, by Bruce, 2007-06-01.
-			//
+
 			switch(priv->InitialGain)
 			{
-				case 1: //m861dBm
-					//printk("RTL8187 + 8225 Initial Gain State 1: -82 dBm \n");
+				case 1: 
 					write_phy_ofdm(dev, 0x97, 0x26);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0x86);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfa);	mdelay(1);
 					break;
 					
-				case 2: //m862dBm
-					//printk("RTL8187 + 8225 Initial Gain State 2: -78 dBm \n");
-					write_phy_ofdm(dev, 0x97, 0x36);	mdelay(1);// Revise 0x26 to 0x36, by Roger, 2007.05.03.
+				case 2: 
+					write_phy_ofdm(dev, 0x97, 0x36);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0x86);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfa);	mdelay(1);
 					break;
 
-				case 3: //m863dBm
-					//printk("RTL8187 + 8225 Initial Gain State 3: -78 dBm \n");
-					write_phy_ofdm(dev, 0x97, 0x36);	mdelay(1);// Revise 0x26 to 0x36, by Roger, 2007.05.03.
+				case 3: 
+					write_phy_ofdm(dev, 0x97, 0x36);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0x86);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfb);	mdelay(1);
 					break;
 
-				case 4: //m864dBm
-					//printk("RTL8187 + 8225 Initial Gain State 4: -74 dBm \n");
-					write_phy_ofdm(dev, 0x97, 0x46);	mdelay(1);// Revise 0x26 to 0x36, by Roger, 2007.05.03.
+				case 4: 
+					write_phy_ofdm(dev, 0x97, 0x46);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0x86);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfb);	mdelay(1);
 					break;
 
-				case 5: //m82dBm
-					//printk("RTL8187 + 8225 Initial Gain State 5: -74 dBm \n");
+				case 5: 
 					write_phy_ofdm(dev, 0x97, 0x46);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0x96);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfb);	mdelay(1);
 					break;
 
-				case 6: //m78dBm
-					//printk("RTL8187 + 8225 Initial Gain State 6: -70 dBm \n");
+				case 6: 
 					write_phy_ofdm(dev, 0x97, 0x56);	mdelay(1);					
 					write_phy_ofdm(dev, 0xa4, 0x96);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfc);	mdelay(1);
 					break;
 
-				case 7: //m74dBm
-					//printk("RTL8187 + 8225 Initial Gain State 7: -70 dBm \n");
+				case 7: 
 					write_phy_ofdm(dev, 0x97, 0x56);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0xa6);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfc);	mdelay(1);
 					break;
 
-				// By Bruce, 2007-03-29.
 				case 8:
 					write_phy_ofdm(dev, 0x97, 0x66);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0xb6);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfc);	mdelay(1);
 					break;
 
-				default:	//MP
-					//printk("RTL8187 + 8225 Initial Gain State: -82 dBm (default), InitialGain(%d)\n", priv->InitialGain);
+				default:	
 					write_phy_ofdm(dev, 0x97, 0x26);	mdelay(1);
 					write_phy_ofdm(dev, 0xa4, 0x86);	mdelay(1);
 					write_phy_ofdm(dev, 0x85, 0xfa);	mdelay(1);
@@ -911,7 +822,6 @@
 			break;
 	}
 }
-//by amy for DIG
 #if 0
 void PhyConfig8187(struct net_device *dev)
 {
@@ -933,12 +843,9 @@
 	{
 		if(priv->InitialGain == 0)
 			priv->InitialGain = 4;
-		//printk("PhyConfig8187(): DIG is enabled, set default initial gain index to %d\n", priv->InitialGain);
 	}
 
-	// By Bruce, 2007-03-29.
 	UpdateCCKThreshold(dev);
-	// Update initial gain after PhyConfig comleted, asked for by SD3 CMLin.
 	UpdateInitialGain(dev);
 	return ;
 }
@@ -969,7 +876,7 @@
 
 	write_nic_dword(dev, RF_PARA, 0x100044);
 	
-	#if 1  //0->1
+	#if 1  
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 	write_nic_byte(dev, CONFIG3, 0x44);
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
@@ -978,7 +885,6 @@
 	
 	rtl8185_rf_pins_enable(dev);
 
-//		mdelay(1000);
 
 	write_rtl8225(dev, 0x0, 0x2bf); mdelay(1);
 	
@@ -995,7 +901,6 @@
 	
 	
 	write_rtl8225(dev, 0x5, 0xc72);mdelay(1);
-//	}
 	
 	write_rtl8225(dev, 0x6, 0xe6);  mdelay(1);
 
@@ -1022,8 +927,6 @@
 	mdelay(100);
 	
 	
-	//if(priv->card_type != USB) // maybe not needed even for 8185 */
-//	write_rtl8225(dev, 0x7, rtl8225_chan[channel]); 
 	
 	write_rtl8225(dev, 0x0, 0x1b7);
 	
@@ -1032,15 +935,12 @@
 		
 		#if 0
 		if(priv->phy_ver == 1) 
-			// version A */
 			write_rtl8225(dev, 0x2, rtl8225a_rxgain[i]);
 		else
 		#endif
-		// version B & C & D*/
 		
 		write_rtl8225(dev, 0x2, rtl8225z2_rxgain[i]);
 	}
-	//write_rtl8225(dev, 0x3, 0x80);
 	write_rtl8225(dev, 0x3, 0x2);
 	write_rtl8225(dev, 0x5, 0x4);
 
@@ -1049,20 +949,13 @@
 	write_rtl8225(dev, 0x2, 0xc4d);
 	
 	if(priv->card_type == USB){
-	//	force_pci_posting(dev);
 		mdelay(200);
 		
 		write_rtl8225(dev, 0x2, 0x44d);
 		
-	//	force_pci_posting(dev);
 		mdelay(200);
 		
-	}//End of if(priv->card_type == USB)
-	// FIXME!! rtl8187 we have to check if calibrarion
-	// is successful and eventually cal. again (repeat
-	// the two write on reg 2)
-	//
-	// Check for calibration status, 2005.11.17,
+	}
         data = read_rtl8225(dev, 6);
         if (!(data&0x00000080))
         {
@@ -1076,31 +969,19 @@
                                 DMESGW("RF Calibration Failed!!!!\n");
                         }
         }
-	//force_pci_posting(dev);
 	
-	mdelay(200); //200 for 8187 
+	mdelay(200); 
 	
 	
-//	//if(priv->card_type != USB){
-//		write_rtl8225(dev, 0x2, 0x44d);
-//		write_rtl8225(dev, 0x7, rtl8225_chan[channel]);
-//		write_rtl8225(dev, 0x2, 0x47d);
-//		
-//		force_pci_posting(dev);
-//		mdelay(100);
-//		
-//		write_rtl8225(dev, 0x2, 0x44d);
-//	//}
 	
 	write_rtl8225(dev, 0x0, 0x2bf);   
 	
 	if(priv->card_type != USB)
 		rtl8185_rf_pins_enable(dev);
-	//set up ZEBRA AGC table, 2005.11.17,
         for(i=0;i<128;i++){
                 data = rtl8225_agc[i];
 
-                addr = i + 0x80; //enable writing AGC table
+                addr = i + 0x80; 
                 write_phy_ofdm(dev, 0xb, data);
 
                 mdelay(1);
@@ -1135,15 +1016,11 @@
 
 	write_phy_ofdm(dev, 0xa, 0x8); mdelay(1);
 
-	//write_phy_ofdm(dev, 0x18, 0xef); 
-	//	}
-	//}
 	write_phy_ofdm(dev, 0xb, 0x80); mdelay(1);
 
 	write_phy_ofdm(dev, 0xc, 0x1);mdelay(1);
 
 	
-	//if(priv->card_type != USB)
 	write_phy_ofdm(dev, 0xd, 0x43); 
 		
 	write_phy_ofdm(dev, 0xe, 0xd3);mdelay(1);
@@ -1152,34 +1029,24 @@
 	#if 0
 	if(priv->card_8185 == 1){
 		if(priv->card_8185_Bversion)
-			write_phy_ofdm(dev, 0xf, 0x20);//ver B*/
+			write_phy_ofdm(dev, 0xf, 0x20);
 		else
-			write_phy_ofdm(dev, 0xf, 0x28);//ver C*/
+			write_phy_ofdm(dev, 0xf, 0x28);
 	}else{
 	#endif
 	write_phy_ofdm(dev, 0xf, 0x38);mdelay(1);
-//ver D & 8187*/
-//	}
 	
-//	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-//		write_phy_ofdm(dev, 0x10, 0x04);//ver B*/
-//	else
 	write_phy_ofdm(dev, 0x10, 0x84);mdelay(1);
-//ver C & D & 8187*/
 	
 	write_phy_ofdm(dev, 0x11, 0x07);mdelay(1);
-//agc resp time 700*/
 
 	
-//	if(priv->card_8185 == 2){
-	// Ver D & 8187*/
 	write_phy_ofdm(dev, 0x12, 0x20);mdelay(1);
 
 	write_phy_ofdm(dev, 0x13, 0x20);mdelay(1);
 
 #if 0
 	}else{
-		// Ver B & C*/
 		write_phy_ofdm(dev, 0x12, 0x0);
 		write_phy_ofdm(dev, 0x13, 0x0);
 	}
@@ -1189,8 +1056,6 @@
 	write_phy_ofdm(dev, 0x16, 0x0); mdelay(1);
 	write_phy_ofdm(dev, 0x17, 0x40); mdelay(1);
 	
-//	if (priv->card_type == USB)
-//		write_phy_ofdm(dev, 0x18, 0xef);
 	
 	write_phy_ofdm(dev, 0x18, 0xef);mdelay(1);
  
@@ -1201,13 +1066,12 @@
 	
 	write_phy_ofdm(dev, 0x1c, 0x4);mdelay(1);
 
-	write_phy_ofdm(dev, 0x1d, 0xc5);mdelay(1); //2005.11.17,
+	write_phy_ofdm(dev, 0x1d, 0xc5);mdelay(1); 
 	
 	write_phy_ofdm(dev, 0x1e, 0x95);mdelay(1);
 
 	write_phy_ofdm(dev, 0x1f, 0x75);	mdelay(1);
 
-//	}
 	
 	write_phy_ofdm(dev, 0x20, 0x1f);mdelay(1);
 
@@ -1215,8 +1079,7 @@
 	
 	write_phy_ofdm(dev, 0x22, 0x16);mdelay(1);
 
-//	if(priv->card_type != USB)
-	write_phy_ofdm(dev, 0x23, 0x80);mdelay(1); //FIXME maybe not needed // <>
+	write_phy_ofdm(dev, 0x23, 0x80);mdelay(1); 
 	
 	write_phy_ofdm(dev, 0x24, 0x46); mdelay(1);
 	write_phy_ofdm(dev, 0x25, 0x00); mdelay(1);
@@ -1225,10 +1088,8 @@
 	write_phy_ofdm(dev, 0x27, 0x88); mdelay(1);
 
 	
-	// <> Set init. gain to m74dBm.
 	
 	rtl8225z2_set_gain(dev,4);
-	//rtl8225z2_set_gain(dev,2);
 	
 	write_phy_cck(dev, 0x0, 0x98); mdelay(1);
 	write_phy_cck(dev, 0x3, 0x20); mdelay(1);
@@ -1236,7 +1097,6 @@
 	write_phy_cck(dev, 0x5, 0x12); mdelay(1);
 	write_phy_cck(dev, 0x6, 0xfc); mdelay(1);
 	write_phy_cck(dev, 0x7, 0x78);mdelay(1);
- // Ver C & D & 8187*/
 	write_phy_cck(dev, 0x8, 0x2e);mdelay(1);
 
 	write_phy_cck(dev, 0x9, 0x11);mdelay(1);
@@ -1248,17 +1108,17 @@
 	write_phy_cck(dev, 0x12, 0x47); mdelay(1);
 #if 0
 	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
-		write_phy_cck(dev, 0x13, 0x98); // Ver B */
+		write_phy_cck(dev, 0x13, 0x98); 
 	else
 #endif
-	write_phy_cck(dev, 0x13, 0xd0); // Ver C & D & 8187*/
+	write_phy_cck(dev, 0x13, 0xd0); 
 		
 	write_phy_cck(dev, 0x19, 0x0); mdelay(1);
 	write_phy_cck(dev, 0x1a, 0xa0); mdelay(1);
 	write_phy_cck(dev, 0x1b, 0x8); mdelay(1);
 	write_phy_cck(dev, 0x1d, 0x0); mdelay(1);
 	
-	write_phy_cck(dev, 0x40, 0x86); // CCK Carrier Sense Threshold */ mdelay(1);
+	write_phy_cck(dev, 0x40, 0x86); 
 	
 	write_phy_cck(dev, 0x41, 0x9d);mdelay(1);
 
@@ -1282,26 +1142,14 @@
 
 	
 
-// <>
-//	// TESTR 0xb 8187
-//	write_phy_cck(dev, 0x10, 0x93);// & 0xfb);
-//	
-//	//if(priv->card_type != USB){
-//		write_phy_ofdm(dev, 0x2, 0x62);
-//		write_phy_ofdm(dev, 0x6, 0x0);
-//		write_phy_ofdm(dev, 0x8, 0x0);
-//	//}
 	
 	rtl8225z2_SetTXPowerLevel(dev, channel);
 	
-	write_phy_cck(dev, 0x10, 0x9b); mdelay(1); // Rx ant A, 0xdb for B */
-	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1);// Rx ant A, 0x10 for B */
+	write_phy_cck(dev, 0x10, 0x9b); mdelay(1); 
+	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1);
 	
-	rtl8185_tx_antenna(dev, 0x3); // TX ant A, 0x0 for B */
+	rtl8185_tx_antenna(dev, 0x3); 
 	
-	// switch to high-speed 3-wire 
-	// last digit. 2 for both cck and ofdm
-	//
 	if(priv->card_type == USB)
 		write_nic_dword(dev, 0x94, 0x3dc00002);
 	else{
@@ -1309,20 +1157,10 @@
 		rtl8185_rf_pins_enable(dev);
 	}
 
-//	if(priv->card_type != USB)
-//	rtl8225_set_gain(dev, 4); // FIXME this '1' is random */ // <>
-//	 rtl8225_set_mode(dev, 1); // FIXME start in B mode */ // <>
-//	
-//	// make sure is waken up! */
-//	write_rtl8225(dev,0x4, 0x9ff);
-//	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON); 
-//	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
 	
 	rtl8225_rf_set_chan(dev, priv->chan);
 
-	//write_nic_word(dev,BRSR,brsr);
 	
-	//rtl8225z2_rf_set_mode(dev);
 }
 
 void rtl8225z2_rf_set_mode(struct net_device *dev) 
diff -ruN rtl8187l_orig/rtl8187/r8180_wx.c rtl8187l/rtl8187/r8180_wx.c
--- rtl8187l_orig/rtl8187/r8180_wx.c	2011-01-02 18:14:31.039499000 +0100
+++ rtl8187l/rtl8187/r8180_wx.c	2009-06-26 09:07:43.841770000 +0200
@@ -30,22 +30,21 @@
 #include "../ieee80211/ieee80211.h"
 
 
-//#define RATE_COUNT 4
 u32 rtl8180_rates[] = {1000000,2000000,5500000,11000000,
 	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
 #define RATE_COUNT (sizeof(rtl8180_rates)/sizeof(rtl8180_rates[0]))
 
 static CHANNEL_LIST DefaultChannelPlan[] = {
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},			//Default channel plan
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64},19},  		//FCC
-	{{1,2,3,4,5,6,7,8,9,10,11},11},                    				//IC
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},  	//ETSI
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},    //Spain. Change to ETSI. 
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},  	//France. Change to ETSI.
-	{{14,36,40,44,48,52,56,60,64},9},						//MKK
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14, 36,40,44,48,52,56,60,64},22},//MKK1
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},	//Israel.
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,34,38,42,46},17}			// For 11a , TELEC
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},			
+	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64},19},  		
+	{{1,2,3,4,5,6,7,8,9,10,11},11},                    				
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},  	
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},    
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},  	
+	{{14,36,40,44,48,52,56,60,64},9},						
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14, 36,40,44,48,52,56,60,64},22},
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},	
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,34,38,42,46},17}			
 };	
 #if 0
 static int r8180_wx_get_freq(struct net_device *dev,
@@ -193,7 +192,7 @@
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	wrqu->rts.value = priv->rts;
-	wrqu->rts.fixed = 0;	// no auto select */
+	wrqu->rts.fixed = 0;	
 	wrqu->rts.disabled = (wrqu->rts.value == 0);
 
 	return 0;
@@ -258,30 +257,18 @@
 	return ret;
 }
 
-//YJ,add,080819,for hidden ap
 struct  iw_range_with_scan_capa
 {
-        // Informative stuff (to choose between different interface) */
-        __u32           throughput;     // To give an idea... */
-        // In theory this value should be the maximum benchmarked
-        // TCP/IP throughput, because with most of these devices the
-        // bit rate is meaningless (overhead an co) to estimate how
-        // fast the connection will go and pick the fastest one.
-        // I suggest people to play with Netperf or any benchmark...
-        // 
-
-        // NWID (or domain id) */
-        __u32           min_nwid;       // Minimal NWID we are able to set */
-        __u32           max_nwid;       // Maximal NWID we are able to set */
+        __u32           throughput;     
+
+        __u32           min_nwid;       
+        __u32           max_nwid;       
 
-        // Old Frequency (backward compat - moved lower ) */
         __u16           old_num_channels;
         __u8            old_num_frequency;
 
-        // Scan capabilities */
         __u8            scan_capa;       
 };
-//YJ,add,080819,for hidden ap
 
 static int rtl8180_wx_get_range(struct net_device *dev, 
 				struct iw_request_info *info, 
@@ -291,45 +278,27 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	u16 val;
 	int i;
-	//struct iw_range_with_scan_capa* tmp = (struct iw_range_with_scan_capa*)range; //YJ,add,080819,for hidden ap
 
 	wrqu->data.length = sizeof(*range);
 	memset(range, 0, sizeof(*range));
 
-	// Let's try to keep this struct in the same order as in
-	// linux/include/wireless.h
-	// 
-	
-	// TODO: See what values we can set, and remove the ones we can't
-	// set, or fill them with some default data.
-	// 
+	
 
-	// ~5 Mb/s real (802.11b) */
 	range->throughput = 5 * 1000 * 1000;     
 
-	// TODO: Not used in 802.11b?
-//	range->min_nwid;	// Minimal NWID we are able to set */
-	// TODO: Not used in 802.11b?
-//	range->max_nwid;	// Maximal NWID we are able to set */
-	
-        // Old Frequency (backward compat - moved lower ) */
-//	range->old_num_channels; 
-//	range->old_num_frequency;
-//	range->old_freq[6]; // Filler to keep "version" at the same offset */
+	
 	if(priv->rf_set_sens != NULL)
-		range->sensitivity = priv->max_sens;	// signal level threshold range */
+		range->sensitivity = priv->max_sens;	
 	
 	range->max_qual.qual = 100;
-	// TODO: Find real max RSSI and stick here */
 	range->max_qual.level = 0;
 	range->max_qual.noise = -98;
-	range->max_qual.updated = 7; // Updated all three */
+	range->max_qual.updated = 7; 
 
-	range->avg_qual.qual = 92; // > 8% missed beacons is 'bad' */
-	// TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.qual = 92; 
 	range->avg_qual.level = 20 + -98;
 	range->avg_qual.noise = 0;
-	range->avg_qual.updated = 7; // Updated all three */
+	range->avg_qual.updated = 7; 
 
 	range->num_bitrates = RATE_COUNT;
 	
@@ -345,27 +314,17 @@
 	range->we_version_compiled = WIRELESS_EXT;
 	range->we_version_source = 16;
 
-//	range->retry_capa;	// What retry options are supported */
-//	range->retry_flags;	// How to decode max/min retry limit */
-//	range->r_time_flags;	// How to decode max/min retry life */
-//	range->min_retry;	// Minimal number of retries */
-//	range->max_retry;	// Maximal number of retries */
-//	range->min_r_time;	// Minimal retry lifetime */
-//	range->max_r_time;	// Maximal retry lifetime */
 
         range->num_channels = 14;
 
 	for (i = 0, val = 0; i < 14; i++) {
 		
-		// Include only legal frequencies for some countries
 		if ((priv->challow)[i+1]) {
 		        range->freq[val].i = i + 1;
 			range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
 			range->freq[val].e = 1;
 			val++;
 		} else {
-			// FIXME: do we need to set anything for channels
-			// we don't use ?
 		}
 		
 		if (val == IW_MAX_FREQUENCIES)
@@ -373,10 +332,11 @@
 	}
 
 	range->num_frequency = val;
+	
+#if WIRELESS_EXT > 17
 	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 
 				| IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
-
-	//tmp->scan_capa = 0x01; //YJ,add,080819,for hidden ap
+#endif
 
 	return 0;
 }
@@ -399,25 +359,27 @@
 		return 0;
 #endif
 
-//YJ,add,080819, for hidden ap
-	//printk("==*&*&*&==>%s in\n", __func__);	
-	//printk("=*&*&*&*===>flag:%x, %x\n", wrqu->data.flags, IW_SCAN_THIS_ESSID);
+#if WIRELESS_EXT > 17
 	if (wrqu->data.flags & IW_SCAN_THIS_ESSID)
 	{
 		struct iw_scan_req* req = (struct iw_scan_req*)b;
 		if (req->essid_len)
 		{
-			//printk("==**&*&*&**===>scan set ssid:%s\n", req->essid);
 			ieee->current_network.ssid_len = req->essid_len;
 			memcpy(ieee->current_network.ssid, req->essid, req->essid_len); 
-			//printk("=====>network ssid:%s\n", ieee->current_network.ssid);
 		}
 	}
-//YJ,add,080819, for hidden ap, end	
-	
+#endif
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_scan(priv->ieee80211,a,wrqu,b);
+
+	if(priv->ieee80211->state != IEEE80211_LINKED){
+		priv->ieee80211->scanning = 0;
+		priv->ieee80211->sync_scan_hurryup = 0;
+		ieee80211_start_scan_syncro(priv->ieee80211);
+		ret = 0;
+	}else	
+		ret = ieee80211_wx_set_scan(priv->ieee80211,a,wrqu,b);
 	
 	up(&priv->wx_sem);
 	return ret;
@@ -552,7 +514,7 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
 	wrqu->frag.value = priv->ieee80211->fts;
-	wrqu->frag.fixed = 0;	// no auto select */
+	wrqu->frag.fixed = 0;	
 	wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
 
 	return 0;
@@ -671,19 +633,8 @@
 		DMESG("Setting retry for non RTS/CTS data to %d", wrqu->retry.value);
 	}
 	
-	// FIXME ! 
-	// We might try to write directly the TX config register
-	// or to restart just the (R)TX process.
-	// I'm unsure if whole reset is really needed
-	// 
 
  	rtl8180_commit(dev);
-	//if(priv->up){
-	//	rtl8180_rtx_disable(dev);
-	//	rtl8180_rx_enable(dev);
-	//	rtl8180_tx_enable(dev);
-	//		
-	//}
 exit:
 	up(&priv->wx_sem);
 	
@@ -697,7 +648,7 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	
 
-	wrqu->retry.disabled = 0; // can't be disabled */
+	wrqu->retry.disabled = 0; 
 
 	if ((wrqu->retry.flags & IW_RETRY_TYPE) == 
 	    IW_RETRY_LIFETIME) 
@@ -710,7 +661,6 @@
 		wrqu->retry.flags = IW_RETRY_LIMIT & IW_RETRY_MIN;
 		wrqu->retry.value = priv->retry_data;
 	}
-	//DMESG("returning %d",wrqu->retry.value);
 	
 
 	return 0;
@@ -722,7 +672,7 @@
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	if(priv->rf_set_sens == NULL) 
-		return -1; // we have not this support for this radio */
+		return -1; 
 	wrqu->sens.value = priv->sens;
 	return 0;
 }
@@ -741,9 +691,8 @@
 		return 0;
 	
 	down(&priv->wx_sem);
-	//DMESG("attempt to set sensivity to %ddb",wrqu->sens.value);
 	if(priv->rf_set_sens == NULL) {
-		err= -1; // we have not this support for this radio */
+		err= -1; 
 		goto exit;
 	}
 	if(priv->rf_set_sens(dev, wrqu->sens.value) == 0)
@@ -767,18 +716,19 @@
                                         struct iw_request_info *info,
                                         union iwreq_data *wrqu, char *extra)
 {
+	int ret=0;
 	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	int ret=0;
 	
 	if(priv->ieee80211->bHwRadioOff)
 		return 0;
 
 	down(&priv->wx_sem);
-	//printk("====>%s()\n)", __FUNCTION__);
+
 	ret = ieee80211_wx_set_encode_ext(priv->ieee80211, info, wrqu, extra);
 	up(&priv->wx_sem);
+#endif
 	return ret;	
 
 }
@@ -786,17 +736,20 @@
                                         struct iw_request_info *info,
                                         union iwreq_data *data, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+
 	int ret=0;
-	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
+	struct r8180_priv *priv = ieee80211_priv(dev);
+
 	if(priv->ieee80211->bHwRadioOff)
 		return 0;
 
 	down(&priv->wx_sem);
 
-	//printk("====>%s()\n)", __FUNCTION__);
+
 	ret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);
 	up(&priv->wx_sem);
+#endif
 	return ret;
 }
 
@@ -805,39 +758,40 @@
                                         union iwreq_data *wrqu, char *extra)
 {
 	int ret=0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	
 	if(priv->ieee80211->bHwRadioOff)
 		return 0;
 
 	down(&priv->wx_sem);
-#if 1
 
-	//printk("====>%s()\n)", __FUNCTION__);
+
 	ret = ieee80211_wx_set_mlme(priv->ieee80211, info, wrqu, extra);
-#endif
+
 	up(&priv->wx_sem);
+#endif
 	return ret;
 }
 static int r8180_wx_set_gen_ie(struct net_device *dev,
                                         struct iw_request_info *info,
                                         union iwreq_data *data, char *extra)
 {
-	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
 	int ret=0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
         struct r8180_priv *priv = ieee80211_priv(dev);
 	
 	if(priv->ieee80211->bHwRadioOff)
 		return 0;
 
         down(&priv->wx_sem);
-#if 1
 
-	//printk("====>%s()\n)", __FUNCTION__);
+
+
         ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
-#endif
+
         up(&priv->wx_sem);
-	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
+#endif
         return ret;
 
 
@@ -877,8 +831,6 @@
 	}
 	
 	ret = ieee80211_wx_set_power(priv->ieee80211, info, wrqu, extra);
-	//DMESG("power save mode is not supported yet when using rtl general ieee80211 stack!");
-	//ret = -1;	
 
 	up(&priv->wx_sem);
 	
@@ -948,7 +900,6 @@
 	} else {
 		ieee->mode = mode;
 		ieee->modulation = modulation;
-//		ieee80211_start_protocol(ieee);
 	}
 
 	up(&priv->wx_sem);
@@ -982,7 +933,7 @@
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
-	*extra = (char) priv->plcp_preamble_mode; 	// 0:auto 1:short 2:long
+	*extra = (char) priv->plcp_preamble_mode; 	
 	up(&priv->wx_sem);
 
 	return 0;
@@ -993,11 +944,9 @@
 			       union iwreq_data *wrqu, char *extra)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//struct ieee80211_network *network = &(priv->ieee80211->current_network);
 	int ret = 0;
 	down(&priv->wx_sem);
-	// Modify by hikaru 6.5
-	*((int *)extra) = priv->wstats.qual.level;//for interface test ,it should be the priv->wstats.qual.level;
+	*((int *)extra) = priv->wstats.qual.level;
 	up(&priv->wx_sem);
 
 	return ret;
@@ -1008,11 +957,9 @@
 			       union iwreq_data *wrqu, char *extra)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//struct ieee80211_network *network = &(priv->ieee80211->current_network);
 	int ret = 0;
 	down(&priv->wx_sem);
-	// Modify by hikaru 6.5
-	*((int *)extra) = priv->wstats.qual.qual;//for interface test ,it should be the priv->wstats.qual.qual;
+	*((int *)extra) = priv->wstats.qual.qual;
 	up(&priv->wx_sem);
 
 	return ret;
@@ -1027,23 +974,15 @@
 	down(&priv->wx_sem);
 
 	priv->stats.txrdu = 0;
-//	priv->stats.rxrdu = 0;
-//	priv->stats.rxnolast = 0;
-//	priv->stats.rxnodata = 0;
-//	priv->stats.rxnopointer = 0;
 	priv->stats.txnperr = 0;
 	priv->stats.txresumed = 0;
 	priv->stats.rxerr = 0;
-//	priv->stats.rxoverflow = 0;
 	priv->stats.rxint = 0; 
 
 	priv->stats.txnpokint = 0;
 	priv->stats.txhpokint = 0;
 	priv->stats.txhperr = 0;
-//	priv->stats.ints = 0;
-//	priv->stats.shints = 0;
 	priv->stats.txoverflow = 0;
-//	priv->stats.rxdmafail = 0;
 	priv->stats.txretry=0;
 	priv->stats.txok=0;
 	priv->stats.txerr=0;
@@ -1052,7 +991,7 @@
 	priv->stats.txlpokint = 0;
 	priv->stats.txlperr = 0;
 	priv->stats.rxok=0;
-	priv->stats.rxretry =0;//20060601
+	priv->stats.rxretry =0;
 	priv->stats.rxcrcerrmin=0;
 	priv->stats.rxcrcerrmid=0;
 	priv->stats.rxcrcerrmax=0;
@@ -1072,7 +1011,6 @@
 
 	down(&priv->wx_sem);
 	priv->rf_wakeup(dev);
-// lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	priv->iwpriv_radio_on = 1;
 #endif
@@ -1090,7 +1028,6 @@
 
 	down(&priv->wx_sem);
 	priv->rf_sleep(dev);
-// lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	priv->iwpriv_radio_on = 0;
 #endif
@@ -1105,10 +1042,8 @@
 			     union iwreq_data *wrqu, char *extra)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//struct ieee80211_device *ieee = netdev_priv(dev);
 	int *val = (int *)extra;
 	int i;
-	//unsigned long flags;
 	
 	if(priv->ieee80211->bHwRadioOff)
 		return 0;
@@ -1116,10 +1051,8 @@
 	down(&priv->wx_sem);
 	if (DefaultChannelPlan[*val].Len != 0){
 		priv ->channel_plan = *val;
-		// Clear old channel map
 		for (i=1;i<=MAX_CHANNEL_NUMBER;i++)
 			priv->ieee80211->channel_map[i] = 0;
-		// Set new channel map
 		for (i=1;i<=DefaultChannelPlan[*val].Len;i++) 
 			priv->ieee80211->channel_map[DefaultChannelPlan[*val].Channel[i-1]] = 1;
 	}
@@ -1146,7 +1079,6 @@
 			       union iwreq_data *wrqu, char *extra)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//struct ieee80211_device *ieee;
 
 	down(&priv->wx_sem);
 	strcpy(extra, "1020.0808");
@@ -1179,7 +1111,11 @@
         NULL,                     /* SIOCWIWTHRSPY */
         r8180_wx_set_wap,      	  /* SIOCSIWAP */
         r8180_wx_get_wap,         /* SIOCGIWAP */
-        r8180_wx_set_mlme, //NULL,    /* SIOCSIWMLME*/                 /* -- hole -- */
+#if (WIRELESS_EXT >= 18)
+        r8180_wx_set_mlme, 
+#else
+  	NULL,
+#endif
         dummy,                     /* SIOCGIWAPLIST -- depricated */
         r8180_wx_set_scan,        /* SIOCSIWSCAN */
         r8180_wx_get_scan,        /* SIOCGIWSCAN */
@@ -1201,20 +1137,24 @@
         r8180_wx_get_retry,       /* SIOCGIWRETRY */
         r8180_wx_set_enc,         /* SIOCSIWENCODE */
         r8180_wx_get_enc,         /* SIOCGIWENCODE */
-//	dummy,
-//	dummy,
         r8180_wx_set_power,                    /* SIOCSIWPOWER */
         r8180_wx_get_power,                    /* SIOCGIWPOWER */
-		NULL,			/*---hole---*/
-		NULL, 			/*---hole---*/
-		r8180_wx_set_gen_ie,//NULL, 			/* SIOCSIWGENIE */
-		NULL, 			/* SIOCSIWGENIE */
-		r8180_wx_set_auth,//NULL, 			/* SIOCSIWAUTH */
-		NULL,//r8180_wx_get_auth,//NULL, 			/* SIOCSIWAUTH */
-		r8180_wx_set_enc_ext, 			/* SIOCSIWENCODEEXT */
-		NULL,//r8180_wx_get_enc_ext,//NULL, 			/* SIOCSIWENCODEEXT */
-		NULL, 			/* SIOCSIWPMKSA */
-		NULL, 			 /*---hole---*/
+	NULL,			/*---hole---*/
+	NULL, 			/*---hole---*/
+	r8180_wx_set_gen_ie,
+	NULL, 			/* SIOCSIWGENIE */
+#if (WIRELESS_EXT >= 18)
+	r8180_wx_set_auth,
+	NULL,
+	r8180_wx_set_enc_ext, 			/* SIOCSIWENCODEEXT */
+#else
+	NULL,
+	NULL,
+	NULL,
+#endif
+	NULL,
+	NULL, 			/* SIOCSIWPMKSA */
+	NULL, 			 /*---hole---*/
 }; 
 
 
@@ -1319,12 +1259,8 @@
 
 
 static iw_handler r8180_private_handler[] = {
-//	r8180_wx_set_monitor,  /* SIOCIWFIRSTPRIV */
 	r8180_wx_set_crcmon,   /*SIOCIWSECONDPRIV*/
 	dummy,
-//	r8180_wx_set_forceassociate,
-//	r8180_wx_set_beaconinterval,
-//	r8180_wx_set_monitor_type,
 	dummy,
 	dummy,
 	r8180_wx_set_scan_type,
@@ -1354,35 +1290,25 @@
                                   struct ieee80211_network *dst,
 				  struct ieee80211_device *ieee)
 {
-        // A network is only a duplicate if the channel, BSSID, ESSID
-        // and the capability field (in particular IBSS and BSS) all match.  
-        // We treat all <hidden> with the same BSSID and channel
-        // as one network */
-        return (((src->ssid_len == dst->ssid_len)||(ieee->iw_mode == IW_MODE_INFRA)) &&  //YJ,mod, 080819,for hidden ap
-			//((src->ssid_len == dst->ssid_len) &&
+        return (((src->ssid_len == dst->ssid_len)||(ieee->iw_mode == IW_MODE_INFRA)) &&  
 			(src->channel == dst->channel) &&
 			!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
-			(!memcmp(src->ssid, dst->ssid, src->ssid_len)||(ieee->iw_mode == IW_MODE_INFRA)) &&  //YJ,mod, 080819,for hidden ap 
-			//!memcmp(src->ssid, dst->ssid, src->ssid_len) &&
+			(!memcmp(src->ssid, dst->ssid, src->ssid_len)||(ieee->iw_mode == IW_MODE_INFRA)) &&  
 			((src->capability & WLAN_CAPABILITY_IBSS) ==
 			(dst->capability & WLAN_CAPABILITY_IBSS)) &&
 			((src->capability & WLAN_CAPABILITY_BSS) ==
 			(dst->capability & WLAN_CAPABILITY_BSS)));
 }
 
-//WB modefied to show signal to GUI on 18-01-2008
 static struct iw_statistics *r8180_get_wireless_stats(struct net_device *dev)
 {
        struct r8180_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
 	struct iw_statistics* wstats = &priv->wstats;
-	//struct ieee80211_network* target = NULL;
 	int tmp_level = 0;
 	int tmp_qual = 0;
 	int tmp_noise = 0;
-	//unsigned long flag;
 
-//	printk("=====>%s level:%d, qual:%d, noise:%d\n", __func__, tmp_level, tmp_qual, tmp_noise);
 	if (ieee->state < IEEE80211_LINKED)
 	{
 		wstats->qual.qual = 0;
@@ -1428,7 +1354,6 @@
 	tmp_level = (&ieee->current_network)->stats.signal;
 	tmp_qual = (&ieee->current_network)->stats.signalstrength;
 	tmp_noise = (&ieee->current_network)->stats.noise;			
-//	printk("=====>level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
 	
 	wstats->qual.level = tmp_level;
 	wstats->qual.qual = tmp_qual;
diff -ruN rtl8187l_orig/rtl8187/r8187_core.c rtl8187l/rtl8187/r8187_core.c
--- rtl8187l_orig/rtl8187/r8187_core.c	2011-01-02 18:14:31.043506000 +0100
+++ rtl8187l/rtl8187/r8187_core.c	2011-01-03 14:26:57.841770000 +0100
@@ -55,24 +55,24 @@
 #undef DEBUG_TX_ALLOC
 #undef DEBUG_TX_DESC
 
-//#define CONFIG_RTL8180_IO_MAP
 
 #include "r8180_hw.h"
 #include "r8187.h"
-#include "r8180_rtl8225.h" // RTL8225 Radio frontend */
-#include "r8180_93cx6.h"   // Card EEPROM */
+#include "r8180_rtl8225.h" 
+#include "r8180_93cx6.h"   
 #include "r8180_wx.h"
 #include "r8180_dm.h"
 
 
-// FIXME: check if 2.6.7 is ok
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7))
 #define usb_kill_urb usb_unlink_urb
 #endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 #ifdef CONFIG_PM
 #include "r8180_pm.h"
 #endif
+#endif
 
 #ifndef USB_VENDOR_ID_REALTEK
 #define USB_VENDOR_ID_REALTEK		0x0bda
@@ -92,7 +92,6 @@
 	{}
 };
 
-//static char* ifname = "ath%d";
 static char* ifname = "wlan%d";
 #if 0
 static int hwseqnum = 0;
@@ -108,15 +107,11 @@
 	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},
 	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},
 	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},				//sean fix (for cameo)
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},};//Ida add for 11a
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},				
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},};
 #define eqMacAddr(a,b)                                          ( ((a)[0]==(b)[0] && (a)[1]==(b)[1] && (a)[2]==(b)[2] && (a)[3]==(b)[3] && (a)[4]==(b)[4] && (a)[5]==(b)[5]) ? 1:0 )
-//by amy for rate adaptive
 #define DEFAULT_RATE_ADAPTIVE_TIMER_PERIOD      300
-//by amy for rate adaptive
-//by amy for ps
 #define IEEE80211_WATCH_DOG_TIME    2000
-//by amy for ps
 MODULE_LICENSE("GPL");
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 MODULE_VERSION("V 1.1");
@@ -141,37 +136,39 @@
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
 module_param(ifname, charp, S_IRUGO|S_IWUSR );
-//module_param(hwseqnum,int, S_IRUGO|S_IWUSR);
-//module_param(hwwep,int, S_IRUGO|S_IWUSR);
 module_param(channels,int, S_IRUGO|S_IWUSR);
 #else
 MODULE_PARM(ifname, "s");
-//MODULE_PARM(hwseqnum,"i");
-//MODULE_PARM(hwwep,"i");
 MODULE_PARM(channels,"i");
 #endif
 
 MODULE_PARM_DESC(devname," Net interface name,ath%d=default");
-//MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
-//MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
-//MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
 MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static int __devinit rtl8187_usb_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id);
-			 
 static void __devexit rtl8187_usb_disconnect(struct usb_interface *intf);
+#else
+static void *__devinit rtl8187_usb_probe(struct usb_device *udev,unsigned int ifnum,
+			 const struct usb_device_id *id);
+static void __devexit rtl8187_usb_disconnect(struct usb_device *udev, void *ptr);
+#endif
 
 static struct usb_driver rtl8187_usb_driver = {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
 	.owner		= THIS_MODULE,
 #endif
-	.name		= RTL8187_MODULE_NAME,	          // Driver name   */
-	.id_table	= rtl8187_usb_id_tbl,	          // PCI_ID table  */
-	.probe		= rtl8187_usb_probe,	          // probe fn      */
-	.disconnect	= rtl8187_usb_disconnect,	  // remove fn     */
-	.suspend	= rtl8187_suspend,	          // PM suspend fn */
-	.resume		= rtl8187_resume,                 // PM resume fn  */
+	.name		= RTL8187_MODULE_NAME,	          
+	.id_table	= rtl8187_usb_id_tbl,	          
+	.probe		= rtl8187_usb_probe,	          
+	.disconnect	= rtl8187_usb_disconnect,	  
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+#ifdef CONFIG_PM
+	.suspend	= rtl8187_suspend,	          
+	.resume		= rtl8187_resume,                 
+#endif
+#endif
 };
 
 
@@ -274,17 +271,11 @@
 	return data;
 }
 
-// this might still called in what was the PHY rtl8185/rtl8187 common code 
-// plans are to possibilty turn it again in one common code...
-//
 inline void force_pci_posting(struct net_device *dev)
 {
 }
 
 
-//irqreturn_t rtl8180_interrupt(int irq, void *netdev, struct pt_regs *regs);
-//void set_nic_rxring(struct net_device *dev);
-//void set_nic_txring(struct net_device *dev);
 static struct net_device_stats *rtl8180_stats(struct net_device *dev);
 void rtl8180_commit(struct net_device *dev);
 
@@ -295,8 +286,6 @@
  void rtl8180_restart(struct net_device *dev);
 void rtl8180_rq_tx_ack(struct net_device *dev);
 #endif
-//void rtl8180_restart(struct net_device *dev);
-//void rtl8180_rq_tx_ack(struct net_device *dev);
 
 /****************************************************************************
    -----------------------------PROCFS STUFF-------------------------
@@ -309,17 +298,14 @@
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	
 	int len = 0;
 	int i,n;
 			
 	int max=0xff;
 	
-	// This dump the current register page */
 	for(n=0;n<=max;)
 	{
-		//printk( "\nD: %2x> ", n);
 		len += snprintf(page + len, count - len,
 			"\nD:  %2x > ",n);
 
@@ -327,7 +313,6 @@
 		len += snprintf(page + len, count - len,
 			"%2x ",read_nic_byte(dev,n));
 
-		//	printk("%2x ",read_nic_byte(dev,n));
 	}
 	len += snprintf(page + len, count - len,"\n");
 
@@ -372,40 +357,6 @@
 
 	
 	len += snprintf(page + len, count - len,
-//		"TX normal priority ok int: %lu\n"
-//		"TX normal priority error int: %lu\n"
-//		"TX high priority ok int: %lu\n"
-//		"TX high priority failed error int: %lu\n"
-//		"TX low priority ok int: %lu\n"
-//		"TX low priority failed error int: %lu\n"
-//		"TX queue resume: %lu\n"
-//		"TX queue stopped?: %d\n"
-//		"TX fifo overflow: %lu\n"
-//		"TX beacon: %lu\n"
-//		"TX lp queue: %d\n"
-//		"TX np queue: %d\n"
-//		"TX HW queue: %d\n"
-//		"TX lp dropped: %lu\n"
-//		"TX np dropped: %lu\n"
-//		"TX total data packets %lu\n",		
-//		"TX beacon aborted: %lu\n",
-//		priv->stats.txnpokint,
-//		priv->stats.txnperr,
-//		priv->stats.txhpokint,
-//		priv->stats.txhperr,
-//		priv->stats.txlpokint,
-//		priv->stats.txlperr,
-//		priv->stats.txresumed,
-//		netif_queue_stopped(dev),
-//		priv->stats.txoverflow,
-//		priv->stats.txbeacon,
-//		atomic_read(&(priv->tx_lp_pending)),
-//		atomic_read(&(priv->tx_np_pending)),
-//		read_nic_byte(dev, TXFIFOCOUNT),
-//		priv->stats.txlpdrop,
-//		priv->stats.txnpdrop,
-//		priv->stats.txdatapkt
-//		priv->stats.txbeaconerr
 		"TX OK: %lu\n"
 		"TX Error: %lu\n"
 		"TX Retry: %lu\n"
@@ -435,12 +386,6 @@
 	int len = 0;
 	
 	len += snprintf(page + len, count - len,
-		//"RX packets: %lu\n"
-		//"RX urb status error: %lu\n"
-		//"RX invalid urb error: %lu\n",
-		//priv->stats.rxok,
-		//priv->stats.rxstaterr,
-		//priv->stats.rxurberr
 		"RX OK: %lu\n"
 		"RX Retry: %lu\n"
 		"RX CRC Error(0-500): %lu\n"
@@ -494,11 +439,8 @@
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	if (priv->dir_dev) {
-	//	remove_proc_entry("stats-hw", priv->dir_dev);
 		remove_proc_entry("stats-tx", priv->dir_dev);
 		remove_proc_entry("stats-rx", priv->dir_dev);
-	//	remove_proc_entry("stats-ieee", priv->dir_dev);
-	//	remove_proc_entry("stats-ap", priv->dir_dev);
 		remove_proc_entry("registers", priv->dir_dev);
 		remove_proc_entry(dev->name, rtl8180_proc);
 		priv->dir_dev = NULL;
@@ -580,7 +522,6 @@
    -----------------------------MISC STUFF-------------------------
 *****************************************************************************/
 
-// this is only for debugging */
 void print_buffer(u32 *buffer, int len)
 {
 	int i;
@@ -612,18 +553,15 @@
 void tx_timeout(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//rtl8180_commit(dev);
 	printk(KERN_INFO "Timeout pending %d!\n",atomic_read(&priv->tx_lp_pending));
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 	schedule_work(&priv->reset_wq);
 #else
 	schedule_task(&priv->reset_wq);
 #endif
-	//DMESG("TXTIMEOUT");
 }
 
 
-// this is only for debug */
 void dump_eprom(struct net_device *dev)
 {
 	int i;
@@ -631,7 +569,6 @@
 		DMESG("EEPROM addr %x : %x", i, eprom_read(dev,i));
 }
 
-// this is only for debug */
 void rtl8180_dump_reg(struct net_device *dev)
 {
 	int i;
@@ -657,22 +594,15 @@
 void rtl8180_irq_enable(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);	
-	//priv->irq_enabled = 1;
-//	write_nic_word(dev,INTA_MASK,INTA_RXOK | INTA_RXDESCERR | INTA_RXOVERFLOW | 
-//	INTA_TXOVERFLOW | INTA_HIPRIORITYDESCERR | INTA_HIPRIORITYDESCOK | 
-//	INTA_NORMPRIORITYDESCERR | INTA_NORMPRIORITYDESCOK |
-//	INTA_LOWPRIORITYDESCERR | INTA_LOWPRIORITYDESCOK | INTA_TIMEOUT);
 	write_nic_word(dev,INTA_MASK, priv->irq_mask);
 }
 
 
 void rtl8180_irq_disable(struct net_device *dev)
 {
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);	
 
 	write_nic_word(dev,INTA_MASK,0);
 	force_pci_posting(dev);
-//	priv->irq_enabled = 0;
 }
 
 
@@ -696,11 +626,6 @@
 	msr  = read_nic_byte(dev, MSR);
 	msr &= ~ MSR_LINK_MASK;
 	
-	// do not change in link_state != WLAN_LINK_ASSOCIATED.
-	// msr must be updated if the state is ASSOCIATING. 
-	// this is intentional and make sense for ad-hoc and
-	// master (see the create BSS/IBSS func)
-	// 
 	if (priv->ieee80211->state == IEEE80211_LINKED){ 
 			
 		if (priv->ieee80211->iw_mode == IW_MODE_INFRA)
@@ -731,7 +656,6 @@
 		}
 	#endif
 	
-	// this hack should avoid frame TX during channel setting*/
 	tx = read_nic_dword(dev,TX_CONF);
 	tx &= ~TX_LOOPBACK_MASK;
 
@@ -739,7 +663,6 @@
 	write_nic_dword(dev,TX_CONF, tx |( TX_LOOPBACK_MAC<<TX_LOOPBACK_SHIFT));
 
 	priv->rf_set_chan(dev,priv->chan);
-	//mdelay(10);
 	write_nic_dword(dev,TX_CONF,tx | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT));
 #endif
 }
@@ -748,7 +671,6 @@
 #else
 void rtl8187_rx_isr(struct urb *rx_urb);
 #endif
-//void rtl8187_rx_isr(struct urb *rx_urb);
 
 
 void rtl8187_rx_urbsubmit(struct net_device *dev, struct urb* rx_urb)
@@ -759,18 +681,17 @@
 	if(priv->ieee80211->bHwRadioOff == true)
 		return;
 #endif
-//	u8 *rx;
 	
-	//DMESG("starting RX");
-	//rx = kmalloc(RX_URB_SIZE*sizeof(u8),GFP_ATOMIC);
-	//if(!rx){ 
-	//	DMESGE("unable to allocate RX buffer");
-	//	return;
-	//}
 	
 	usb_fill_bulk_urb(rx_urb,priv->udev,usb_rcvbulkpipe(priv->udev,0x81), 
 			  rx_urb->transfer_buffer,RX_URB_SIZE,rtl8187_rx_isr,dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	err = usb_submit_urb(rx_urb, GFP_ATOMIC);	
+#else
+	err = usb_submit_urb(rx_urb);	
+#endif
+
 	if(err && err != -EPERM){
 		DMESGE("cannot submit RX command. URB_STATUS %x",rx_urb->status);
 		
@@ -786,7 +707,7 @@
 	
 	if(!priv->rx_urb)
 		DMESGE("Cannot intiate RX urb mechanism");
-	for(i=0;i<MAX_RX_URB;i++) // RX_MAX_URB is 1 
+	for(i=0;i<MAX_RX_URB;i++) 
 		rtl8187_rx_urbsubmit(dev,priv->rx_urb[i]);
 	priv->tx_urb_index = 0;
 		
@@ -818,10 +739,6 @@
 		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
 	}
 	
-	//if(priv->ieee80211->iw_mode == IW_MODE_MASTER){
-	//	rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
-	//	rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
-	//}
 	
 	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR){
 		rxconf = rxconf | (1<<ACCEPT_ICVERR_FRAME_SHIFT);
@@ -843,16 +760,10 @@
 	
 	rxconf = rxconf | RCR_ONLYERLPKT;
 	
-//	rxconf = rxconf &~ RCR_CS_MASK;
-//	rxconf = rxconf | (1<<RCR_CS_SHIFT);
 
 	write_nic_dword(dev, RX_CONF, rxconf);	
 	
-	// V rtl suggested V //
-//	write_nic_dword(dev, RX_CONF, 0x901ce70e);
 	
-	//fix_rx_fifo(dev);
-// 	//set_nic_rxring(dev);
 	#ifdef DEBUG_RX
 	DMESG("rxconf: %x %x",rxconf ,read_nic_dword(dev,RX_CONF));
 	#endif
@@ -870,11 +781,6 @@
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_RX_ENABLE_SHIFT));
 
-	// In rtl8139 driver seems that DMA threshold has to be written 
-	// after enabling RX, so we rewrite RX_CONFIG register 
-	// 
-	//mdelay(100);
-	//write_nic_dword(dev, RX_CONF, rxconf); 
 	
 }
 
@@ -923,8 +829,8 @@
 	txconf = txconf &~ TCR_DPRETRY_MASK;
 	txconf = txconf &~ TCR_RTSRETRY_MASK;
 	
-	txconf = txconf | (priv->retry_data<<TX_DPRETRY_SHIFT); // long
-	txconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT); // short
+	txconf = txconf | (priv->retry_data<<TX_DPRETRY_SHIFT); 
+	txconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT); 
 	
 	txconf = txconf &~ (1<<TX_NOCRC_SHIFT);
 	
@@ -939,8 +845,6 @@
 	
 	write_nic_dword(dev,TX_CONF,txconf);
 	
-	// V RTL suggested V //
-//	write_nic_dword(dev,TX_CONF,0x00e00707);
 
 
 #ifdef DEBUG_TX
@@ -950,12 +854,6 @@
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));		
 
-	//mdelay(100);
-	//write_nic_dword(dev,TX_CONF,txconf);
-	//#endif
-	//rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	//write_nic_byte(dev, TX_DMA_POLLING, priv->dma_poll_mask);
-	//rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 }
 
 #if 0
@@ -984,16 +882,14 @@
 
 void rtl8180_rtx_disable(struct net_device *dev)
 {
-	//struct r8180_priv *priv = ieee80211_priv(dev);
 	u8 cmd;
-	//int i;
 	
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev, CMD, cmd &~ \
 		       ((1<<CMD_RX_ENABLE_SHIFT)|(1<<CMD_TX_ENABLE_SHIFT)));
 	force_pci_posting(dev);
 	mdelay(10);
-#if 0 //lzm for suspend crash
+#if 0 
 	if(priv->rx_urb){
 		for(i=0;i<MAX_RX_URB;i++)
 		usb_kill_urb(priv->rx_urb[i]);
@@ -1015,11 +911,7 @@
 					  &priv->txbeaconringdma);
 	if (!priv->txbeaconring) return -1;
 	for (tmp=priv->txbeaconring,i=0;i<count;i++){
-		*tmp = *tmp &~ (1<<31); // descriptor empty, owned by the drv 
-		//
-		//(tmp+2) = (u32)dma_tmp;
-		//(tmp+3) = bufsize;
-		//
+		*tmp = *tmp &~ (1<<31); 
 		if(i+1<count)
 			*(tmp+4) = (u32)priv->txbeaconringdma+((i+1)*8*4);
 		else
@@ -1037,9 +929,6 @@
 	
 	u8 cr;
 	
-	//  make sure the analog power is on before
-	//  reset, otherwise reset may fail
-	// 
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
 	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
 	
@@ -1069,9 +958,6 @@
 	force_pci_posting(dev);
 	mdelay(200);
 
-	//  after the eeprom load cycle, make sure we have
-	//  correct anaparams
-	// 
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
 	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
 	
@@ -1183,16 +1069,16 @@
 	if( rtl8180_IsWirelessBMode(DataRate) )
 	{
 		if( bManagementFrame || !bShortPreamble || DataRate == 10 )
-		{	// long preamble
+		{	
 			FrameTime = (u16)(144+48+(FrameLength*8/(DataRate/10)));		
 		}
 		else
-		{	// Short preamble
+		{	
 			FrameTime = (u16)(72+24+(FrameLength*8/(DataRate/10)));
 		}
-		if( ( FrameLength*8 % (DataRate/10) ) != 0 ) //Get the Ceilling
+		if( ( FrameLength*8 % (DataRate/10) ) != 0 ) 
 				FrameTime ++;
-	} else {	//802.11g DSSS-OFDM PLCP length field calculation.
+	} else {	
 		N_DBPS = N_DBPSOfRate(DataRate);
 		Ceiling = (16 + 8*FrameLength + 6) / N_DBPS 
 				+ (((16 + 8*FrameLength + 6) % N_DBPS) ? 1 : 0);
@@ -1208,23 +1094,17 @@
 #else
 void rtl8187_rx_isr(struct urb *rx_urb)
 #endif
-//void rtl8187_rx_isr(struct urb *rx_urb)
 {
 	struct net_device *dev = (struct net_device*)rx_urb->context;
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
 	priv->rxurb_task = rx_urb;
-	//DMESGW("David: Rx tasklet start!");
 	tasklet_schedule(&priv->irq_rx_tasklet);
-       // schedule_work(&priv->ieee80211->rx_handle_wq);
-       //queue_work(priv->ieee80211->wq,&priv->ieee80211->rx_handle_wq);	
-//	DMESGW("=David: Rx tasklet finish!");
 }
 
 #if 0
 void rtl8180_tx_queues_stop(struct net_device *dev)
 {
-	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	u8 dma_poll_mask = (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
 	dma_poll_mask |= (1<<TX_DMA_STOP_HIPRIORITY_SHIFT);
 	dma_poll_mask |= (1<<TX_DMA_STOP_NORMPRIORITY_SHIFT);
@@ -1238,7 +1118,6 @@
 
 void rtl8180_data_hard_stop(struct net_device *dev)
 {
-	//FIXME !!
 	#if 0
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	priv->dma_poll_mask |= (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
@@ -1251,7 +1130,6 @@
 
 void rtl8180_data_hard_resume(struct net_device *dev)
 {
-	// FIXME !!
 	#if 0
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	priv->dma_poll_mask &= ~(1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
@@ -1262,9 +1140,6 @@
 }
 
 
-// this function TX data frames when the ieee80211 stack requires this.
-// It checks also if we need to stop the ieee tx queue, eventually do it
-// 
 void rtl8180_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int rate)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -1275,13 +1150,6 @@
 
 	if (le16_to_cpu(h->frame_ctl) & IEEE80211_FCTL_MOREFRAGS)
 		morefrag = 1;
-        //
-	// This function doesn't require lock because we make
-	// sure it's called with the tx_lock already acquired.
-	// this come from the kernel's hard_xmit callback (trought
-	// the ieee stack, or from the try_wake_queue (again trought
-	// the ieee stack.
-	//
 	spin_lock_irqsave(&priv->tx_lock,flags);	
 		
 	if(priv->ieee80211->bHwRadioOff)
@@ -1294,9 +1162,7 @@
 		DMESG("Error: no TX slot ");
 		ieee80211_stop_queue(priv->ieee80211);
 	}
-//by lizhaoming for LED TX 2008.6.23	
 #ifdef LED_SHIN
-//	printk("==================>data tx\n");
 	priv->ieee80211->ieee80211_led_contorl(dev,LED_CTL_TX); 
 #endif	
 	
@@ -1312,11 +1178,6 @@
 			
 }
 #if 0
-//  This is a rough attempt to TX a frame
-//  This is called by the ieee 80211 stack to TX management frames.
-//  If the ring is full packet are dropped (for data frame the queue
-//  is stopped before this can happen).
-// 
 int rtl8180_hard_start_xmit(struct sk_buff *skb,struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -1326,10 +1187,6 @@
 	spin_lock_irqsave(&priv->tx_lock,flags);
 	
 	ret = rtl8180_tx(dev, (u32*)skb->data, skb->len, NORM_PRIORITY, 0,DEFAULT_BASICRATE);
-//	int i;
-//	for(i=0;i<skb->len;i++)
-//		printk("%x ", skb->data[i]);
-//	printk("--------------------\n");
 	priv->ieee80211->stats.tx_bytes+=skb->len;
 	priv->ieee80211->stats.tx_packets++;
 	
@@ -1341,7 +1198,6 @@
 #endif
 
 #if 0
-// longpre 144+48 shortpre 72+24
 u16 rtl8180_len2duration(u32 len, short rate,short* ext)
 {
 	u16 duration;
@@ -1349,7 +1205,7 @@
 	*ext=0;
 	
 	switch(rate){
-	case 0://1mbps
+	case 0:
 		*ext=0;
 		duration = ((len+4)<<4) /0x2;
 		drift = ((len+4)<<4) % 0x2;
@@ -1357,7 +1213,7 @@
 		duration++;
 		break;
 		
-	case 1://2mbps
+	case 1:
 		*ext=0;
 		duration = ((len+4)<<4) /0x4;
 		drift = ((len+4)<<4) % 0x4;
@@ -1365,7 +1221,7 @@
 		duration++;
 		break;
 		
-	case 2: //5.5mbps
+	case 2: 
 		*ext=0;
 		duration = ((len+4)<<4) /0xb;
 		drift = ((len+4)<<4) % 0xb;
@@ -1375,7 +1231,7 @@
 		break;
 		
 	default:
-	case 3://11mbps				
+	case 3:
 		*ext=0;
 		duration = ((len+4)<<4) /0x16;
 		drift = ((len+4)<<4) % 0x16;
@@ -1407,10 +1263,7 @@
 		priv->stats.txlpokint++;
 	else
 		priv->stats.txlperr++;
-	//kfree(tx_urb->transfer_buffer);
-	//usb_free_urb(tx_urb);
 	atomic_dec(&priv->tx_lp_pending);
-//	printk(KERN_INFO "lptx urb %d\n",priv->tx_lp_pending);
 	rtl8180_try_wake_queue(dev,LOW_PRIORITY);
 }
 
@@ -1441,12 +1294,9 @@
 	
 	write_nic_dword(dev,BSSID,((u32*)net->bssid)[0]);
 	write_nic_word(dev,BSSID+4,((u16*)net->bssid)[2]);
-	//for(i=0;i<ETH_ALEN;i++)
-	//	write_nic_byte(dev,BSSID+i,net->bssid[i]);
 
 	rtl8180_update_msr(dev);
 		
-//	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
 	write_nic_word(dev, AtimWnd, 2);
 	write_nic_word(dev, AtimtrItv, 100);	
 	write_nic_word(dev, BEACON_INTERVAL, net->beacon_interval);
@@ -1484,7 +1334,6 @@
 	write_nic_byte(dev, BQREQ, read_nic_byte(dev, BQREQ) | (1<<7));
 	
 	i=0;
-	//while(!read_nic_byte(dev,BQREQ & (1<<7)))
 	while( (read_nic_byte(dev, BQREQ) & (1<<7)) == 0 )
 	{
 		msleep_interruptible_rtl(HZ/2);
@@ -1514,30 +1363,20 @@
 		priv->stats.txnpokint++;
 	else
 		priv->stats.txnperr++;
-	//kfree(tx_urb->transfer_buffer);
-	//usb_free_urb(tx_urb);
 	atomic_dec(&priv->tx_np_pending);
-//	printk(KERN_INFO "nptx urb %d\n",priv->tx_np_pending);
-	//rtl8180_try_wake_queue(dev,NORM_PRIORITY);
 }
 
 
-// This function do the real dirty work: it sends a TX command 
-// descriptor plus data URB 
-// 
  
 short rtl8180_tx(struct net_device *dev, u8* txbuf, int len, priority_t priority,
 		 short morefrag, short rate)
 {
-	//u32 *tx;
 	u8 *tx; 
 	u8 *pdata;
 	u8 seg = ((u32)txbuf % 4);
 	u32 *pdata32;
 	u32 *ptxbuf32;
 	int i;
-//	u16 duration;
-//	short ext;
 	int pend;
 	int status;
 	struct urb *tx_urb;
@@ -1547,10 +1386,8 @@
 	u16 duration;
         
 	struct r8180_priv *priv = ieee80211_priv(dev);
-//	int rate = ieeerate2rtlrate(priv->ieee80211->rate);
         
        	pend = atomic_read((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending);
-	// we are locked here so the two atomic_read and inc are executed without interleaves */
 	if( pend > MAX_TX_URB){
 		if(priority == NORM_PRIORITY)
 			priv->stats.txnpdrop++;
@@ -1561,14 +1398,12 @@
 	}
 		
 #if 0	
-	//tx = kmalloc((len + 4*3), GFP_ATOMIC);
 	urb_len = len + 4*3;
 	if((0 == urb_len%64)||(0 == urb_len%512)) {
 	  urb_len += 1;	  
 	}
 	tx = kmalloc(urb_len, GFP_ATOMIC);
 	if(!tx) return -ENOMEM;
-	//printk(KERN_WARNING "urb_len = %d\n", urb_len);	
 	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
 	
 	if(!tx_urb){
@@ -1577,7 +1412,6 @@
 		return -ENOMEM;
 	}
 #else
-	//urb_len = TX_URB_SIZE;
 	urb_len = len + 4*3;
 	if((0 == urb_len%64)||(0 == urb_len%512)) {
 	  urb_len += 1;	  
@@ -1593,49 +1427,31 @@
 	tx[0] = 0;
 	tx[0] |= len & 0xfff;
 	tx[0] |= (1<<15);
-//	printk(KERN_INFO "preamble mode %d,rate %d!\n",priv->plcp_preamble_mode,rate);
 	if (priv->ieee80211->current_network.capability&WLAN_CAPABILITY_SHORT_PREAMBLE)
-		if (priv->plcp_preamble_mode==1 && rate!=0) {	//  short mode now, not long!
+		if (priv->plcp_preamble_mode==1 && rate!=0) {	
 			tx[0] |= (1<<16);	
-//			printk(KERN_INFO "use short preamble!\n");
-		}			// enable short preamble mode.
+		}			
 
-//	if(priv->shortpre)
-//		tx[0] |= (1<<16);
-//	printk(KERN_INFO "len %d,rts %d, priority %d!\n",len,priv->rts,priority);
 	if ( (len>priv->rts) && priv->rts && priority==LOW_PRIORITY){
-			tx[0] |= (1<<23);	//enalbe RTS function
-//			tx[0] |= (0<<19);	//use 1M bps send RTS packet
-			AckCtsTime = ComputeTxTime(14, 10,0, 0);	// AckCTSLng = 14 use 1M bps send
+			tx[0] |= (1<<23);	
+			AckCtsTime = ComputeTxTime(14, 10,0, 0);	
 			FrameTime = ComputeTxTime(len + 4, rtl8180_rate2rate(rate), 0, tx[0]&(1<<16));
-			// RTS/CTS time is calculate as follow
-			duration = FrameTime + 3*10 + 2*AckCtsTime;	//10us is the SifsTime;	
-			tx[1] |= duration; 	//Need to edit here!  ----hikaru
+			duration = FrameTime + 3*10 + 2*AckCtsTime;	
+			tx[1] |= duration; 	
 			printk(KERN_INFO "duration %d!\n",duration);
 	}
 	else 
 		tx[1]=0;
-	//if(len > priv->rts_threshold){
-//		tx[0] |= (1<<23); //ENABLE RTS
-//		tx[0] |= (1<<18); //ENABLE CTS
-	//}
 	if(morefrag) tx[0] |= (1<<17);
-	tx[0] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 19); // RTS RATE - should be basic rate */
+	tx[0] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 19); 
 	tx[0] |= (rate << 24);
-//	tx[1] = 0;
 	
-//	duration = rtl8180_len2duration(len,
-//		rate,&ext);	
-//	tx[1] |= (duration & 0x7fff) <<16;
-//	if(ext) tx[1] |= (1<<31);
 
 	
-//	tx[2] = 0x303020;
-	tx[2] = 3;  // CW min
-	tx[2] |= (7<<4); //CW max
-	tx[2] |= (11<<8);//(priv->retry_data<<8); //retry lim
+	tx[2] = 3;  
+	tx[2] |= (7<<4); 
+	tx[2] |= (11<<8);
 	
-//	printk("%x\n%x\n",tx[0],tx[1]);
 
 	#ifdef DUMP_TX
 	int i;
@@ -1653,7 +1469,6 @@
 
 	pdata32 = (u32 *)pdata;
 	ptxbuf32 = (u32 *)txbuf;
-	//memcpy(tx+12,txbuf,len);
 #if 0
 	memcpy(pdata32, (u32 *)txbuf, (len+4)/4);
 #else
@@ -1661,31 +1476,26 @@
 		*pdata32++ = *ptxbuf32++;
 	}
 #endif
-	//memcpy(pdata, txbuf, len);
 	
-	//tx[0] = 0;
-	//tx[1] = 0;
 	tx[2] = 0;
 	tx[3] = 0;
 	
-	//tx[0] |= len & 0xfff;
 	tx[0] = len & 0xff;
 	tx[1] = (len & 0x0f00) >> 8;
 	tx[1] |= (1<<7);
 
 	if (priv->ieee80211->current_network.capability&WLAN_CAPABILITY_SHORT_PREAMBLE)
-		if (priv->plcp_preamble_mode==1 && rate!=0) {	//  short mode now, not long!
+		if (priv->plcp_preamble_mode==1 && rate!=0) {	
 			tx[2] |= 1;	
 
 		}			
 
 	if ( (len>priv->rts) && priv->rts && priority==LOW_PRIORITY){
-			tx[2] |= (1<<7);	//enalbe RTS function
-			AckCtsTime = ComputeTxTime(14, 10,0, 0);	// AckCTSLng = 14 use 1M bps send
+			tx[2] |= (1<<7);	
+			AckCtsTime = ComputeTxTime(14, 10,0, 0);	
 			FrameTime = ComputeTxTime(len + 4, rtl8180_rate2rate(rate), 0, tx[2]&1);
-			// RTS/CTS time is calculate as follow
-			duration = FrameTime + 3*10 + 2*AckCtsTime;	//10us is the SifsTime;	
-			tx[4] |= duration & 0xff; 	//Need to edit here!  ----hikaru
+			duration = FrameTime + 3*10 + 2*AckCtsTime;	
+			tx[4] |= duration & 0xff; 	
 			tx[5] |= (duration & 0xff00) >> 8; 
 			printk(KERN_INFO "duration %d!\n",duration);
 	}
@@ -1695,26 +1505,31 @@
 	}
 	
 	if(morefrag) tx[2] |= (1<<1);
-	tx[2] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 3); // RTS RATE - should be basic rate */
+	tx[2] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 3); 
 	tx[3] |= rate;
 
-	tx[8] = 3;  // CW min
-	tx[8] |= (7<<4); //CW max
-	tx[9] |= 11;//(priv->retry_data<<8); //retry lim
+	tx[8] = 3;  
+	tx[8] |= (7<<4); 
+	tx[9] |= 11;
         
         	
 
-	// FIXME check what EP is for low/norm PRI */
 	usb_fill_bulk_urb(tx_urb,priv->udev,
                           usb_sndbulkpipe(priv->udev,(priority == LOW_PRIORITY)?2:3), tx,
 			  urb_len, ((priority == LOW_PRIORITY)?rtl8187_lptx_isr:rtl8187_nptx_isr), dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
+#else
+	status = usb_submit_urb(tx_urb);
+#endif
+
        	if (!status){
 		atomic_inc((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending);
 		priv->stats.txok++;
 		return 0;
 	}else{
-		priv->stats.txerr++; //tony 20060601
+		priv->stats.txerr++; 
 		printk("Error TX URB %d, error %d",
 				atomic_read((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending),
 				status);
@@ -1725,7 +1540,6 @@
  
 
 void rtl8180_irq_rx_tasklet(struct r8180_priv * priv);
-//void rtl8180_irq_rx_tasklet(struct work_struct * work);
 
 short rtl8187_usb_initendpoints(struct net_device *dev)
 {
@@ -1735,7 +1549,11 @@
 	priv->rx_urb = (struct urb**) kmalloc (sizeof(struct urb*) * MAX_RX_URB, GFP_KERNEL);
 	
 	for(i=0;i<MAX_RX_URB;i++){
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 
 		priv->rx_urb[i] = usb_alloc_urb(0,GFP_KERNEL);
+#else
+		priv->rx_urb[i] = usb_alloc_urb(0);
+#endif
 		if(!priv->rx_urb[i]) 
 			goto destroy;
 		
@@ -1750,14 +1568,17 @@
 		struct tx_urb_context *ptrcontext = &priv->tx_context[j];
 		u8 seg_size;
 		
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 		
 		ptrcontext->tx_urb = usb_alloc_urb(0,GFP_KERNEL);
+#else
+		ptrcontext->tx_urb = usb_alloc_urb(0);
+#endif
 		if(!ptrcontext->tx_urb) 
 			goto destroy_tx;
 		
 		ptrcontext->transfer_buffer = kmalloc(TX_URB_SIZE, GFP_KERNEL);
 		if(!ptrcontext->transfer_buffer) 
 			goto destroy1_tx;
-		// set tx_urb 4 byte align
 		seg_size = (u32)ptrcontext->transfer_buffer % 4;
 		ptrcontext->ptalign_buf = ptrcontext->transfer_buffer + ((seg_size > 0)? (4 - seg_size):0);
 	}
@@ -1804,7 +1625,6 @@
 		priv->rx_urb = NULL;
 		
 	}
-	//added by david. 2007.1.30
 	for(j=0; j < MAX_TX_URB; j++){
 		struct tx_urb_context *ptrcontext = &priv->tx_context[j];
 		
@@ -1816,7 +1636,11 @@
 	}
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(rtl8187_usb_deleteendpoints);
+#else
+EXPORT_SYMBOL_NOVERS(rtl8187_usb_deleteendpoints);
+#endif
 
 void rtl8187_set_rate(struct net_device *dev)
 {
@@ -1824,20 +1648,11 @@
 	u16 word;
 	int basic_rate,min_rr_rate,max_rr_rate;
 	
-//	struct r8180_priv *priv = ieee80211_priv(dev);
 	
-	//if (ieee80211_is_54g(priv->ieee80211->current_network) && 
-//		priv->ieee80211->state == IEEE80211_LINKED){
 	basic_rate = ieeerate2rtlrate(240);
 	min_rr_rate = ieeerate2rtlrate(60);
 	max_rr_rate = ieeerate2rtlrate(240);
 	
-//	
-//	}else{
-//		basic_rate = ieeerate2rtlrate(20);
-//		min_rr_rate = ieeerate2rtlrate(10);
-//		max_rr_rate = ieeerate2rtlrate(110);
-//	}
 
 	write_nic_byte(dev, RESP_RATE,
 			max_rr_rate<<MAX_RESP_RATE_SHIFT| min_rr_rate<<MIN_RESP_RATE_SHIFT);
@@ -1850,18 +1665,14 @@
 		word |= (1<<i);
 
 	write_nic_word(dev, BRSR, word);
-	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
 }
 
 
 void rtl8187_link_change(struct net_device *dev)
 {
-//	int i;
 	
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//write_nic_word(dev, BintrItv, net->beacon_interval);
 	rtl8187_net_update(dev);
-	//update timing params*/
 	rtl8180_set_chan(dev, priv->chan);
 	rtl8187_set_rxconf(dev);
 }
@@ -1877,7 +1688,6 @@
 #else
 void rtl8180_hw_wakeup(struct net_device *dev)
 {
-	//unsigned long flags;
 	
 	struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
@@ -1886,61 +1696,42 @@
 		printk(KERN_INFO "last time sleep unfinished!\n");
 		return;
 	}
-//	down(&priv->power_sem);
-//	if (priv->ps_sleep_finish) {
-	//	write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)&~CONFIG4_PWRMGT);
-//	spin_lock_irqsave(&priv->ps_lock,flags);
-	//DMESG("Waken up!");
-//	write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)&~CONFIG4_PWRMGT);
 	
 		if(priv->rf_wakeup)
 			priv->rf_wakeup(dev);
 		priv->ps_sleep_finish=0;
-//	}
-//	ieee80211_wake_queue(priv->ieee80211);
-//	up(&priv->power_sem);
-////	printk(KERN_INFO "wakeup queue!\n");
-//	mdelay(HW_WAKE_DELAY);
-//	spin_unlock_irqrestore(&priv->ps_lock,flags);
 	printk(KERN_INFO "leave wakeup!\n");
 }
 
-//void rtl8180_rq_tx_ack_wq(struct net_device *dev){
-//	struct r8180_priv *priv = ieee80211_priv(dev);
-//	schedule_work(&priv->ps_request_tx_ack_wq);
-//}
 
 
 void timer_hw_wakeup_wq(unsigned long data)
 {
 	struct r8180_priv *priv = ieee80211_priv((struct net_device *)data);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 	schedule_work(&priv->rtl8180_hw_wakeup_wq);
+#else
+	schedule_task(&priv->rtl8180_hw_wakeup_wq);
+#endif
 	printk(KERN_INFO "timer wakup schedule!\n");
 }
 
 #if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 void rtl8180_rq_tx_ack(struct work_struct * work)
 {
-	//struct r8180_priv *priv = (struct ieee80211_device*)
-	//	container_of(work, struct ieee80211_device, ps_request_tx_ack_wq)->priv;
 	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, ps_request_tx_ack_wq);
 	struct r8180_priv *priv = (struct r8180_priv *)ieee->priv;
-//	struct net_device *dev = priv->dev;
 #else
 void rtl8180_rq_tx_ack(struct net_device *dev){
 		
 	struct r8180_priv *priv = ieee80211_priv(dev);
 #endif	
-//	write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)|CONFIG4_PWRMGT);
 	priv->ack_tx_to_ieee = 1;
-//	printk(KERN_INFO "rtl8180_rq_tx_ack!\n");
 }
 
 #if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 void rtl8180_hw_sleep(struct work_struct * work)
 {
-        //struct r8180_priv *priv = (struct ieee80211_device*)
-        //      container_of(work, struct ieee80211_device, hw_sleep_wq)->priv;
 	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, hw_sleep_wq);
 	struct r8180_priv *priv = (struct r8180_priv *)ieee->priv;
         struct net_device *dev = priv->dev;
@@ -1950,82 +1741,43 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
 	u32 rb,tl;
-	//unsigned long flags;
 	u32  timeout;
 	if (priv->ps_sleep_finish) {
 		printk(KERN_INFO "last time wake unfinished!\n");
 		return;
 	}
-//	down(&priv->power_sem);
-//	if (atomic_read(&priv->tx_lp_pending)) {
-//		printk(KERN_WARNING "lp pending no sleep!\n");
-//		return;
-//	}
-//	else {
-//		printk(KERN_WARNING "stop queue when sleep!\n");
-//		ieee80211_stop_queue(priv->ieee80211);
-//	}
-//	if (!priv->ps_sleep_finish) {
 	rb = read_nic_dword(dev, TSFTR);
-////	printk(KERN_INFO "enter rtl8180_hw_sleep!\n");
-//	spin_lock_irqsave(&priv->ps_lock,flags);
 	
-	// Writing HW register with 0 equals to disable
-	// the timer, that is not really what we want
-	//
 	tl = priv->ieee80211->ps_tl;
-//	printk(KERN_INFO "tl is %lu!\n",tl);
 	tl -= HW_WAKE_DELAY*1000;
 	 
 	if(tl == 0) tl = 1;
 	
-	// FIXME HACK FIXME HACK */
-//	force_pci_posting(dev);
-//	mdelay(1);
 	
-//	rb = read_nic_dword(dev, TSFTR);
 #ifdef TONY_PS
 	printk(KERN_INFO "tl %lu, rb %lu!\n",tl,rb);
 #endif
 	
-	//DMESG("sleep until %x, hw @:%x",tl,rb);
 	
-	// If the interval in witch we are requested to sleep is too
-	//  short then give up and remain awake
-	// 
-//	printk(KERN_INFO "rb %lu, tl %lu!\n",rb,tl);
 	if(((rb<tl)&& (tl-rb) < MIN_SLEEP_TIME)
 		||((rb>tl)&& (rb-tl) < MIN_SLEEP_TIME))
 		return;
 		
-//	write_nic_dword(dev, TimerInt, tl);
-	//DMESG("sleep..");
-//	rb = read_nic_dword(dev, TSFTR);
-	
-	// if we suspect the TimerInt is gone beyond tl 
-	//  while setting it, then give up
-	// 
+	
 	if(((tl > rb) && ((tl-rb) > MAX_SLEEP_TIME))||
 		((tl < rb) && ((rb-tl) > MAX_SLEEP_TIME)))
 		return;
 
 	if (rb>tl)
-		timeout = (rb-tl)>>10;//divide by 1024 
+		timeout = (rb-tl)>>10;
 	else
 		timeout = (tl-rb)>>10; 
 
-//	if(priv->rf_sleep)
-//		priv->rf_sleep(dev);
-	priv->ps_timer.expires = jiffies+timeout;
-////	printk(KERN_INFO "jiffies %lu, timeout %lu!\n",jiffies,timeout);
-	add_timer(&priv->ps_timer);
+	mod_timer(&priv->ps_timer, jiffies+timeout);
 	
 	if(priv->rf_sleep)
 		priv->rf_sleep(dev);
 	priv->ps_sleep_finish=1;
-//	}
-//	up(&priv->power_sem);
-//	spin_unlock_irqrestore(&priv->ps_lock,flags);	
 	printk(KERN_INFO "leave sleep!\n");
 }
 
@@ -2039,25 +1791,13 @@
 #endif
 
 	used = atomic_read(&priv->tx_np_pending);
-////	printk(KERN_INFO "np used %d!\n",used);
 	if (used) return 0; 
 	used = atomic_read(&priv->tx_lp_pending);
-////	printk(KERN_INFO "lp used %d!\n",used);
 	if (used) return 0;
 	
 	return 1;
 }
 
-//by amy for rate adaptive
-//
-//	Description: 
-//		Core logic to adjust Tx data rate in STA mode according to 
-//		OFDM retry count ratio.
-//
-//	Note:
-//		RTL8187   : pHalData->CurrRetryCnt = TallyCnt
-//		RTL8187B : pHalData->CurrRetryCnt = PktRetryCnt in TxClosedCommand 
-//
 void sta_rateadaptive8187(	struct net_device *dev)
 {
         struct r8180_priv *priv = ieee80211_priv(dev);
@@ -2069,12 +1809,9 @@
 	long            CurrSignalStrength;
 
 
-	//CurrRetryCnt = pHalData->CurrRetryCnt - pHalData->LastRetryCnt;
-	//CurrTxokCnt	= Adapter->TxStats.NumTxOkTotal - pHalData->LastTxokCnt;
-	//CurrRxokCnt	= Adapter->RxStats.NumRxOkTotal - pHalData->LastRxokCnt;
 	priv->CurrRetryCnt = read_nic_word(dev, Tally_Cnt);
 
-	CurrRetryCnt = priv->CurrRetryCnt - priv->LastRetryCnt ;//lzm ??? priv->CurrRetryCnt from ???
+	CurrRetryCnt = priv->CurrRetryCnt - priv->LastRetryCnt ;
         CurrTxokCnt  = (priv->stats.txbeaconokint + priv->stats.txnpokint +
                                         priv->stats.txhpokint + priv->stats.txlpokint )- priv->LastTxokCnt;
         CurrRxokCnt  =  priv->stats.rxok - priv->LastRxokCnt;
@@ -2107,61 +1844,47 @@
 	printk("(4) CurrRetryRate = %d \n", CurrRetryRate);     
 	printk("(5) SignalStrength = %d \n",priv->RecvSignalPower);
 #endif
-	//priv->LastRetryCnt = priv->CurrRetryCnt;
-	//priv->LastTxokCnt = dev->TxStats.NumTxOkTotal;
-	//priv->LastRxokCnt = dev->RxStats.NumRxOkTotal;
 
         priv->LastRetryCnt = priv->CurrRetryCnt ;
         priv->LastTxokCnt  = (priv->stats.txbeaconokint + priv->stats.txnpokint +
                                         priv->stats.txhpokint + priv->stats.txlpokint );
         priv->LastRxokCnt = priv->stats.rxok;
-        priv->CurrRetryCnt = 0;// ???
+        priv->CurrRetryCnt = 0;
 		
-//	printk("(2) priv->LastTxokCnt = %d  \n",  priv->LastTxokCnt);      
-//	printk("(3) priv->LastRxokCnt = %d \n", priv->LastRxokCnt);
-// IncludedInSupportedRates : Return BOOLEAN: TxRate is included in SupportedRates or not.
 #if 1	
-	//if ((&ieee->current_network)->stats.signalstrength > -50 && IncludedInSupportedRates(Adapter, 108))
-	if ((&ieee->current_network)->stats.signalstrength > 85 )//&& IncludedInSupportedRates(Adapter, 108))
+	if ((&ieee->current_network)->stats.signalstrength > 85 )
 	{
-//		printk("RA: return to 54Mbps first \n");
 		priv->CurrentOperaRate = 108;
 	}
 #endif	
 	
-	//2No Tx packets, return to init_rate or not?
 	if ( (CurrTxokCnt==0)|| (CurrRetryRate==0))
 	{
-		//After 3 sec, try up
 		priv->TryupingCountNoData++;
 #if 1
 		if (priv->TryupingCountNoData>10)
 		{
 			priv->TryupingCountNoData=0;
-		 	if ( priv->CurrentOperaRate == 96 ) {//&& IncludedInSupportedRates(Adapter, 108) ){
+		 	if ( priv->CurrentOperaRate == 96 ) {
 				priv->CurrentOperaRate = 108;
-		 	}else if (priv->CurrentOperaRate == 72   ) {//&& IncludedInSupportedRates(Adapter, 96) ){
+		 	}else if (priv->CurrentOperaRate == 72   ) {
 				priv->CurrentOperaRate = 96;
-		 	}else if (priv->CurrentOperaRate == 48   ) {//&& IncludedInSupportedRates(Adapter, 72) ){
+		 	}else if (priv->CurrentOperaRate == 48   ) {
 				priv->CurrentOperaRate = 72;
-			}else if (priv->CurrentOperaRate == 36   ) {//&& IncludedInSupportedRates(Adapter, 48) ){
+			}else if (priv->CurrentOperaRate == 36   ) {
 				priv->CurrentOperaRate = 48;
-			}else if (priv->CurrentOperaRate == 22   ) {//&& IncludedInSupportedRates(Adapter, 36) ){
+			}else if (priv->CurrentOperaRate == 22   ) {
 				priv->CurrentOperaRate = 36;
-			}else if (priv->CurrentOperaRate == 11   ) {//&& IncludedInSupportedRates(Adapter, 22) ){
+			}else if (priv->CurrentOperaRate == 11   ) {
 				priv->CurrentOperaRate = 22;
-			}else if (priv->CurrentOperaRate == 4   ) {//&& IncludedInSupportedRates(Adapter, 11) ){
+			}else if (priv->CurrentOperaRate == 4   ) {
 				priv->CurrentOperaRate = 11;
-			}else if (priv->CurrentOperaRate == 2   ) {//&& IncludedInSupportedRates(Adapter, 4) ){
+			}else if (priv->CurrentOperaRate == 2   ) {
 				priv->CurrentOperaRate = 4;
 			}
 			
 		}
 #endif
-		//2004.12.23 skip record for 0
-		//pHalData->LastRetryRate = CurrRetryRate;
-		//printk("(6) pMgntInfo->CurrentOperaRate =%d\n",priv->CurrentOperaRate);
-	//	return;
 		goto end;
 	}
 	else
@@ -2176,17 +1899,14 @@
 		priv->TryupingCount=0;
 		if ( (CurrRetryRate>15)&&(priv->CurrRetryRate < CurrRetryRate) )
 		{
-			//not necessary up rate, fall back rate
 			priv->CurrentOperaRate = priv->CurrTxRate;
 			priv->LastRetryRate = CurrRetryRate;
-			//printk( "(7) pMgntInfo->CurrentOperaRate =%d\n",priv->CurrentOperaRate );
-			//return;
 			goto end;
 		}
 	}
 
 	if(CurrTxokCnt< 1 && CurrRetryRate > 100)
-	{	// For ping case. Don't drop too deep for better feeling. 2006.07.02, by rcjko.
+	{	
 		
 		switch(priv->CurrentOperaRate)
 		{
@@ -2215,245 +1935,189 @@
 			break;	
 
 		default:
-			// Force data rate to 11Mbps.
 			priv->CurrentOperaRate = 22;
 			break;
 		}
 	}
 	else if ( priv->CurrentOperaRate == 108 )
 	{
-		//2For 54Mbps
-		if ( (CurrRetryRate>40)&&(priv->LastRetryRate>40) ) //&& IncludedInSupportedRates(Adapter, 96) ) 
+		if ( (CurrRetryRate>40)&&(priv->LastRetryRate>40) ) 
 		{
-		//	printk("RA: down to rate from 54 to 48Mbps\n");
 			priv->CurrentOperaRate = 96;
 		}
 	}
 	else if ( priv->CurrentOperaRate == 96 )
 	{
-		//2For 48Mbps
-		if ( ((CurrRetryRate>40) && (priv->LastRetryRate>40)) ) //&& IncludedInSupportedRates(Adapter, 72) )//&& (Adapter->RxStats.SignalStrength < -61))
+		if ( ((CurrRetryRate>40) && (priv->LastRetryRate>40)) ) 
 		{
-		//	printk("RA: down to rate from 48 to 36Mbps\n");
 			priv->CurrentOperaRate = 72;
 		}
-		else if ( (CurrRetryRate<15) && (priv->LastRetryRate<15) ) //&& IncludedInSupportedRates(Adapter, 108) ) //TO DO: need to consider (RSSI)
+		else if ( (CurrRetryRate<15) && (priv->LastRetryRate<15) ) 
 		{
-		//	printk("RA: up to rate from 48 to 54Mbps\n");
 			priv->CurrentOperaRate = 108;
 		}
-		//2For 48 End
 	}
 	else if ( priv->CurrentOperaRate == 72 )
 	{
-		//2For 36Mbps
-		if ( (CurrRetryRate>99) && (priv->LastRetryRate>99) ) //&& IncludedInSupportedRates(Adapter, 48)) 
+		if ( (CurrRetryRate>99) && (priv->LastRetryRate>99) ) 
 		{
-			//down to rate 24Mbps
-		//	printk("RA: down to rate from 36 to 24Mbps\n");
 			priv->CurrentOperaRate = 48;
 		}
-		else if ( (CurrRetryRate<15) ) //&& IncludedInSupportedRates(Adapter, 96) )//&& (device->LastRetryRate<15) ) //TO DO: need to consider (RSSI)
+		else if ( (CurrRetryRate<15) ) 
 		{
-			//count down 10 times
 			priv->TryupingCount++;
-			if ( (priv->bTryuping==false)&& (priv->TryupingCount>20) )//check after 6 sec again
+			if ( (priv->bTryuping==false)&& (priv->TryupingCount>20) )
 			{
-		//		printk("RA: Trying up to rate from 36 to 48Mbps\n");
 				priv->TryupingCount = 0;
 				priv->bTryuping = true;
-				priv->CurrTxRate =  priv->CurrentOperaRate; //72
+				priv->CurrTxRate =  priv->CurrentOperaRate; 
 				priv->CurrRetryRate = CurrRetryRate;
 				
 				priv->CurrentOperaRate = 96;
 			}
 		}
-		//2For 36 End
 	}
 	else if ( priv->CurrentOperaRate == 48 )
 	{
-		//2For 24Mbps
-		if ( ((CurrRetryRate>99) && (priv->LastRetryRate>99) ) //&& IncludedInSupportedRates(Adapter, 36))
+		if ( ((CurrRetryRate>99) && (priv->LastRetryRate>99) ) 
 			)
 		{
-			//down to rate 18Mbps
-		//	printk("RA: down to rate from 24 to 18Mbps\n");
 			priv->CurrentOperaRate = 36;
 
-			//Update init_gain= -78dB for 18Mpbs
 			
 			if (priv->InitialGain != 4 )
 			{
 				priv->InitialGain = 4;
-		//		printk("RA: update init_gain to index %d for 18M\n",priv->InitialGain);
-				UpdateInitialGain(dev); // 2005.01.06, by rcnjko. 
+				UpdateInitialGain(dev); 
 			}
 		}
-		else if ( (CurrRetryRate<15) && (priv->LastRetryRate<15) ) //&& IncludedInSupportedRates(Adapter, 72)) //TO DO: need to consider (RSSI)
+		else if ( (CurrRetryRate<15) && (priv->LastRetryRate<15) ) 
 		{
-		//	printk("RA: up to rate from 24 to 36Mbps\n");
 			priv->CurrentOperaRate = 72;
 		}
-		//2For 24 End
 		
 	}
 	else if ( priv->CurrentOperaRate == 36 )
 	{
-		//2For 18Mbps
-		if ( ((CurrRetryRate>99) && (priv->LastRetryRate>99)) ) //&& IncludedInSupportedRates(Adapter, 22))//&& (Adapter->RxStats.SignalStrength < -65))
+		if ( ((CurrRetryRate>99) && (priv->LastRetryRate>99)) ) 
 		{
-		//	printk("RA: down to rate from 18 to 11Mbps\n");
 			priv->CurrentOperaRate = 22;
 
-			//Update init_gain= -78dB for 11Mpbs
 			
 			if (priv->InitialGain != 4 )
 			{
 				priv->InitialGain = 4;
-		//		printk("RA: update init_gain to index %d for 11M\n",priv->InitialGain);
-				UpdateInitialGain(dev); // 2005.01.06, by rcnjko.  
+				UpdateInitialGain(dev); 
 			}
 		}
-		else if ( (CurrRetryRate<15) && (priv->LastRetryRate<15) ) //&& IncludedInSupportedRates(Adapter, 48)) //TO DO: need to consider (RSSI)
+		else if ( (CurrRetryRate<15) && (priv->LastRetryRate<15) ) 
 		{
-		//	printk("RA: up to rate from 18 to 24Mbps\n");
 			priv->CurrentOperaRate = 48;
 			
 			if (priv->InitialGain != 5 )
 			{
 				priv->InitialGain = 5;
-		//		printk("RA: update init_gain to index %d for 24M\n",priv->InitialGain);
-				UpdateInitialGain(dev); // 2005.01.06, by rcnjko. 
+				UpdateInitialGain(dev); 
 			}		
 		}
-		//2For 18 End		
 	}
 	else if ( priv->CurrentOperaRate == 22 )
 	{
-		//2For 11Mbps
-		if (CurrRetryRate>299 ) //&& IncludedInSupportedRates(Adapter, 11))
+		if (CurrRetryRate>299 ) 
 		{
 			priv->TryDownCountLowData++;
 			if (priv->TryDownCountLowData>3)
 			{
 				priv->TryDownCountLowData = 0;
-				//down to rate 5.5Mbps
-		//		printk("RA: down to rate from 11 to 5.5Mbps\n");
 				priv->CurrentOperaRate = 11;
 
-				//Update init_gain= -82dB for 5.5Mpbs
 				
 				if (priv->InitialGain != 3 )
 				{
 					priv->InitialGain = 3;
-		//			printk("RA: update init_gain to index %d for 5.5M\n",priv->InitialGain);
-					UpdateInitialGain(dev); // 2005.01.06, by rcnjko.
+					UpdateInitialGain(dev); 
 				}
 			}
 		}
-		else if ( (CurrRetryRate<45) ) //&& IncludedInSupportedRates(Adapter, 36) )//&& (device->LastRetryRate<15) ) //TO DO: need to consider (RSSI)
+		else if ( (CurrRetryRate<45) ) 
 		{
 			priv->TryDownCountLowData = 0;
-			//count down 10 times
 			priv->TryupingCount++;
-			if ( (priv->bTryuping==false)&& (priv->TryupingCount>20) )//check after 6 sec again
+			if ( (priv->bTryuping==false)&& (priv->TryupingCount>20) )
 			{
-		//		printk("RA: Trying up to rate from 11 to 18Mbps\n");
 				priv->TryupingCount = 0;
 				priv->bTryuping = true;
-				priv->CurrTxRate =  priv->CurrentOperaRate; //72
+				priv->CurrTxRate =  priv->CurrentOperaRate; 
 				priv->CurrRetryRate = CurrRetryRate;
 				
 				priv->CurrentOperaRate = 36;
 			}
 		}
-		//2For 11 End
 	}
 	else if ( priv->CurrentOperaRate == 11 )
 	{
-		//2For 5.5Mbps
-		if (CurrRetryRate>199 ) //&& IncludedInSupportedRates(Adapter, 4) ) 
+		if (CurrRetryRate>199 ) 
 		{
 			priv->TryDownCountLowData++;
 			if (priv->TryDownCountLowData>3)
 			{
 				priv->TryDownCountLowData = 0;
-				//down to rate 2Mbps
-		//		printk("RA: down to rate from 5.5 to 2Mbps\n");
 				priv->CurrentOperaRate = 4;
 
-				//Update init_gain= -82dB for 5.5Mpbs
 				
 				if (priv->InitialGain != 3 )
 				{
 					priv->InitialGain = 3;
-		//			printk("RA: update init_gain to index %d for 2M \n",priv->InitialGain);
-					UpdateInitialGain(dev); // 2005.01.06, by rcnjko.
+					UpdateInitialGain(dev); 
 				}
 			}
 		}
-		else if ( (CurrRetryRate<30) && (priv->LastRetryRate<30) ) //&& IncludedInSupportedRates(Adapter, 22) )
+		else if ( (CurrRetryRate<30) && (priv->LastRetryRate<30) ) 
 		{
 			priv->TryDownCountLowData = 0;
-		//	printk("RA: up to rate from 5.5 to 11Mbps\n");
 			priv->CurrentOperaRate = 22;
 			
 			if (priv->InitialGain  != 4 )
 			{
 				priv->InitialGain  = 4;
-		//		printk("RA: update init_gain to index %d for 11M\n",priv->InitialGain);
-				UpdateInitialGain(dev); // 2005.01.06, by rcnjko.
+				UpdateInitialGain(dev); 
 			}		
 		}
-		//2For 5.5 End
 	}
 	else if ( priv->CurrentOperaRate == 4 )
 	{
-		//2For 2 Mbps
-		if((CurrRetryRate>99) && (priv->LastRetryRate>99) ) //&& IncludedInSupportedRates(Adapter, 2) )
+		if((CurrRetryRate>99) && (priv->LastRetryRate>99) ) 
 		{
 			priv->TryDownCountLowData++;
 			if (priv->TryDownCountLowData>3)
 			{
-				//down to rate 1Mbps
-		//		printk("RA: down to rate from 2 to 1Mbps\n");
 				priv->CurrentOperaRate = 2;
 
-				//Update init_gain= -82dB for 5.5Mpbs
 				
 				if (priv->InitialGain != 3 )
 				{
 					priv->InitialGain = 3;
-		//			printk("RA: update init_gain to index %d for 1M \n",priv->InitialGain);
-					UpdateInitialGain(dev); // 2005.01.06, by rcnjko.
+					UpdateInitialGain(dev); 
 				}
 			}
 		}
-		else if ( (CurrRetryRate<50) && (priv->LastRetryRate<50) ) //&& IncludedInSupportedRates(Adapter, 11) )
+		else if ( (CurrRetryRate<50) && (priv->LastRetryRate<50) ) 
 		{
 			priv->TryDownCountLowData=0;
-		//	printk("RA: up to rate from 2 to 5.5 Mbps\n");
 			priv->CurrentOperaRate = 11;
 		}
-		//2For 2 End
 	}
 	else if ( priv->CurrentOperaRate == 2 )
 	{
-		//2For 1 Mbps
-		if ( (CurrRetryRate<50) && (priv->LastRetryRate<50) ) //&& IncludedInSupportedRates(Adapter, 4))
+		if ( (CurrRetryRate<50) && (priv->LastRetryRate<50) ) 
 		{
-		//	printk("RA: up to rate from 1 to 2 Mbps\n");
 			priv->CurrentOperaRate = 4;
 		}
-		//2For 1 End
 	}
 
 end:
-        //Record the related info
         priv->LastRetryRate = CurrRetryRate;
-        //priv->LastTxThroughput = TxThroughput;
         priv->ieee80211->rate = priv->CurrentOperaRate * 5;
-//	printk("(e) pMgntInfo->CurrentOperaRate =%d\n",priv->CurrentOperaRate );
 }
 
 
@@ -2470,11 +2134,7 @@
 	{
 
 #endif
-		//      struct r8180_priv *priv = ieee80211_priv(dev);
-		//  	u16 isr_content;
-	//	DMESG("---->rtl8180_rate_adapter");
 		sta_rateadaptive8187(dev);
-	//	DMESG("<----rtl8180_rate_adapter");
 }
 #endif
 
@@ -2482,51 +2142,36 @@
 void timer_rate_adaptive(unsigned long data)
 {
     struct r8180_priv* priv = ieee80211_priv((struct net_device *)data);
-    //printk("rateadapter_timer timer_rate_adaptive()\n");
         if(!priv->up)
         {
-                //DMESG("<----timer_rate_adaptive():driver is not up!\n");
                 return;
         }
         if(     (priv->ieee80211->mode != IEEE_B) &&
                 (priv->ieee80211->iw_mode != IW_MODE_MASTER)
                 && (priv->ieee80211->state == IEEE80211_LINKED))
         {
-//          DMESG("timer_rate_adaptive():schedule rate_adapter_wq\n");
-        queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->rate_adapter_wq);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)	
+		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->rate_adapter_wq, 0);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
+		queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->rate_adapter_wq);
+#else
+		schedule_task(&priv->ieee80211->rate_adapter_wq);
+#endif        
         }
-        //priv->rateadapter_timer.expires = jiffies + MSECS(DEFAULT_RATE_ADAPTIVE_TIMER_PERIOD);
         mod_timer(&priv->rateadapter_timer, jiffies + MSECS(DEFAULT_RATE_ADAPTIVE_TIMER_PERIOD));
-//        DMESG("<----timer_rate_adaptive()\n");
 }
-//by amy for rate adaptive
 #endif
 
-//by amy for rate adaptive
-//by amy for power save
 void
 InactivePowerSave(
 	struct net_device *dev
 	)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	//u8 index = 0;
 
-	//
-	// This flag "bSwRfProcessing", indicates the status of IPS procedure, should be set if the IPS workitem
-	// is really scheduled.
-	// The old code, sets this flag before scheduling the IPS workitem and however, at the same time the
-	// previous IPS workitem did not end yet, fails to schedule the current workitem. Thus, bSwRfProcessing
-	// blocks the IPS procedure of switching RF.
-	// By Bruce, 2007-12-25.
-	//
 	priv->bSwRfProcessing = true;
-//	printk("in function %s\n",__FUNCTION__);
 	MgntActSet_RF_State(dev, priv->eInactivePowerState, RF_CHANGE_BY_IPS);
 
-	//
-	// To solve CAM values miss in RF OFF, rewrite CAM values after RF ON. By Bruce, 2007-09-20.
-	//
 #if 0
 	while( index < 4 )
 	{
@@ -2543,11 +2188,6 @@
 	priv->bSwRfProcessing = false;	
 }
 
-//
-//	Description:
-//		Enter the inactive power save mode. RF will be off
-//	2007.08.17, by shien chang.
-//
 void
 IPSEnter(
 	struct net_device *dev
@@ -2556,31 +2196,17 @@
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	RT_RF_POWER_STATE rtState;
 	printk("==============================>enter IPS\n");
-//	printk("in function %s\n",__FUNCTION__);
 	if (priv->bInactivePs)
 	{
 		rtState = priv->eRFPowerState;
 
-		//
-		// Added by Bruce, 2007-12-25.
-		// Do not enter IPS in the following conditions:
-		// (1) RF is already OFF or Sleep
-		// (2) bSwRfProcessing (indicates the IPS is still under going)
-		// (3) Connectted (only disconnected can trigger IPS)
-		// (4) IBSS (send Beacon)
-		// (5) AP mode (send Beacon)
-		//
 		if (rtState == eRfOn && !priv->bSwRfProcessing && (priv->ieee80211->iw_mode != IW_MODE_ADHOC) 
 			&& (priv->ieee80211->state != IEEE80211_LINKED ))
 		{
-			//printk("IPSEnter(): Turn off RF.\n");
 			priv->eInactivePowerState = eRfOff;
 			InactivePowerSave(dev);
-//			SetRFPowerState(dev, priv->eInactivePowerState);
-//			MgntActSet_RF_State(dev, priv->eInactivePowerState, RF_CHANGE_BY_IPS);
 		}
 	}
-//	printk("priv->eRFPowerState is %d\n",priv->eRFPowerState);	
 }
 void
 IPSLeave(
@@ -2589,41 +2215,30 @@
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	RT_RF_POWER_STATE rtState;
-//	printk("===================================>leave IPS\n");
 	if (priv->bInactivePs)
 	{	
 		rtState = priv->eRFPowerState;	
 		if ((rtState == eRfOff || rtState == eRfSleep) && (!priv->bSwRfProcessing) && priv->RfOffReason <= RF_CHANGE_BY_IPS)
 		{
-//			printk("IPSLeave(): Turn on RF.\n");
 			priv->eInactivePowerState = eRfOn;
 			InactivePowerSave(dev);
 		}
 	}
-//	printk("priv->eRFPowerState is %d\n",priv->eRFPowerState);
 }
-//by amy for power save
-//by amy for rate adaptive
-//void rtl8180_watch_dog(struct net_device *dev)
 #ifdef DIG
 #if 1
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8180_watch_dog_wq (struct work_struct *work)
 {
-//      struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
-//      struct ieee80211_device * ieee = (struct ieee80211_device*)
-//                                             container_of(work, struct ieee80211_device, watch_dog_wq);
         struct delayed_work *dwork = container_of(work,struct delayed_work,work);
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,watch_dog_wq);
         struct net_device *dev = ieee->dev;
 #else
 void rtl8180_watch_dog_wq(struct net_device *dev)
 {
-       // struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
 #endif 
 
-//{
 
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	bool bEnterPS;
@@ -2631,21 +2246,13 @@
 	
 	bEnterPS = false;
 	bBusyTraffic = false;
-//	printk("========================>enter rtl8180_watch_dog_wq()\n");
 #if 1
-	//down(&priv->ieee80211->ips_sem);
     if(priv->ieee80211->actscanning == false){
 		if((priv->ieee80211->state == IEEE80211_NOLINK) && (priv->ieee80211->beinretry == false) && (priv->eRFPowerState == eRfOn) && (priv->ieee80211->iw_mode == IW_MODE_INFRA )){
-//		printk("====================>haha:IPSEnter()\n");
 		down(&priv->ieee80211->ips_sem);
-		//IPSEnter(dev);	
 		up(&priv->ieee80211->ips_sem);
-//		MgntActSet_RF_State(dev,eRfOff,RF_CHANGE_BY_IPS);	
-			//ieee80211_stop_scan(priv->ieee80211);
 }
     }
-//	queue_delayed_work(priv->ieee80211->wq,&priv->ieee80211->watch_dog_wq,IEEE80211_WATCH_DOG_TIME);
-	//up(&priv->ieee80211->ips_sem);
 #endif
 #if 0
 	if(priv->ieee80211->state == IEEE80211_LINKED){
@@ -2655,15 +2262,10 @@
 			bBusyTraffic = true;
 		}
 
-//		if(priv->NumRxOkInPeriod < 50 || priv->NumTxOkInPeriod < 50 )
 		if((priv->ieee80211->NumRxData + priv->NumTxOkInPeriod)<8)
 		{
 			bEnterPS= true;
 		}
-		//printk("priv->NumRxOkInPeriod is %d\n",priv->ieee80211->NumRxData);
-	        //printk("priv->NumTxOkInPeriod is %d\n",priv->NumTxOkInPeriod);
-//		printk("bEnterPS is %d\n",bEnterPS);
-		// LeisurePS only work in infra mode.
 		if(bEnterPS)
 		{
 			LeisurePSEnter(priv);
@@ -2678,13 +2280,10 @@
 		LeisurePSLeave(priv);
 	}
  
-//	printk("MgntLinkStatusWatchdog(): RxOk: %d TxOk: %d => bBusyTraffic: %d\n",priv->NumRxOkInPeriod, priv->NumTxOkInPeriod, bBusyTraffic);
 	priv->NumRxOkInPeriod = 0;
 	priv->NumTxOkInPeriod = 0;
 	priv->ieee80211->NumRxData = 0;
-//	pMgntInfo->LinkDetectInfo.bBusyTraffic = bBusyTraffic;
 #endif		
-//	printk("========================>leave rtl8180_watch_dog_wq()\n");
 }
 #endif
 #ifdef DIG
@@ -2692,46 +2291,48 @@
 {
 	struct r8180_priv* priv = ieee80211_priv((struct net_device *)data);
 	struct net_device* dev = priv->ieee80211->dev;
-//	DMESG("---->watch_dog_adaptive()\n");
 	if(!priv->up)
 	{
-		//DMESG("<----watch_dog_adaptive():driver is not up!\n");
 		return;
 	}
-	// Tx and Rx High Power Mechanism.
 	if(CheckHighPower(dev))
 	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)	
+		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->tx_pw_wq, 0);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->tx_pw_wq);
+#else
+		schedule_task(&priv->ieee80211->tx_pw_wq);
+#endif		
 	}
 
-	// Schedule an workitem to perform DIG
 	if(CheckDig(dev) == true)
 	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)	
+		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_dig_wq, 0);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_dig_wq);
+#else
+		schedule_task(&priv->ieee80211->hw_dig_wq);
+#endif
+		
 	}
 
-	//queue_work(priv->ieee80211->wq,&priv->ieee80211->watch_dog_wq);
-	//  	rtl8180_watch_dog((struct net_device *)data);
-	//priv->watch_dog_timer.expires = jiffies + MSECS(IEEE80211_WATCH_DOG_TIME);
-	//add_timer(&priv->watch_dog_timer);
 	mod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
-//	DMESG("<----watch_dog_adaptive()\n");
 }
 #endif
 
-//lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void GPIOChangeRFWorkItemCallBack(struct work_struct *work);
 #else
-void GPIOChangeRFWorkItemCallBack(struct ieee80211_device *ieee);
+void GPIOChangeRFWorkItemCallBack(struct net_device *dev);
 #endif
 void gpio_change_polling(unsigned long data);
 #endif
 
 
 void rtl8180_irq_rx_tasklet(struct r8180_priv *priv);
-//void rtl8180_irq_rx_tasklet(struct work_struct *work);
 short rtl8180_init(struct net_device *dev)
 {
 		
@@ -2741,52 +2342,27 @@
 	int ch;
 	u8 chan_plan_index;
 	u16 EEPROMId;
-	//u16 version;
-	//u8 hw_version;
-	//u8 config3;
-	
-	//FIXME: these constants are placed in a bad pleace.
-
-//	priv->txbuffsize = 1024;
-//	priv->txringcount = 32;
-//	priv->rxbuffersize = 1024;
-//	priv->rxringcount = 32; 
-//	priv->txbeaconcount = 3;
-//	priv->rx_skb_complete = 1;
-	//priv->txnp_pending.ispending=0; 
-	// ^^ the SKB does not containt a partial RXed
-	// packet (is empty)
-	//
+	
+
 #if 0
 	if(!channels){
 		DMESG("No channels, aborting");
 		return -1;
 	}
 	ch=channels;
-	priv->channel_plan = 0;//hikaru
+	priv->channel_plan = 0;
 
-	 // set channels 1..14 allowed in given locale
 	for (i=1; i<=14; i++) {
 		(priv->ieee80211->channel_map)[i] = (u8)(ch & 0x01);
 		ch >>= 1;
 	}
 #endif	
-	//memcpy(priv->stats,0,sizeof(struct Stats));
 	
-	//priv->irq_enabled=0;
 	
-//	priv->stats.rxdmafail=0;
 	priv->stats.txrdu=0;
-//	priv->stats.rxrdu=0;
-//	priv->stats.rxnolast=0;
-//	priv->stats.rxnodata=0;
-	//priv->stats.rxreset=0;
-	//priv->stats.rxwrkaround=0;
-//	priv->stats.rxnopointer=0;
 	priv->stats.txnperr=0;
 	priv->stats.txresumed=0;
 	priv->stats.rxerr=0;
-//	priv->stats.rxoverflow=0;
 	priv->stats.rxint=0;
 	priv->stats.txnpokint=0;
 	priv->stats.txhpokint=0;
@@ -2802,7 +2378,7 @@
 	priv->stats.txretry=0;
 	priv->stats.txlperr=0;
 	priv->stats.txlpokint=0;
-	priv->stats.rxretry=0;//tony 20060601
+	priv->stats.rxretry=0;
 	priv->stats.rxcrcerrmin=0;
 	priv->stats.rxcrcerrmid=0;
 	priv->stats.rxcrcerrmax=0;
@@ -2813,27 +2389,20 @@
 	
 	priv->retry_rts = DEFAULT_RETRY_RTS;
 	priv->retry_data = DEFAULT_RETRY_DATA;
-	priv->ieee80211->rate = 110; //11 mbps
+	priv->ieee80211->rate = 110; 
 	priv->CurrentOperaRate=priv->ieee80211->rate/5;
 	priv->ieee80211->short_slot = 1;
-	priv->ieee80211->mode = IEEE_G|IEEE_B; //2007.1.25
+	priv->ieee80211->mode = IEEE_G|IEEE_B; 
 	priv->promisc = (dev->flags & IFF_PROMISC) ? 1:0;
 	spin_lock_init(&priv->tx_lock);
 	spin_lock_init(&priv->rf_ps_lock);
-//      priv->stats.txokbytestotal =0;
-//by amy
         priv->LastSignalStrengthInPercent=0;
         priv->SignalStrength=0;
         priv->SignalQuality=0;
         priv->antenna_flag=0;
         priv->flag_beacon = false;
-//by amy
-//david
-	//radion on defaultly 
 	priv->radion = 1;
-//david
 	priv->ScanAllowedNow = 1;	
-//by amy for rate adaptive
     priv->CurrRetryCnt=0;
     priv->LastRetryCnt=0;
         priv->LastTxokCnt=0;
@@ -2852,41 +2421,30 @@
         priv->FailTxRateCount=0;
         priv->LastTxThroughput=0;
         priv->txokbytestotal=0;
-//by amy for rate adaptive
-//by amy for ps
 		priv->RFChangeInProgress = false;
 		priv->SetRFPowerStateInProgress = false;
 		priv->RFProgType = 0;
 		priv->bInHctTest = false;
-		priv->bInactivePs = true;//false;
-		//priv->ieee80211->bInactivePs = priv->bInactivePs;
+		priv->bInactivePs = true;
 		priv->bSwRfProcessing = false;
 		priv->eRFPowerState = eRfOff;
 		priv->RfOffReason = 0;
 		priv->NumRxOkInPeriod = 0;
 		priv->NumTxOkInPeriod = 0;
 		priv->bLeisurePs = true;
-	//	priv->dot11PowerSaveMode = eActive;
-		//priv->RegThreeWireMode=HW_THREE_WIRE_BY_8051;
 	priv->ps_mode = false;
-//by amy for ps
 
-//by amy for DIG
 	priv->bDigMechanism = 1;
 	priv->bCCKThMechanism = 0;
 	priv->InitialGain = 0;
 	priv->StageCCKTh = 0;
 	priv->RegBModeGainStage = 2;
-//by amy for DIG
-// {by david for DIG, 2008.3.6
 	priv->RegDigOfdmFaUpTh = 0x0c;
 	priv->RegBModeGainStage = 0x02;
 	priv->DIG_NumberFallbackVote = 0;
 	priv->DIG_NumberUpgradeVote = 0;
 	priv->CCKUpperTh = 0x100;
 	priv->CCKLowerTh = 0x20;
-//}
-//{added by david for High tx power, 2008.3.11
 	priv->bRegHighPowerMechanism = true;
 	priv->bToUpdateTxPwr = false;
 
@@ -2894,15 +2452,9 @@
 	priv->Z2HiPwrLowerTh = 75;
 	priv->Z2RSSIHiPwrUpperTh = 70;
 	priv->Z2RSSIHiPwrLowerTh = 20;
-	//specify for rtl8187B
 	priv->wMacRegRfPinsOutput = 0x0480;
 	priv->wMacRegRfPinsSelect = 0x2488;
-	//
-	// Note that, we just set TrSwState to TR_HW_CONTROLLED here instead of changing 
-	// HW setting because we assume it should be inialized as HW controlled. 061010, by rcnjko.
-	//
 	priv->TrSwitchState = TR_HW_CONTROLLED;
-//}
 
 #ifdef SW_ANTE_DIVERSITY
 	priv->antb=0;
@@ -2910,9 +2462,8 @@
         priv->LastRxPktAntenna = 0;
 	priv->AdMinCheckPeriod = 5;
 	priv->AdMaxCheckPeriod = 10;
-// Lower signal strength threshold to fit the HW participation in antenna diversity. +by amy 080312
-	priv->AdMaxRxSsThreshold = 30;//60->30
-	priv->AdRxSsThreshold = 20;//50->20
+	priv->AdMaxRxSsThreshold = 30;
+	priv->AdRxSsThreshold = 20;
 	priv->AdCheckPeriod = priv->AdMinCheckPeriod;
 	priv->AdTickCount = 0;
 	priv->AdRxSignalStrength = -1;
@@ -2927,90 +2478,105 @@
 	priv->SwAntennaDiversityTimer.function = (void *)SwAntennaDiversityTimerCallback;
 #endif
 
-//lzm add 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	priv->wlan_first_up_flag1 = 0;
 	priv->iwpriv_radio_on = 1;
 #endif	
-//by lizhaoming for LED
 #ifdef LED
 	priv->ieee80211->ieee80211_led_contorl = LedControl8187;
 #endif
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)	
-	INIT_WORK(&priv->reset_wq,(void*) rtl8180_restart,dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#ifdef POLLING_METHOD_FOR_RADIO
+	INIT_DELAYED_WORK(&priv->ieee80211->GPIOChangeRFWorkItem,(void*) GPIOChangeRFWorkItemCallBack);
+#endif
+
+#ifdef SW_ANTE_DIVERSITY
+	INIT_DELAYED_WORK(&priv->ieee80211->SwAntennaWorkItem,(void*) SwAntennaWorkItemCallback);
+#endif
+
+
+#ifdef RATE_ADAPTIVE
+	INIT_DELAYED_WORK(&priv->ieee80211->rate_adapter_wq,(void*)rtl8180_rate_adapter);
+#endif
+
+#ifdef DIG
+	INIT_DELAYED_WORK(&priv->ieee80211->watch_dog_wq,(void*)rtl8180_watch_dog_wq);
+	INIT_DELAYED_WORK(&priv->ieee80211->hw_dig_wq,(void*)rtl8180_hw_dig_wq);
+	INIT_DELAYED_WORK(&priv->ieee80211->tx_pw_wq,(void*)rtl8180_tx_pw_wq);
+#endif
+	INIT_WORK(&priv->ieee80211->ps_request_tx_ack_wq,(void*)rtl8180_rq_tx_ack);
+	INIT_WORK(&priv->ieee80211->hw_wakeup_wq,(void*)rtl8180_hw_wakeup);
+	INIT_WORK(&priv->ieee80211->hw_sleep_wq,(void*)rtl8180_hw_sleep);
+	INIT_WORK(&priv->reset_wq,(void*) rtl8180_restart);
+
+#else 
+
+#ifdef POLLING_METHOD_FOR_RADIO
+	INIT_WORK(&priv->ieee80211->GPIOChangeRFWorkItem,(void*) GPIOChangeRFWorkItemCallBack, dev);
+#endif
+
+#ifdef SW_ANTE_DIVERSITY
+	INIT_WORK(&priv->ieee80211->SwAntennaWorkItem,(void*) SwAntennaWorkItemCallback, dev);
+#endif
+
 #ifdef RATE_ADAPTIVE
 	INIT_WORK(&priv->ieee80211->rate_adapter_wq,(void*)rtl8180_rate_adapter,dev);	
 #endif
+
 #ifdef DIG
-	INIT_WORK(&priv->ieee80211->hw_dig_wq,(void*)rtl8180_hw_dig_wq,dev);
 	INIT_WORK(&priv->ieee80211->watch_dog_wq,(void*)rtl8180_watch_dog_wq,dev);
+	INIT_WORK(&priv->ieee80211->hw_dig_wq,(void*)rtl8180_hw_dig_wq,dev);
 	INIT_WORK(&priv->ieee80211->tx_pw_wq,(void*)rtl8180_tx_pw_wq,dev);
 #endif
 	INIT_WORK(&priv->ieee80211->ps_request_tx_ack_wq,(void*)rtl8180_rq_tx_ack,dev);
 	INIT_WORK(&priv->ieee80211->hw_wakeup_wq,(void*)rtl8180_hw_wakeup,dev);
 	INIT_WORK(&priv->ieee80211->hw_sleep_wq,(void*)rtl8180_hw_sleep,dev);
-//	INIT_WORK(&priv->ps_request_tx_ack_wq,(void(*)(void*))rtl8180_rq_tx_ack,dev);
-//lzm add for radio on/off 080917
-#ifdef POLLING_METHOD_FOR_RADIO
-	INIT_WORK(&priv->ieee80211->GPIOChangeRFWorkItem,(void*) GPIOChangeRFWorkItemCallBack, priv->ieee80211);
-#endif
-
-#ifdef SW_ANTE_DIVERSITY
-	INIT_WORK(&priv->ieee80211->SwAntennaWorkItem,(void*) SwAntennaWorkItemCallback, dev);
+	INIT_WORK(&priv->reset_wq,(void*) rtl8180_restart,dev);
 #endif
 
 #else
-//lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
-	INIT_DELAYED_WORK(&priv->ieee80211->GPIOChangeRFWorkItem,(void*) GPIOChangeRFWorkItemCallBack);
+	tq_init(&priv->ieee80211->GPIOChangeRFWorkItem,(void*) GPIOChangeRFWorkItemCallBack, dev);
 #endif
 
 #ifdef SW_ANTE_DIVERSITY
-	INIT_DELAYED_WORK(&priv->ieee80211->SwAntennaWorkItem,(void*) SwAntennaWorkItemCallback);
+	tq_init(&priv->ieee80211->SwAntennaWorkItem,(void*) SwAntennaWorkItemCallback, dev);
 #endif
 
-	INIT_WORK(&priv->reset_wq,(void*) rtl8180_restart);
 #ifdef RATE_ADAPTIVE
-	INIT_DELAYED_WORK(&priv->ieee80211->rate_adapter_wq,(void*)rtl8180_rate_adapter);
+	tq_init(&priv->ieee80211->rate_adapter_wq,(void*)rtl8180_rate_adapter,dev);	
 #endif
+
 #ifdef DIG
-	INIT_DELAYED_WORK(&priv->ieee80211->hw_dig_wq,(void*)rtl8180_hw_dig_wq);
-	INIT_DELAYED_WORK(&priv->ieee80211->watch_dog_wq,(void*)rtl8180_watch_dog_wq);
-	INIT_DELAYED_WORK(&priv->ieee80211->tx_pw_wq,(void*)rtl8180_tx_pw_wq);
-#endif
-	INIT_WORK(&priv->ieee80211->ps_request_tx_ack_wq,(void*)rtl8180_rq_tx_ack);
-	INIT_WORK(&priv->ieee80211->hw_wakeup_wq,(void*)rtl8180_hw_wakeup);
-	INIT_WORK(&priv->ieee80211->hw_sleep_wq,(void*)rtl8180_hw_sleep);
-//	INIT_WORK(&priv->ps_request_tx_ack_wq,(void(*)(void*))rtl8180_rq_tx_ack);
-       // INIT_WORK(&priv->ieee80211->rx_handle_wq,(void(*)(void*))rtl8180_irq_rx_tasklet);
+	tq_init(&priv->ieee80211->watch_dog_wq,(void*)rtl8180_watch_dog_wq,dev);
+	tq_init(&priv->ieee80211->hw_dig_wq,(void*)rtl8180_hw_dig_wq,dev);
+	tq_init(&priv->ieee80211->tx_pw_wq,(void*)rtl8180_tx_pw_wq,dev);
 #endif
-#else
-        tq_init(&priv->reset_wq,(void*) rtl8180_restart,dev);
+
+	tq_init(&priv->ieee80211->ps_request_tx_ack_wq,(void*)rtl8180_rq_tx_ack,dev);
+	tq_init(&priv->ieee80211->hw_wakeup_wq,(void*)rtl8180_hw_wakeup,dev);
+	tq_init(&priv->ieee80211->hw_sleep_wq,(void*)rtl8180_hw_sleep,dev);
+	tq_init(&priv->reset_wq,(void*) rtl8180_restart,dev);
 #endif
-//lzm add for radio on/off 080917
+
 #ifdef POLLING_METHOD_FOR_RADIO
 	init_timer(&priv->gpio_polling_timer);
 	priv->gpio_polling_timer.data = (unsigned long)dev;
 	priv->gpio_polling_timer.function = gpio_change_polling;
 #endif
 #ifdef RATE_ADAPTIVE
-//by amy for rate adaptive
     init_timer(&priv->rateadapter_timer);
         priv->rateadapter_timer.data = (unsigned long)dev;
         priv->rateadapter_timer.function = timer_rate_adaptive;
-//by amy for rate adaptive
 #endif
 #ifdef DIG
-//by amy for ps
     init_timer(&priv->watch_dog_timer);
 	priv->watch_dog_timer.data = (unsigned long)dev;
 	priv->watch_dog_timer.function = watch_dog_adaptive;
-//by amy for ps
 #endif	
 	sema_init(&priv->wx_sem,1);
 	sema_init(&priv->power_sem,1);
-	//printk(KERN_WARNING "priv->power_sema %d!\n",priv->power_sem);
 
 	tasklet_init(&priv->irq_rx_tasklet,
 		     (void(*)(unsigned long))rtl8180_irq_rx_tasklet,
@@ -3020,38 +2586,29 @@
 	priv->ps_timer.data = (unsigned long)dev;
 	priv->ps_timer.function = timer_hw_wakeup_wq;
 
-	//priv->ieee80211->func = 
-	//	kmalloc(sizeof(struct ieee80211_helper_functions),GFP_KERNEL);
-	//memset(priv->ieee80211->func, 0,
-	  //     sizeof(struct ieee80211_helper_functions));
 	priv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;	
 	priv->ieee80211->iw_mode = IW_MODE_INFRA;
 	priv->ieee80211->softmac_features  = IEEE_SOFTMAC_SCAN | 
 		IEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ | 
 		IEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE |
-		//IEEE_SOFTMAC_BEACONS | 
+		IEEE_SOFTMAC_BEACONS |
 		IEEE_SOFTMAC_SINGLE_QUEUE;
 	
 	priv->ieee80211->active_scan = 1;
-	priv->ieee80211->rate = 110; //11 mbps
+	priv->ieee80211->rate = 110; 
 	priv->CurrentOperaRate=priv->ieee80211->rate/5;
 	priv->ieee80211->modulation = IEEE80211_CCK_MODULATION | IEEE80211_OFDM_MODULATION;
 	priv->ieee80211->host_encrypt = 1;
 	priv->ieee80211->host_decrypt = 1;
-//	priv->ieee80211->ps_request_tx_ack = rtl8180_rq_tx_ack_wq;
-	//priv->ieee80211->ps_request_tx_ack = rtl8180_rq_tx_ack;
 	priv->ieee80211->ps_is_queue_empty = rtl8180_is_tx_queue_empty;
-	priv->ieee80211->start_send_beacons = rtl8187_beacon_tx;
-	priv->ieee80211->stop_send_beacons = rtl8187_beacon_stop;
-	//priv->ieee80211->softmac_hard_start_xmit = rtl8180_hard_start_xmit;
+	priv->ieee80211->start_send_beacons = NULL;
+	priv->ieee80211->stop_send_beacons = NULL;
 	priv->ieee80211->softmac_hard_start_xmit = NULL;
 	priv->ieee80211->set_chan = rtl8180_set_chan;
 	priv->ieee80211->link_change = rtl8187_link_change;
 	priv->ieee80211->softmac_data_hard_start_xmit = rtl8180_hard_data_xmit;
 	priv->ieee80211->data_hard_stop = rtl8180_data_hard_stop;
 	priv->ieee80211->data_hard_resume = rtl8180_data_hard_resume;
-	//priv->ieee80211->start_send_beacons = NULL;
-	//priv->ieee80211->stop_send_beacons = NULL;
 	
 	priv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;
 	
@@ -3065,7 +2622,6 @@
 		hw_version =( read_nic_dword(dev, TCR) & TCR_HWVERID_MASK)>>TCR_HWVERID_SHIFT;
 		switch (hw_version) {
 			case 0x06:
-		//		priv->card_8187_Bversion = VERSION_8187B_B;
 				break;
 			case 0x05:
 				priv->card_8187_Bversion = VERSION_8187_D;
@@ -3078,8 +2634,6 @@
 
 #ifdef SW_ANTE_DIVERSITY
         EEPROMId = eprom_read(dev, 0);
-        //DMESG("=====>EEPROMId:0x%04x\n", EEPROMId);
-        //if(EEPROMId != RTL8185_EEPROM_ID)
         if(EEPROMId != 0x8129)
         {
             priv->AutoloadFailFlag = true; 
@@ -3091,7 +2645,6 @@
 
 	priv->EEPROMVersion = eprom_read(dev, (u16) (EEPROM_VERSION>>1) );
 
-        //DMESG("=====>EEPROMVersion:0x%04x\n", priv->EEPROMVersion);
 #if 0
 	if( (!priv->card_8185) && priv->EEPROMVersion < 0x0101)
 	{
@@ -3107,7 +2660,6 @@
 		}
 	}
 
-	//if(!priv->card_8185)
 	{
 		if(priv->antb) 
 			DMESG ("Antenna B is default antenna");
@@ -3120,14 +2672,11 @@
 			DMESG("Antenna diversity is disabled");
 	}
 #endif	
-	//Read AntennaDiversity,CSThreshold,CSMethod,DigitalPhy,DefaultAntennaB,GEPRFOffState	
 	if(priv->EEPROMVersion <= 0x0101)
 	{
-//#if HAL_CODE_BASE==RTL818X
 		priv->EEPROMAntennaDiversity=true;
 		priv->EEPROMCSThreshold=0x0c;
 		priv->EEPROMDefaultAntennaB=false;
-//#endif
 		priv->EEPROMCSMethod=RCR_EnCS1;
 		priv->EEPROMDigitalPhy=true;
 		
@@ -3136,17 +2685,14 @@
 	{
 		u16	usValue;
 
-//#if HAL_CODE_BASE==RTL818X
 		usValue = eprom_read(dev, (u16) (EEPROM_CONFIG2>>1) ) & 0xff;
 		if(usValue&0x40)
 			priv->EEPROMAntennaDiversity=true;
 		else
 			priv->EEPROMAntennaDiversity=false;
-                //DMESG("=====>EEPROMAntennaDiversity:%d\n", priv->EEPROMAntennaDiversity);
 
 		usValue = eprom_read(dev, (u16) (EEPROM_CS_THRESHOLD>>1) ) >> 8;
 		priv->EEPROMCSThreshold=usValue;
-//#endif
 			
 		if(priv->EEPROMVersion<=0x0104)
 			usValue = eprom_read(dev, (u16) (EEPROM_RF_PARAM>>1) ) & 0xff;
@@ -3157,27 +2703,20 @@
 			priv->EEPROMDigitalPhy=false;
 		else
 			priv->EEPROMDigitalPhy=true;
-                //DMESG("=====>EEPROMDigitalPhy:%d\n", priv->EEPROMDigitalPhy);
-//#if HAL_CODE_BASE==RTL818X
 		if(usValue&0x02)
 			priv->EEPROMDefaultAntennaB=true;
 		else
 			priv->EEPROMDefaultAntennaB=false;
-                //DMESG("=====>EEPROMDefaultAntennaB:%d\n", priv->EEPROMDefaultAntennaB);
-//#endif
 		switch((usValue&0x0c)>>2)
 		{
 		case 1:
 			priv->EEPROMCSMethod=RCR_EnCS1;
-                        //DMESG("=====>EEPROMCSMethod:RCR_EnCS1\n");
 			break;
 		case 2:
 			priv->EEPROMCSMethod=RCR_EnCS2;
-                        //DMESG("=====>EEPROMCSMethod:RCR_EnCS2\n");
 			break;
 		default:
 			priv->EEPROMCSMethod=0;
-                        //DMESG("=====>EEPROMCSMethod:0\n");
 			break;
 		}
 
@@ -3188,7 +2727,6 @@
 				priv->EEPROMGEPRFOffState = (usValue&0x10)?1:0;
 			}
 		}
-                //DMESG("=====>EEPROMGEPRFOffState:%d\n", priv->EEPROMGEPRFOffState);
 	}
 #endif
 	#if 0
@@ -3198,14 +2736,12 @@
 		case HW_VERID_R8185_ABC:
 			DMESG("MAC controller is a RTL8185 b/g");	
 			priv->card_8185 = 1;
-			// you should not find a card with 8225 PHY ver < C*/
 			priv->phy_ver = 2;
 			break;
 			 
 		case HW_VERID_R8185_D:
 			DMESG("MAC controller is a RTL8185 b/g (V. D)");	
 			priv->card_8185 = 2;
-			// you should not find a card with 8225 PHY ver < C*/
 			priv->phy_ver = 2;
 			break;
 			
@@ -3226,7 +2762,6 @@
 	}
 	
 	
-	// you should not found any 8185 Ver B Card */
 	priv->card_8185_Bversion = 0;
 	
 	config3 = read_nic_byte(dev, CONFIG3);
@@ -3247,47 +2782,32 @@
 
 
 	
-	// commented out just because we already do
-	//   this when resetting the card
 	#if 0
 		
 	u8 txcr, txreg50;
 	u32 txreg54, txreg60;
 
-	// enable A/D D/A register */
 	txcr = read_nic_byte(dev, 0x59);
-//	DMESG("<txcr:%x>", txcr);
-	//write_nic_word(dev, 0x59, 0x44);
 	write_nic_byte(dev, 0x59, 0x44);
-	//write_nic_byte(dev, 0x59, 0xea);
 	txcr = read_nic_byte(dev, 0x59);
-//	DMESG("<<txcr:%x>>", txcr);
 
         txreg50 = read_nic_byte(dev, 0x50);
-  //      DMESG("<txreg50:%x>", txreg50);
         write_nic_byte(dev, 0x50, 0xc0);
         txreg50 = read_nic_byte(dev, 0x50);
-    //    DMESG("<<txreg50:%x>>", txreg50);
 
 
         txreg54 = read_nic_dword(dev, 0x54);
-     //   DMESG("<txreg54:%x>", txreg54);
         txreg54 = 0xa0000a59;
-    //    DMESG("<<txreg54:%x>>", txreg54);
         write_nic_dword(dev, 0x54, txreg54);
         txreg54 = read_nic_dword(dev, 0x54);
-   //     DMESG("<<<txreg54:%x>>>", txreg54);
 
         txreg60 = read_nic_dword(dev, 0x60);
-     //   DMESG("<txreg60:%x>", txreg60);
 
         write_nic_byte(dev, 0x50, 0x0);
         txcr = read_nic_byte(dev, 0x50);
-       // DMESG("<<txcr:%x>>", txcr);
 
 #endif
 	
-	//the eeprom type is stored in RCR register bit #6 */ 
 	if (RCR_9356SEL & read_nic_dword(dev, RCR)){
 		priv->epromtype=EPROM_93c56;
 		DMESG("Reported EEPROM chip is a 93c56 (2Kbit)");
@@ -3302,7 +2822,6 @@
 	if(chan_plan_index & 0x80) {
 		chan_plan_index &= 0x7f;
 		if ((DefaultChannelPlan[chan_plan_index].Len != 0)&&(chan_plan_index < sizeof(DefaultChannelPlan)/sizeof(DefaultChannelPlan[0]))){
-			// force channel plan map
 			for (i=0;i<DefaultChannelPlan[chan_plan_index].Len;i++) 
 				priv->ieee80211->channel_map[DefaultChannelPlan[chan_plan_index].Channel[i]] = 1;
 		} else {
@@ -3310,13 +2829,11 @@
 			return -1;
 		}
 	} else {
-		//default channel plan setting
 		if(!channels){
 			DMESG("No channels, aborting");
 			return -1;
 		}
 		ch=channels;
-		// set channels 1..14 allowed in given locale
 		for (i=1; i<=14; i++) {
 			(priv->ieee80211->channel_map)[i] = (u8)(ch & 0x01);
 			ch >>= 1;
@@ -3366,7 +2883,6 @@
 	priv->cck_txpwr_base = word & 0xf;
 	priv->ofdm_txpwr_base = (word>>4) & 0xf;
 	
-	// check RF frontend chipset */
 	
 	switch (priv->rf_chip) {
 		
@@ -3404,9 +2920,7 @@
 		
 	}
 
-//	DMESG("Energy threshold: %x",priv->cs_treshold);
 	DMESG("PAPE from CONFIG2: %x",read_nic_byte(dev,CONFIG2)&0x7);
-	//DMESG("CONFIG2: %x ECONFIG2: %x",read_nic_byte(dev,CONFIG2),eprom_read(dev,EPROM_CONFIG2));
 	
 	if(rtl8187_usb_initendpoints(dev)!=0){ 
 		DMESG("Endopoints initialization failed");
@@ -3445,9 +2959,7 @@
 
 void rtl8185_rf_pins_enable(struct net_device *dev)
 {
-//	u16 tmp;
-//	tmp = read_nic_word(dev, RFPinsEnable);*/
-	write_nic_word(dev, RFPinsEnable, 0x1ff7);// | tmp);
+	write_nic_word(dev, RFPinsEnable, 0x1ff7);
 }
 
 
@@ -3499,9 +3011,7 @@
 
 void rtl8187_write_phy(struct net_device *dev, u8 adr, u32 data)
 {
-	//u8 phyr;
 	u32 phyw;
-//	int i;
 	
 	adr |= 0x80;
 	 
@@ -3509,13 +3019,11 @@
 	
 	
 	
-	// Note that, we must write 0xff7c after 0x7d-0x7f to write BB register. 
 	write_nic_byte(dev, 0x7f, ((phyw & 0xff000000) >> 24));
 	write_nic_byte(dev, 0x7e, ((phyw & 0x00ff0000) >> 16));
 	write_nic_byte(dev, 0x7d, ((phyw & 0x0000ff00) >> 8));
 	write_nic_byte(dev, 0x7c, ((phyw & 0x000000ff) ));
 
-	//read_nic_dword(dev, PHY_ADR);
 #if 0	
 	for(i=0;i<10;i++){
 		write_nic_dword(dev, PHY_ADR, 0xffffff7f & phyw);
@@ -3524,10 +3032,6 @@
 			
 	}
 #endif
-	// this is ok to fail when we write AGC table. check for AGC table might be
-	//  done by masking with 0x7f instead of 0xff
-	// 
-	//if(phyr != (data&0xff)) DMESGW("Phy write timeout %x %x %x", phyr, data, adr);
 	mdelay(1);
 }
 
@@ -3549,24 +3053,15 @@
 void rtl8180_adapter_start(struct net_device *dev)
 {
         struct r8180_priv *priv = ieee80211_priv(dev);
-	//u32 anaparam;
-	//u8 config3;
 	
-	//rtl8180_rtx_disable(dev);
 	rtl8180_reset(dev);
 
 	write_nic_byte(dev,0x85,0);
 	write_nic_byte(dev,0x91,0);
 	
-	// light blink! */
 	write_nic_byte(dev,0x85,4);
 	
-	//write_nic_byte(dev,0x91,1);
-	//write_nic_byte(dev,0x90,0);
 	priv->irq_mask = 0xffff;
-//	priv->dma_poll_mask = 0;
-//	priv->dma_poll_mask|= (1<<TX_DMA_STOP_BEACON_SHIFT);
-//	rtl8180_beacon_tx_disable(dev);
 	
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 	write_nic_dword(dev, MAC0, ((u32*)dev->dev_addr)[0]);
@@ -3575,13 +3070,6 @@
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 	rtl8180_update_msr(dev);
 
-//	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-//	
-//	write_nic_word(dev,0xf4,0xffff);
-//	write_nic_byte(dev,
-//		       CONFIG1, (read_nic_byte(dev,CONFIG1) & 0x3f) | 0x80);	
-//
-//	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 	write_nic_dword(dev,INT_TIMEOUT,0);	
 
 #ifdef DEBUG_REGISTERS
@@ -3602,36 +3090,23 @@
 	write_nic_word(dev,0x5e,1);
 
 	#if 1
-	//mdelay(1);
 	write_nic_word(dev,0xfe,0x10);
-//	mdelay(1);
 	#endif
-	write_nic_byte(dev, TALLY_SEL, 0x80);//Set NQ retry count
+	write_nic_byte(dev, TALLY_SEL, 0x80);
 
 	write_nic_byte(dev, 0xff, 0x60);
 
 	write_nic_word(dev,0x5e,0);
 
-	//add for Led controll
 	write_nic_byte(dev,0x85,4);
 	
 	rtl8180_irq_enable(dev);
-	//DMESG ("lfree %d",get_curr_tx_free_desc(dev,LOW_PRIORITY));
 	
-	//DMESG ("nfree %d",get_curr_tx_free_desc(dev,NORM_PRIORITY));
 	
-	//DMESG ("hfree %d",get_curr_tx_free_desc(dev,HI_PRIORITY));
-	//if(check_nic_enought_desc(dev,NORM_PRIORITY)) DMESG("NORM OK");
-	//if(check_nic_enought_desc(dev,HI_PRIORITY)) DMESG("HI OK");
-	//if(check_nic_enought_desc(dev,LOW_PRIORITY)) DMESG("LOW OK");*/
 }
 
 
 
-//  this configures registers for beacon tx and enables it via
-//  rtl8180_beacon_tx_enable(). rtl8180_beacon_tx_disable() might
-//  be used to stop beacon transmission
-// 
 #if 0
 void rtl8180_start_tx_beacon(struct net_device *dev)
 {
@@ -3639,20 +3114,12 @@
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	u16 word;	
 	DMESG("Enabling beacon TX");
-	//write_nic_byte(dev, 0x42,0xe6);// TCR
-	//rtl8180_init_beacon(dev);
-	//set_nic_txring(dev);
-//	rtl8180_prepare_beacon(dev);
 	rtl8180_irq_disable(dev);
-//	rtl8180_beacon_tx_enable(dev);
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	//write_nic_byte(dev,0x9d,0x20); //DMA Poll
-	//write_nic_word(dev,0x7a,0);
-	//write_nic_word(dev,0x7a,0x8000);
 
 	
 	word  = read_nic_word(dev, BcnItv);
-	word &= ~BcnItv_BcnItv; // clear Bcn_Itv
+	word &= ~BcnItv_BcnItv; 
 	write_nic_word(dev, BcnItv, word);
 
 	write_nic_word(dev, AtimWnd, 
@@ -3661,29 +3128,19 @@
 	word  = read_nic_word(dev, BintrItv);
 	word &= ~BintrItv_BintrItv;
 	
-	//word |= priv->ieee80211->beacon_interval * 
-	//	((priv->txbeaconcount > 1)?(priv->txbeaconcount-1):1);
-	// FIXME:FIXME check if correct ^^ worked with 0x3e8;
 	
 	write_nic_word(dev, BintrItv, word);
 	
-	//write_nic_word(dev,0x2e,0xe002);
-	//write_nic_dword(dev,0x30,0xb8c7832e);
 	for(i=0; i<ETH_ALEN; i++)
 		write_nic_byte(dev, BSSID+i, priv->ieee80211->beacon_cell_ssid[i]);
 	
-//	rtl8180_update_msr(dev);
 
 	
-	//write_nic_byte(dev,CONFIG4,3); 
 	
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 	
 	rtl8180_irq_enable(dev);
 	
-	//rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	//write_nic_byte(dev,0x9d,0x00); 	
-	//rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 }
 #endif
 /***************************************************************************
@@ -3703,11 +3160,9 @@
 
 	priv->up=1;
 	
-	//DMESG("Bringing up iface");
 
 	rtl8180_adapter_start(dev);
 
-//by lizhaoming for LED POWR ON
 #ifdef LED
 	if(priv->ieee80211->bHwRadioOff == false)
 		priv->ieee80211->ieee80211_led_contorl(dev,LED_CTL_POWER_ON); 
@@ -3716,15 +3171,10 @@
 	rtl8180_rx_enable(dev);
 
 	rtl8180_tx_enable(dev);
-//by amy for rate adaptive
         timer_rate_adaptive((unsigned long)dev);
-//by amy for rate adaptive
-//by amy for ps
 	watch_dog_adaptive((unsigned long)dev);
-//by amy for ps	
 
 #ifdef SW_ANTE_DIVERSITY
-//        if(priv->EEPROMAntennaDiversity)
             DMESG("SW Antenna Diversity Enable!");
             SwAntennaDiversityTimerCallback(dev);
 #endif
@@ -3749,7 +3199,6 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	int ret;
 
-	//lzm mod 080917 for radio on/off
 	if(priv->ieee80211->bHwRadioOff == false){
 		DMESG("rtl8180_open process");
 		down(&priv->wx_sem);
@@ -3803,29 +3252,31 @@
 	priv->up=0;
 	ieee80211_softmac_stop_protocol(priv->ieee80211);
 
-// FIXME */
 	if (!netif_queue_stopped(dev))
 		netif_stop_queue(dev);
 	
 	rtl8180_rtx_disable(dev);
 	rtl8180_irq_disable(dev);
 #ifdef RATE_ADAPTIVE
-//by amy for rate adaptive
         del_timer_sync(&priv->rateadapter_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
         cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
-//by amy for rate adaptive
+#endif
 #endif
 #ifdef DIG
 	del_timer_sync(&priv->watch_dog_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&priv->ieee80211->watch_dog_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_dig_wq);
 	cancel_delayed_work(&priv->ieee80211->tx_pw_wq);
-//by amy for rate adaptive
+#endif
 #endif
 #ifdef SW_ANTE_DIVERSITY
 	del_timer_sync(&priv->SwAntennaDiversityTimer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&priv->ieee80211->SwAntennaWorkItem);
 #endif
+#endif
 	if(priv->ieee80211->bHwRadioOff == false){
 		SetZebraRFPowerState8187(dev, eRfOff);
 	}
@@ -3844,26 +3295,26 @@
 	
 	ieee80211_softmac_stop_protocol(priv->ieee80211);
 	sema_init(&priv->power_sem,1);
-	//printk(KERN_WARNING "priv->power_semb %d!\n",priv->power_sem);
 #ifdef RATE_ADAPTIVE
-//by amy for rate adaptive
         del_timer_sync(&priv->rateadapter_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
         cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
-//        printk("haha:rtl8180_down()\n");
-//              if(timer_pending(&priv->rateadapter_timer))
-//by amy for rate adaptive
+#endif
 #endif
 #ifdef DIG
         del_timer_sync(&priv->watch_dog_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
         cancel_delayed_work(&priv->ieee80211->watch_dog_wq);
         cancel_delayed_work(&priv->ieee80211->hw_dig_wq);
         cancel_delayed_work(&priv->ieee80211->tx_pw_wq);
-//by amy for rate adaptive
+#endif
 #endif
 #ifdef SW_ANTE_DIVERSITY
 	del_timer_sync(&priv->SwAntennaDiversityTimer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&priv->ieee80211->SwAntennaWorkItem);
 #endif
+#endif
 	ieee80211_softmac_stop_protocol(priv->ieee80211);
 	
 	rtl8180_irq_disable(dev);
@@ -3874,7 +3325,6 @@
 	if (priv->eRFPowerState == eRfOff)
 	{
 		printk("as commit need to set RF to re on\n");
-		//IPSLeave(dev);
 	}
 #endif
 }
@@ -3902,19 +3352,14 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	short promisc;
 
-	//down(&priv->wx_sem);
 	
-	// FIXME FIXME */
 	
 	promisc = (dev->flags & IFF_PROMISC) ? 1:0;
 	
 	if (promisc != priv->promisc)
-	//	rtl8180_commit(dev);
 	
 	priv->promisc = promisc;
 	
-	//schedule_work(&priv->reset_wq);
-	//up(&priv->wx_sem);
 }
 
 
@@ -3942,7 +3387,6 @@
 
 #ifdef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
 
-//dword 0
 unsigned int    rxlen:12;
 unsigned int    icv:1;
 unsigned int    crc32:1;
@@ -3962,7 +3406,6 @@
 unsigned int    eor:1;
 unsigned int    own:1;
 
-//dword 1
 unsigned char   sq;
 unsigned char   rssi:7;
 unsigned char   antenna:1;
@@ -3973,10 +3416,8 @@
 unsigned char   shift:1;
 unsigned char   rsvd0:5;
 
-//dword 2
 unsigned int tsftl;
 
-//dword 3
 unsigned int tsfth;
 
 
@@ -3994,20 +3435,11 @@
 
 union rx_desc {
 
-//struct	rx_desc_rtl8187b desc_87b;
 struct	rx_desc_rtl8187	 desc_87;
 
 }__attribute__((packed));
 
 #if 0
-//
-//	Description:
-//		Perform signal smoothing for dynamic mechanism.
-//		This is different with PerformSignalSmoothing8187 in smoothing fomula.
-//		No dramatic adjustion is apply because dynamic mechanism need some degree
-//		of correctness. 
-//	2007.01.23, by shien chang.
-//
 void PerformUndecoratedSignalSmoothing8187(struct net_device *dev, struct ieee80211_rx_stats *stats)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -4023,10 +3455,8 @@
 			priv->UndecoratedSmoothedSS = stats->signalstrength;
 		}
 	} else {
-		// Determin the current packet is CCK rate, by Bruce, 2007-04-12.
 		priv->bCurCCKPkt = bCckRate;
 
-		// Tesing for SD3 DZ, by Bruce, 2007-04-11.
 		if(priv->UndecoratedSmoothedSS >= 0)
 		{	
 			priv->UndecoratedSmoothedSS = ((priv->UndecoratedSmoothedSS * 5) + (stats->signalstrength * 10)) / 6;
@@ -4036,11 +3466,6 @@
 			priv->UndecoratedSmoothedSS = stats->signalstrength * 10;
 		}
 
-		//
-		// Bacause the AGC parameter is not exactly correct under high power (AGC saturation), we need to record the RSSI value to be
-		// referenced by DoRxHighPower. It is not necessary to record this value when this packet is sent by OFDM rate.
-		// Advised by SD3 DZ, by Bruce, 2007-04-12.
-		// 
 		if(priv->CurCCKRSSI >= 0 && bCckRate)
 		{
 			priv->CurCCKRSSI = stats->signal;
@@ -4050,7 +3475,6 @@
 			priv->CurCCKRSSI = 0;
 		}
 	}
-	//printk("Sommthing SignalSterngth (%d) => UndecoratedSmoothedSS (%d)\n", stats->signalstrength, priv->UndecoratedSmoothedSS);
 }
 #endif
 
@@ -4060,15 +3484,10 @@
 	struct net_device *dev = (struct net_device*)rx_urb->context;
 	int status,len,flen;
 	struct sk_buff *skb;
-	//u32 *desc;
-	//u8 *desc;
-	//u8 signal,quality,rate;
 
 
 	u32 SignalStrength = 0;
 	bool bCckRate = false;
-	//char RX_PWDB = 0;
-	//long RecvSignalPower=0;
 	union   rx_desc *rx_desc;
 #ifdef SW_ANTE_DIVERSITY
         u8 Antenna = 0;
@@ -4077,19 +3496,16 @@
 		.signal = 0,
 		.noise = -98,
 		.rate = 0,
-		//	.mac_time = jiffies,
 		.freq = IEEE80211_24GHZ_BAND,
 	};
 
-	//DMESG("RX %d ",rx_urb->status);
 	status = rx_urb->status;
 	if(status == 0){
 
 
 		len = rx_urb->actual_length;
-		len -= 4*4;// 4 dword and 4 byte CRC */
+		len -= 4*4;
 
-		//len -= sizeof (struct rx_desc_rtl8187);
 
 		rx_desc = rx_urb->transfer_buffer + len;
 
@@ -4098,7 +3514,6 @@
 		if( flen <= rx_urb->actual_length){
 
 #if 1
-			//stats.nic_type = NIC_8187;
 
 			rx_desc = (union rx_desc *)(rx_urb->transfer_buffer + len);
 
@@ -4115,7 +3530,7 @@
                                 Antenna = rx_desc->desc_87.antenna;
 #endif
 				if( ((stats.rate <= 22) && (stats.rate != 12) && (stats.rate != 18))\
-						|| (stats.rate == 44) )//need to translate to real rate here
+						|| (stats.rate == 44) )
 					bCckRate= true;
 				if (!bCckRate)
 				{
@@ -4133,19 +3548,15 @@
 				SignalStrength = (SignalStrength*75)/100 + 25;
 				stats.signalstrength = (u8)SignalStrength;
 
-				//				skb_put(skb,flen-4);
-				//calculate link quality end
 #endif
 				
 				skb = dev_alloc_skb(flen-4);
-				//skb_reserve(skb,2);
 				if(skb){
 
 					struct ieee80211_hdr *hdr;
 					hdr = (struct ieee80211_hdr *)skb->data;
 					if(hdr->addr3[5] == 0xE3)
 					{
-					//	printk("=====> %d\n", stats.signalstrength);
 					}
 					memcpy(skb_put(skb,flen-4),
 							rx_urb->transfer_buffer,flen -4);
@@ -4174,7 +3585,6 @@
 	else DMESG("RX process aborted due to explicit shutdown");
 }
 
-// based on ipw2200 driver */
 int rtl8180_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -4200,7 +3610,6 @@
 }
 
 
-//void rtl8180_irq_rx_tasklet(struct r8180_priv *priv)
 #if 0
 void rtl8187_rx_isr(struct urb *rx_urb, struct pt_regs *regs)
 {
@@ -4209,33 +3618,27 @@
 	struct net_device *dev = (struct net_device*)rx_urb->context;
 #else
 	struct net_device *dev = (struct net_device*)rx_urb->context;
-	//struct urb *rx_urb = priv->rxurb_task;
 	struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
 	int status,len,flen;
 	struct sk_buff *skb;
-	//u32 *desc;
 	u8 *desc;
 	u8 signal,quality,rate;
 	
-	//DMESG("rtl8187_rx_isr");
 	
 	struct ieee80211_rx_stats stats = {
 		.signal = 0,
 		.noise = -98,
 		.rate = 0,
-	//	.mac_time = jiffies,
 		.freq = IEEE80211_24GHZ_BAND,
 	};
 
 	
-	//DMESG("RX %d ",rx_urb->status);
 	status = rx_urb->status;
 	if(status == 0){
 		
 		len = rx_urb->actual_length;
-	//	len = len - 4 - 15 - 1; // CRC, DESC, SEPARATOR*/ 
-		len -= 4*4;// 4 dword and 4 byte CRC */
+		len -= 4*4;
 #if 0	
 		desc = (u32*)(rx_urb->transfer_buffer + len);
 		
@@ -4243,18 +3646,13 @@
 		
 		if( flen <= rx_urb->actual_length){
 		
-			//stats.signal = (desc[1] & 0x7f00)>>8;
-			//stats.noise = desc[1] &0xff;
 			signal=(desc[1]& (0xff0000))>>16;
-			signal=(signal&0xfe)>>1;	// Modify by hikaru 6.6
+			signal=(signal&0xfe)>>1;	
 				
 			quality=(desc[1] & (0xff));
 			
 			rate=(desc[0] &((1<<23)|(1<<22)|(1<<21)|(1<<20)))>>20;
-		//	printk(KERN_INFO "rate is %d!\n",rate);	
 			stats.rate = rtl8180_rate2rate(rate);	
-		//	printk(KERN_INFO "stats.rate is %d!\n",stats.rate);
-			//stats.rate = desc[0] >> 20 & 0xf;
 			stats.mac_time[0] = desc[2];
 			stats.mac_time[1] = desc[3];
 #endif
@@ -4265,26 +3663,18 @@
 		
 		if( flen <= rx_urb->actual_length){
 		
-			//stats.signal = (desc[1] & 0x7f00)>>8;
-			//stats.noise = desc[1] &0xff;
 			signal=(desc[6]& 0xfe)>>1;
-			//signal=(signal&0xfe)>>1;	// Modify by hikaru 6.6
 				
 			quality=desc[4] & 0xff;
 			
-			//rate=(desc[2] &((1<<7)|(1<<6)|(1<<5)|(1<<4)))>>4;
 			rate=(desc[2] & 0xf0)>>4;
-		//	printk(KERN_INFO "rate is %d!\n",rate);	
 			stats.rate = rtl8180_rate2rate(rate);	
-		//	printk(KERN_INFO "stats.rate is %d!\n",stats.rate);
-			//stats.rate = desc[0] >> 20 & 0xf;
 			stats.mac_time[0] = desc[8] + (desc[9]<<8) + (desc[10]<<16) + (desc[11]<<24);   
 			stats.mac_time[1] = desc[12] + (desc[13]<<8) + (desc[14]<<16) + (desc[15]<<24);   
 
 			
-			//calculate link quality begin
 			if(!rtl8180_IsWirelessBMode(stats.rate) ) 
-			{ // OFDM rate.
+			{ 
 				if(signal>90)
 					signal=90;
 				else if(signal<25)
@@ -4292,7 +3682,7 @@
 				signal = (90-signal)*100/65;
 			}
 			else
-			{ // CCK rate.
+			{ 
 				if(signal>95)
 					signal = 95;
 				else if(signal<30)
@@ -4300,17 +3690,12 @@
 				signal =(95-signal )*100/65;
 			}
 			priv->wstats.qual.level = signal;
-		//	printk(KERN_INFO "signal is %d!\n",signal);
 			if(quality > 64)
 				priv ->wstats.qual.qual = 0;
 			else
-				priv ->wstats.qual.qual = ((64-quality) * 100) / 64;  // SQ value is the SIGNAL_QUALITY returned to IORequest, 
-						//and this value only appear when STA is associated to AP or 
-						// STA is in IBSS mode
-		//	printk(KERN_INFO "quality is %d!\n",priv->wstats.qual.qual);
+				priv ->wstats.qual.qual = ((64-quality) * 100) / 64;  
 			priv->wstats.qual.noise = 100 - priv ->wstats.qual.qual;
 			priv->wstats.qual.updated = 7;
-			//calculate link quality end 
 			skb = dev_alloc_skb(flen-4);
 			if(skb){ 
 			memcpy(skb_put(skb,flen-4),
@@ -4324,8 +3709,6 @@
 			
 			#endif
 			priv->stats.rxok++;
-		//	priv->rxskb = skb;
-		//	priv->tempstats = &stats;
 
 			if(!ieee80211_rx(priv->ieee80211, 
 				skb, &stats))
@@ -4347,14 +3730,20 @@
      ---------------------------- USB_STUFF---------------------------
 *****************************************************************************/
 
-
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static int __devinit rtl8187_usb_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
+#else
+static void * __devinit rtl8187_usb_probe(struct usb_device *udev,
+			                unsigned int ifnum,
+			          const struct usb_device_id *id)
+#endif
 {
-//	unsigned long ioaddr = 0;
 	struct net_device *dev = NULL;
 	struct r8180_priv *priv= NULL;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct usb_device *udev = interface_to_usbdev(intf);
+#endif
 
 	dev = alloc_ieee80211(sizeof(struct r8180_priv));
 
@@ -4362,18 +3751,22 @@
 	SET_MODULE_OWNER(dev);
 #endif
 
-	usb_set_intfdata(intf, dev);	
-	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	usb_set_intfdata(intf, dev);		
 	SET_NETDEV_DEV(dev, &intf->dev);
+#endif
 
 	priv = ieee80211_priv(dev);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 
 	priv->ieee80211 = netdev_priv(dev);
+#else
+	priv->ieee80211 = (struct ieee80211_device *)dev->priv;
+#endif
 	priv->dev = dev;
 	priv->udev=udev;
 	
 	dev->open = rtl8180_open;
 	dev->stop = rtl8180_close;
-	//dev->hard_start_xmit = rtl8180_8023_hard_start_xmit;
 	dev->tx_timeout = tx_timeout;
 	dev->wireless_handlers = &r8180_wx_handlers_def;
 	dev->do_ioctl = rtl8180_ioctl;
@@ -4391,11 +3784,9 @@
 	if (dev_alloc_name(dev, ifname) < 0){
                 DMESG("Oops: devname already taken! Trying wlan%%d...\n");
 		ifname = "wlan%d";
-		//ifname = "ath%d";
 		dev_alloc_name(dev, ifname);
         }
 	
-//	dev->open=rtl8180_init;
 	
 	if(rtl8180_init(dev)!=0){ 
 		DMESG("Initialization failed");
@@ -4409,41 +3800,54 @@
 	
 	rtl8180_proc_init_one(dev);
 
-//lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	gpio_change_polling((unsigned long) dev);
 #endif
-//	netif_device_attach(dev);
 	
 	DMESG("Driver probe completed\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return dev;
+#else
 	return 0;	
-
+#endif
 	
 fail:
 	free_ieee80211(dev);
 		
 	DMESG("wlan driver load failed\n");
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
+	return NULL;
+#else
 	return -ENODEV;
+#endif
 	
 }
 
-
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0) 
 static void __devexit rtl8187_usb_disconnect(struct usb_interface *intf)
+#else 
+static void __devexit rtl8187_usb_disconnect(struct usb_device *udev, void *ptr)
+#endif
 {
 	struct r8180_priv *priv;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = usb_get_intfdata(intf);
+#else
+	struct net_device *dev = (struct net_device *)ptr;
+#endif
  	if(dev){
 		
 		unregister_netdev(dev);
 		
 		priv=ieee80211_priv(dev);
 	
-//lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
      		del_timer_sync(&priv->gpio_polling_timer);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		cancel_delayed_work(&priv->ieee80211->GPIOChangeRFWorkItem);
 #endif
+#endif
 		
 		rtl8180_proc_remove_one(dev);
 		
@@ -4458,9 +3862,7 @@
 		mdelay(10);
 
 	}
-//	pci_disable_device(pdev);
 
-//	netif_device_detach(dev);
 
 	free_ieee80211(dev);
 	DMESG("wlan driver removed\n");
@@ -4502,15 +3904,6 @@
 }
 
 
-//
-//	Description:	
-//		Change ZEBRA's power state.
-//
-//	Assumption:	
-//		This function must be executed in PASSIVE_LEVEL.
-//
-//	050823, by rcnjko.
-//
 bool SetZebraRFPowerState8187(
 	struct net_device *dev,
 	RT_RF_POWER_STATE	eRFPowerState
@@ -4521,80 +3914,55 @@
 	bool			bResult = true;
 	int				i;
 
-	//u16			u2bTFPC = 0;
-	//u8			u1bTmp;
 	
-	//printk("Into function %s\n",__FUNCTION__);
 
-	// Set EEM0 and EEM1 in 9346CR.
 	btCR9346 = read_nic_byte(dev, CR9346);
 	write_nic_byte(dev, CR9346, (btCR9346|0xC0) );
-	// Set PARM_En in Config3.
 	btConfig3 = read_nic_byte(dev, CONFIG3);
 	write_nic_byte(dev, CONFIG3, (btConfig3|CONFIG3_PARM_En) );
 
-	// <NOTE> BB and RF related operations:
-	// 1. Jackie: MAC.54 and MAC.60 of 8187 are different with that of 8185.
 	switch(eRFPowerState)
 	{
 	case eRfOn:
 		DMESG("Now Radio On");
-		//write_nic_dword(dev,  PhyMuxPar, 0x3dc00002); // Asked for by SD3 ED. 2006.05.12, by rcnjko.
 		write_nic_dword(dev,  0xff94, 0x3dc00002);
 		write_nic_dword(dev,  ANAPARAM, ANAPARM_ON);
 		write_nic_dword(dev,   ANAPARAM2, ANAPARM2_ON);
 		write_nic_byte(dev, CONFIG4, (priv->RFProgType));
 
-		//RF_WriteReg(Adapter, 0x4, 0x9FF);
 		write_rtl8225(dev, 0x4, 0x9FF);
 		break;
 
 	case eRfSleep:
 		for(i = 0; i < 500; i++)
-		{ // Make sure TX FIFO is empty befor turn off RFE pwoer.
+		{ 
 			if(read_nic_byte(dev, TFPC) == 0)
 				break;
 			else
 				udelay(10);
 		}
-		write_rtl8225(dev, 0x4, 0xDFF); // Turn off RF first to prevent BB lock up, suggested by PJ, 2006.03.03.
+		write_rtl8225(dev, 0x4, 0xDFF); 
 		write_nic_byte(dev, CONFIG4, (priv->RFProgType|Config4_PowerOff));
-		//PlatformEFIOWrite4Byte(Adapter, PhyMuxPar, 0x3d000002); // SD3 ED: On 8187 minicard, CCK is still work even RF off, so turn off CCCK/OFDM here. 2006.05.12, by rcnjko.
 		write_nic_dword(dev,  0xff94, 0x3d000002);
 		
-		//
-		// 061122, rcnjko: 
-		// Asked for by SD1 William to save more power for Liteon+Arima minicard case.
-		//
-		// 070130, rcnjko:
-		// Turn ON PLL for Liteon+Gateway laptop will encouter Tx stuck.
-		//
-		write_nic_dword(dev, ANAPARAM, 0xa00faa59); // Turn off A/D D/A power but don't turn off PLL to prevent 8187 tx stuck, suggested by Jackie, 2005.09.08, by rcnjko.
+		write_nic_dword(dev, ANAPARAM, 0xa00faa59); 
 		write_nic_dword(dev, ANAPARAM2, ANAPARM2_OFF);
 		break;
 
 	case eRfOff:
 		DMESG("Now Radio Off");
 		for(i = 0; i < 500; i++)
-		{ // Make sure TX FIFO is empty befor turn off RFE pwoer.
+		{ 
 			if(read_nic_byte(dev, TFPC) == 0)
 				break;
 			else
 				udelay(10);
 		}
-		write_rtl8225(dev, 0x4, 0x1FF); // Turn off RF first to prevent BB lock up, suggested by PJ, 2006.03.03.
+		write_rtl8225(dev, 0x4, 0x1FF); 
 		write_nic_byte(dev, CONFIG4, (priv->RFProgType|Config4_PowerOff));
-		//PlatformEFIOWrite4Byte(Adapter, PhyMuxPar, 0x3d000002); // SD3 ED: On 8187 minicard, CCK is still work even RF off, so turn off CCCK/OFDM here. 2006.05.12, by rcnjko.
 		write_nic_dword(dev,  0xff94, 0x3d000002);
 		
-		//
-		// 061122, rcnjko: 
-		// Asked for by SD1 William to save more power for Liteon+Arima minicard case.
-		//
-		// 070130, rcnjko:
-		// Turn ON PLL for Liteon+Gateway laptop will encouter Tx stuck.
-		//
-		write_nic_dword(dev, ANAPARAM,  0xa00faa59); // Turn off A/D D/A power but don't turn off PLL to prevent 8187 tx stuck, suggested by Jackie, 2005.09.08, by rcnjko.
+		write_nic_dword(dev, ANAPARAM,  0xa00faa59); 
 		write_nic_dword(dev, ANAPARAM2, ANAPARM2_OFF);
 		break;
 
@@ -4604,49 +3972,34 @@
 		break;
 	}
 
-	// Clear PARM_En in Config3.
 	btConfig3 &= ~(CONFIG3_PARM_En);
 	write_nic_byte(dev, CONFIG3, btConfig3);
-	// Clear EEM0 and EEM1 in 9346CR.
 	btCR9346 &= ~(0xC0);
 	write_nic_byte(dev, CR9346, btCR9346);
 
 	if(bResult)
 	{
-		// Update current RF state variable.
 		priv->eRFPowerState = eRFPowerState;
 #ifdef LED
 		switch(priv->eRFPowerState)
 		{
 		case eRfOff:
 
-			//
-			//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
-			//
 			if(priv->RfOffReason==BIT28)
 			{
-				//priv->ieee80211->ieee80211_led_contorl(dev,LED_CTL_NO_LINK); 
 			}
 			else
 			{
-				// Turn off LED if RF is not ON.
 				priv->ieee80211->ieee80211_led_contorl(dev,LED_CTL_POWER_OFF); 
 			}
 			break;
 
 		case eRfOn:
-			// Turn on RF we are still linked, which might happen when 
-			// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
-//			if( pMgntInfo->bMediaConnect == TRUE )
-//			{
-			//	printk("Now LED ON!\n");
 			if(priv->up == 1)
 				priv->ieee80211->ieee80211_led_contorl(dev,LED_CTL_POWER_ON); 
-//			}
 			break;
 
 		default:
-			// do nothing.
 			break;
 		}
 #endif
@@ -4656,13 +4009,6 @@
 }
 
 
-//	Description: 
-//		Chang RF Power State.
-//		Note that, only MgntActSet_RF_State() is allowed to set HW_VAR_RF_STATE.
-//
-//	Assumption:
-//		PASSIVE LEVEL.
-//
 bool
 SetRFPowerState(
 	struct net_device *dev, 
@@ -4672,7 +4018,6 @@
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	bool			bResult = false;
 
-//	DMESG("SetRFPowerState(): eRFPowerState(%d)\n", eRFPowerState);
 	if(eRFPowerState == priv->eRFPowerState)
 	{
 		DMESG("SetRFPowerState(): discard the request for eRFPowerState(%d) is the same.", eRFPowerState);
@@ -4681,9 +4026,8 @@
 
 	switch(priv->rf_chip)
 	{
-		case RF_ZEBRA:// 8187L
+		case RF_ZEBRA:
 		case RF_ZEBRA2:
-			//bResult = SetZebraRFPowerState8187B(dev, eRFPowerState);
 			bResult = SetZebraRFPowerState8187(dev, eRFPowerState);
 			break;
 
@@ -4691,7 +4035,6 @@
 			printk("SetRFPowerState8185(): unknown RFChipID: 0x%X!!!\n", priv->rf_chip);
 			break;;
 	}
-//	DMESG("SetRFPowerState(): bResult(%d)", bResult);
 
 	return bResult;
 }
@@ -4708,30 +4051,21 @@
 	u16				RFWaitCounter = 0;
 	unsigned long flag;
 	
-	//DMESG("MgntActSet_RF_State(): StateToSet(%d), ChangeSource(0x%x)",StateToSet, ChangeSource);
-	//
-	// Prevent the race condition of RF state change. By Bruce, 2007-11-28.
-	// Only one thread can change the RF state at one time, and others should wait to be executed.
-	//
 
 	while(true)
 	{
-//		down(&priv->rf_state);
 		spin_lock_irqsave(&priv->rf_ps_lock,flag);
 		if(priv->RFChangeInProgress)
 		{
-//			up(&priv->rf_state);
 			printk("MgntActSet_RF_State(): RF Change in progress! Wait to set..StateToSet(%d).\n", StateToSet);
 			spin_unlock_irqrestore(&priv->rf_ps_lock,flag);			
-			// Set RF after the previous action is done. 
 			while(priv->RFChangeInProgress)
 			{
 				RFWaitCounter ++;
 				printk("MgntActSet_RF_State(): Wait 1 ms (%d times)...\n", RFWaitCounter);
-				udelay(1000); // 1 ms
+				udelay(1000); 
 
-				// Wait too long, return FALSE to avoid to be stuck here.
-				if(RFWaitCounter > 1000) // 1sec
+				if(RFWaitCounter > 1000) 
 				{
 					printk("MgntActSet_RF_State(): Wait too long to set RF\n");
 					return false;
@@ -4741,7 +4075,6 @@
 		else
 		{
 			priv->RFChangeInProgress = true;
-//			up(&priv->rf_state);
 			spin_unlock_irqrestore(&priv->rf_ps_lock,flag);
 			break;
 		}
@@ -4752,10 +4085,6 @@
 	switch(StateToSet) 
 	{
 	case eRfOn:
-		//
-		// Turn On RF no matter the IPS setting because we need to update the RF state to Ndis under Vista, or
-		// the Windows does not allow the driver to perform site survey any more. By Bruce, 2007-10-02. 
-		//
 		priv->RfOffReason &= (~ChangeSource);
 
 		if(! priv->RfOffReason)
@@ -4773,27 +4102,9 @@
 		break;
 
 	case eRfOff:
-		 	// 070125, rcnjko: we always keep connected in AP mode.
 			if (priv->RfOffReason > RF_CHANGE_BY_IPS)
 			{
-				//
-				// 060808, Annie: 
-				// Disconnect to current BSS when radio off. Asked by QuanTa.
-				// 
-
-				//
-				// Calling MgntDisconnect() instead of MgntActSet_802_11_DISASSOCIATE(),
-				// because we do NOT need to set ssid to dummy ones.
-				// Revised by Roger, 2007.12.04.
-				//
-//by amy not supported
-//				MgntDisconnect( dev, disas_lv_ss );	
-				// Clear content of bssDesc[] and bssDesc4Query[] to avoid reporting old bss to UI. 
-				// 2007.05.28, by shien chang.
-//				PlatformZeroMemory( pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC );
-//				pMgntInfo->NumBssDesc = 0;
-//				PlatformZeroMemory( pMgntInfo->bssDesc4Query, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC );
-//				pMgntInfo->NumBssDesc4Query = 0;
+
 			}
 		
 		ieee80211_disassociate(priv->ieee80211);				
@@ -4813,24 +4124,15 @@
 
 	if(bActionAllowed)
 	{
-		//DMESG("MgntActSet_RF_State(): Action is allowed.... ");
-		//DMESG("MgntActSet_RF_State(): StateToSet(%d), RfOffReason(%#X)", StateToSet, priv->RfOffReason);
-                // Config HW to the specified mode.
 		SetRFPowerState(dev, StateToSet);
-		// Turn on RF.
 		if(StateToSet == eRfOn) 
 		{				
-//			HalEnableRx8185Dummy(dev);
 			if(bConnectBySSID)
 			{	
-			// by amy not supported
-//				MgntActSet_802_11_SSID(Adapter, Adapter->MgntInfo.Ssid.Octet, Adapter->MgntInfo.Ssid.Length, TRUE );
 			}
 		}
-		// Turn off RF.
 		else if(StateToSet == eRfOff)
 		{		
-//			HalDisableRx8185Dummy(dev);
 		}		
 	}
 	else
@@ -4838,45 +4140,38 @@
 		printk("MgntActSet_RF_State(): Action is rejected.... StateToSet(%d), ChangeSource(%#X), RfOffReason(%#X)\n", StateToSet, ChangeSource, priv->RfOffReason);
 	}
 
-	// Release RF spinlock
-//	down(&priv->rf_state);
 	spin_lock_irqsave(&priv->rf_ps_lock,flag);
 	priv->RFChangeInProgress = false;
-//	up(&priv->rf_state);
 	spin_unlock_irqrestore(&priv->rf_ps_lock,flag);
 	return bActionAllowed;
 }
-//by amy for ps
 
 
 #ifdef POLLING_METHOD_FOR_RADIO
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void GPIOChangeRFWorkItemCallBack(struct work_struct *work)
 {
-	//struct delayed_work *dwork = container_of(work, struct delayed_work, work);
-	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, GPIOChangeRFWorkItem.work);
-	struct net_device *dev = ieee->dev;
+	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
+        struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,GPIOChangeRFWorkItem);
+        struct net_device *dev = ieee->dev;
 	struct r8180_priv *priv = ieee80211_priv(dev);
 #else
-void GPIOChangeRFWorkItemCallBack(struct ieee80211_device *ieee)
+void GPIOChangeRFWorkItemCallBack(struct net_device *dev)
 {
-	struct net_device *dev = ieee->dev;
 	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct ieee80211_device *ieee = priv->ieee80211;
 #endif
 
-//	u16 tmp2byte;
 	u8 tmp1byte;
-//	u8 btPSR;
-//	u8 btConfig0;
 	RT_RF_POWER_STATE	eRfPowerStateToSet;
 	bool 	bActuallySet=false;
 
 	char *argv[3];
-        static char *RadioPowerPath = "/etc/acpi/events/RadioPower.sh";
+        static char *RadioPowerPath = "/etc/RadioPower.sh";
         static char *envp[] = {"HOME=/", "TERM=linux", "PATH=/usr/bin:/bin", NULL};
 
 #if 0	
-	if(priv->up == 0)//driver stopped
+	if(priv->up == 0)
 		{
 			printk("\nDo nothing...");
 			goto out;
@@ -4885,27 +4180,16 @@
 #endif
 		{
 			
-			// Get RF power state to set.if Driver isn't stopped, we poll GPIO1
 
-			//set 0x91 B1= 0	// 1: for output enable; 0: otherwise.
-			// (William says) Note that, it will cause unstable if we set 
-			// output enable 1 but not to write it. Annie, 2005-12-12.
 			tmp1byte = read_nic_byte(dev,GPE);			
 			tmp1byte &= ~BIT1;
 			write_nic_byte(dev,GPE,tmp1byte);
 
-			//read  0x92 B1(read GPIO1)
 			tmp1byte = read_nic_byte(dev,GPI);
-			//turn on or trun off RF according to the value of GPIO1 
 		
 			eRfPowerStateToSet = (tmp1byte&BIT1) ?  eRfOn : eRfOff;			
 			
-			//lzm just for test
-			//eRfPowerStateToSet = ((priv->iwpriv_radio_on)&(tmp1byte&BIT1))?  eRfOn : eRfOff;			
-			//eRfPowerStateToSet = (priv->iwpriv_radio_on)? eRfOn : eRfOff;			
 
-			//printk("GPIO1:%d,iwpriv_radio_on: %d, eRfPowerStateToSet: %d, bHwRadioOff:%d\n",
-			//tmp1byte,priv->iwpriv_radio_on,eRfPowerStateToSet,priv->ieee80211->bHwRadioOff);
 			if((priv->ieee80211->bHwRadioOff == true) && (eRfPowerStateToSet == eRfOn)){
 				priv->ieee80211->bHwRadioOff = false;
 				bActuallySet = true;
@@ -4924,14 +4208,10 @@
 			{
 				MgntActSet_RF_State(dev, eRfPowerStateToSet, RF_CHANGE_BY_HW);
 
-				// To update the UI status for Power status changed */
                                 if(priv->ieee80211->bHwRadioOff == true)
                                         argv[1] = "RFOFF";
                                 else{
-                                        //if(!priv->RfOffReason)
                                                 argv[1] = "RFON";
-                                        //else
-                                        //      argv[1] = "RFOFF";
                                 }
                                 argv[0] = RadioPowerPath;
                                 argv[2] = NULL;
@@ -4945,8 +4225,14 @@
 void gpio_change_polling(unsigned long data)
 {
     struct r8180_priv* priv = ieee80211_priv((struct net_device *)data);
-	
-        queue_work(priv->ieee80211->wq,(void *)&priv->ieee80211->GPIOChangeRFWorkItem);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20) 
+		queue_delayed_work(priv->ieee80211->wq,&priv->ieee80211->GPIOChangeRFWorkItem,0);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		queue_work(priv->ieee80211->wq,&priv->ieee80211->GPIOChangeRFWorkItem);
+#else	
+		schedule_task(&priv->ieee80211->GPIOChangeRFWorkItem);
+#endif	
 
 	mod_timer(&priv->gpio_polling_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
 }
diff -ruN rtl8187l_orig/rtl8187/r8187.h rtl8187l/rtl8187/r8187.h
--- rtl8187l_orig/rtl8187/r8187.h	2011-01-02 18:14:31.039499000 +0100
+++ rtl8187l/rtl8187/r8187.h	2009-06-26 09:07:43.841770000 +0200
@@ -34,21 +34,19 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-//#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/netdevice.h>
-//#include <linux/pci.h>
 #include <linux/usb.h>
 #include <linux/etherdevice.h>
 #include <linux/delay.h>
-#include <linux/rtnetlink.h>	//for rtnl_lock()
+#include <linux/rtnetlink.h>	
 #include <linux/wireless.h>
 #include <linux/timer.h>
-#include <linux/proc_fs.h>	// Necessary because we use the proc fs
+#include <linux/proc_fs.h>	
 #include <linux/if_arp.h>
 #include <linux/random.h>
 #include <linux/version.h>
@@ -67,7 +65,6 @@
 #endif
 #include "r8180_hw.h"
 
-//added for HW security, john.0629
 #define FALSE 0
 #define TRUE 1
 #define MAX_KEY_LEN     61
@@ -187,12 +184,6 @@
 typedef struct Stats
 {
 	unsigned long txrdu;
-//	unsigned long rxrdu;
-	//unsigned long rxnolast;
-	//unsigned long rxnodata;
-//	unsigned long rxreset;
-//	unsigned long rxwrkaround;
-//	unsigned long rxnopointer;
 	unsigned long rxok;
 	unsigned long rxurberr;
 	unsigned long rxstaterr;
@@ -200,34 +191,28 @@
 	unsigned long txnpdrop;
 	unsigned long txresumed;
 	unsigned long rxerr;
-//	unsigned long rxoverflow;
 	unsigned long rxint;
 	unsigned long txnpokint;
 	unsigned long txhpokint;
 	unsigned long txhperr;
-//	unsigned long ints;
-//	unsigned long shints;
 	unsigned long txoverflow;
-//	unsigned long rxdmafail;
 	unsigned long txok;
 	unsigned long txerr;
 	unsigned long txretry;
-//	unsigned long txbeacon;
 	unsigned long txbeaconerr;
 	unsigned long txbeaconok;
 	unsigned long txlpokint;
 	unsigned long txlpdrop;
 	unsigned long txlperr;
 	unsigned long txdatapkt;
-	unsigned long rxretry;//retry number  tony 20060601
-	unsigned long rxcrcerrmin;//crc error (0-500) 
-	unsigned long rxcrcerrmid;//crc error (500-1000)
-	unsigned long rxcrcerrmax;//crc error (>1000)
-	unsigned long rxicverr;//ICV error
+	unsigned long rxretry;
+	unsigned long rxcrcerrmin;
+	unsigned long rxcrcerrmid;
+	unsigned long rxcrcerrmax;
+	unsigned long rxicverr;
 
 	unsigned long txbeaconokint;
 	unsigned long txbeacondrop;
-//	unsigned long txbeaconerr;
 } Stats;
 
 typedef struct 	ChnlAccessSetting {
@@ -253,16 +238,12 @@
 }RT_RF_POWER_STATE;
 typedef	enum _RT_PS_MODE	
 {
-	eActive,	// Active/Continuous access.
-	eMaxPs,		// Max power save mode.
-	eFastPs		// Fast power save mode.
+	eActive,	
+	eMaxPs,		
+	eFastPs		
 }RT_PS_MODE;
-//
-// Three wire mode.
-//
 #define IC_DEFAULT_THREE_WIRE	 0
 #define SW_THREE_WIRE		 1
-//RTL818xB
 #define SW_THREE_WIRE_BY_8051	 2
 #define HW_THREE_WIRE		 3
 #define HW_THREE_WIRE_BY_8051    4
@@ -275,84 +256,59 @@
 	struct ieee80211_device *ieee80211;
 	struct net_device *dev;
 
-	short card_8187; // 0: rtl8180, 1:rtl8185 V B/C, 2:rtl8185 V D */	
-	short card_8187_Bversion; // if TCR reports card V B/C this discriminates */
-	short card_8185; // O: rtl8180, 1:rtl8185 V B/C, 2:rtl8185 V D */
-	short card_8185_Bversion; // if TCR reports card V B/C this discriminates */
-	short phy_ver; // meaningful for rtl8225 1:A 2:B 3:C */
+	short card_8187; 
+	short card_8187_Bversion; 
+	short card_8185; 
+	short card_8185_Bversion; 
+	short phy_ver; 
 	short enable_gpio0;
 	enum card_type {PCI,MINIPCI,CARDBUS,USB}card_type;
 	short hw_plcp_len;
-	short plcp_preamble_mode; // 0:auto 1:short 2:long
+	short plcp_preamble_mode; 
 
 		
-//	spinlock_t irq_lock;
-//	spinlock_t irq_th_lock;
 	spinlock_t tx_lock;
 	spinlock_t ps_lock;
-//by amy for ps
 	spinlock_t rf_ps_lock;
-//by amy for ps
 	
 	u16 irq_mask;
-//	short irq_enabled;
 	short chan;
 	short sens;
 	short max_sens;
-	u8 chtxpwr[15]; //channels from 1 to 14, 0 not used
-	u8 chtxpwr_ofdm[15]; //channels from 1 to 14, 0 not used
+	u8 chtxpwr[15]; 
+	u8 chtxpwr_ofdm[15]; 
 	u8 cck_txpwr_base;
 	u8 ofdm_txpwr_base;
-	u8 challow[15]; //channels from 1 to 14, 0 not used
-	u8 channel_plan;  // it's the channel plan index
+	u8 challow[15]; 
+	u8 channel_plan;  
 
 	short up;
-	short crcmon; //if 1 allow bad crc frame reception in monitor mode
-//	short prism_hdr;
+	short crcmon; 
 	struct timer_list ps_timer;
-	short PS_timeout;//when ps set on ,if tx timeout ,this will be set 1
+	short PS_timeout;
 	
-//	struct timer_list scan_timer;
-	//short scanpending;
-	//short stopscan;
-//	spinlock_t scan_lock;
-//	u8 active_probe;
-	//u8 active_scan_num;
 	struct semaphore wx_sem;
 	struct semaphore power_sem;
-//	short hw_wep;
 		
-//	short digphy;
-//	short antb;
-//	short diversity;
-//	u8 cs_treshold;
-//	short rcr_csense;
 	short rf_chip;
-//	u32 key0[4];
 	short (*rf_set_sens)(struct net_device *dev,short sens);
 	void (*rf_set_chan)(struct net_device *dev,short ch);
 	void (*rf_close)(struct net_device *dev);
 	void (*rf_init)(struct net_device *dev);
 	void (*rf_wakeup)(struct net_device *dev);
 	void (*rf_sleep)(struct net_device *dev);
-	//short rate;
 	short promisc;	
-	//stats*/
 	struct Stats stats;
 	struct iw_statistics wstats;
 	struct proc_dir_entry *dir_dev;
 	
-	//RX stuff*/
-//	u32 *rxring;
-//	u32 *rxringtail;
-//	dma_addr_t rxringdma;
 	struct urb **rx_urb;
 	struct tx_urb_context tx_context[MAX_TX_URB];
 #ifdef THOMAS_BEACON
 	u32 *oldaddr;
 #endif
 #ifdef THOMAS_TASKLET
-	atomic_t irt_counter;//count for irq_rx_tasklet
+	atomic_t irt_counter;
 #endif
 #ifdef JACKSON_NEW_RX
         struct sk_buff **pp_rxskb;
@@ -360,20 +316,12 @@
 #endif
 	short  tx_urb_index;
 
-	//struct buffer *rxbuffer;
-	//struct buffer *rxbufferhead;
-	//int rxringcount;
-	//u16 rxbuffersize;
 	
-	//struct sk_buff *rx_skb; 
 
-	//short rx_skb_complete;
 
-	//u32 rx_prevlen;
 	atomic_t tx_lp_pending;
 	atomic_t tx_np_pending;
 #if 0	
-	//TX stuff*/
 	u32 *txlpring;
 	u32 *txhpring;
 	u32 *txnpring;
@@ -395,35 +343,23 @@
 	int txringcount;
 	int txbuffsize;
 
-	//struct tx_pendingbuf txnp_pending;
 	struct tasklet_struct irq_tx_tasklet;
 #endif
 	struct tasklet_struct irq_rx_tasklet;
 	struct urb *rxurb_task;
-//	u8 dma_poll_mask;
-	//short tx_suspend;
 	
-	// adhoc/master mode stuff */
 #if 0
 	u32 *txbeacontail;
 	dma_addr_t txbeaconringdma;
 	u32 *txbeaconring;
 	int txbeaconcount;
 #endif
-//	struct ieee_tx_beacon *beacon_buf;
-	//char *master_essid;
-//	dma_addr_t beacondmabuf;
-	//u16 master_beaconinterval;
-//	u32 master_beaconsize;
-	//u16 beacon_interval;
 	
-	//2 Tx Related variables
 	u16	ShortRetryLimit;
 	u16	LongRetryLimit;
 	u32	TransmitConfig;
-	u8	RegCWinMin;		// For turbo mode CW adaptive. Added by Annie, 2005-10-27.
+	u8	RegCWinMin;		
 
-	//2 Rx Related variables
 	u16	EarlyRxThreshold;
 	u32	ReceiveConfig;
 	u8	AcmControl;
@@ -433,51 +369,43 @@
 	u8 retry_data;
 	u8 retry_rts;
 	u16 rts;
-	u8 ps_sleep_finish;//1, finish hw sleep ,0 finish hw wakeup
+	u8 ps_sleep_finish;
 
-//by amy
-//        long            LastSignalStrengthInPercent;
-//        long            SignalStrength;
-//        long                SignalQuality;
         u8                      antenna_flag;
         bool                    flag_beacon;
-//by amy
 	u8		ScanAllowedNow;
-//by amy for rate adaptive
     struct timer_list rateadapter_timer;
     u16                                 LastRetryCnt;
         u16                                     LastRetryRate;
         unsigned long           LastTxokCnt;
         unsigned long           LastRxokCnt;
         u16                                     CurrRetryCnt;
-        //long                            RecvSignalPower;
         unsigned long           LastTxOKBytes;
         u8                                      LastFailTxRate;
         long                            LastFailTxRateSS;
         u8                                      FailTxRateCount;
         u32                             LastTxThroughput;
         unsigned long txokbytestotal;
-        //for up rate
         unsigned short          bTryuping;
-        u8                                      CurrTxRate;     //the rate before up
+        u8                                      CurrTxRate;     
         u16                                     CurrRetryRate;
         u16                                     TryupingCount;
         u8                                      TryDownCountLowData;
         u8                                      TryupingCountNoData;
 
         u8                  CurrentOperaRate;	
-//	struct work_struct reset_wq;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	struct work_struct rtl8180_hw_wakeup_wq;
+#else
+	struct tq_struct rtl8180_hw_wakeup_wq;
+#endif
 	short ack_tx_to_ieee;
 
-// lzm add for radio on/off 080917
 #ifdef POLLING_METHOD_FOR_RADIO
 	u8 iwpriv_radio_on;
 	u8 wlan_first_up_flag1;
 	struct timer_list gpio_polling_timer;
 #endif
-//by amy for rate adaptive	
-//by amy for power save
 	struct timer_list watch_dog_timer;
 	bool bInactivePs;
 	bool bSwRfProcessing;
@@ -487,28 +415,23 @@
 	bool RFChangeInProgress;
 	bool bInHctTest;
 	bool SetRFPowerStateInProgress;
-	//u8   RFProgType;
 	bool bLeisurePs;
 	RT_PS_MODE dot11PowerSaveMode;
 	u32 NumRxOkInPeriod;
 	u32 NumTxOkInPeriod;
 	u8 RegThreeWireMode;
 	bool ps_mode;
-//by amy for power save
-//by amy for DIG
 	bool bDigMechanism;
 	bool bCCKThMechanism;
 	u8   InitialGain;
 	u8   StageCCKTh;
 	u8   RegBModeGainStage;
-	u8   RegDigOfdmFaUpTh;	 //added by david, 2008.3.6
+	u8   RegDigOfdmFaUpTh;	 
 	u8   DIG_NumberFallbackVote;
 	u8   DIG_NumberUpgradeVote;
 	u16  CCKUpperTh;
 	u16  CCKLowerTh;
-	u32  FalseAlarmRegValue; //added by david, 2008.3.6	
-//by amy for DIG
-//{ added by david for high power, 2008.3.11
+	u32  FalseAlarmRegValue; 
 	int  UndecoratedSmoothedSS;
 	bool bRegHighPowerMechanism;
 	bool bToUpdateTxPwr;
@@ -516,16 +439,12 @@
 	u8   Z2HiPwrLowerTh;
 	u8   Z2RSSIHiPwrUpperTh;
 	u8   Z2RSSIHiPwrLowerTh;
-	// Current CCK RSSI value to determine CCK high power, asked by SD3 DZ, by Bruce, 2007-04-12.
 	u8   CurCCKRSSI;
 	bool bCurCCKPkt;
 	u32  wMacRegRfPinsOutput;
 	u32  wMacRegRfPinsSelect;
 	TR_SWITCH_STATE TrSwitchState;
-//}
-//{added by david for radio on/off
 	u8   radion;
-//}
 	struct 	ChnlAccessSetting  ChannelAccessSetting;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	struct work_struct reset_wq;
@@ -535,7 +454,6 @@
 
 
 #ifdef LED
-	// add for led controll */
 	u8		EEPROMCustomerID;
 	RT_CID_TYPE	CustomerID;
 	LED_8187	Gpio0Led;
@@ -544,19 +462,17 @@
 	u8			bEnableLedCtrl;
 	LED_STRATEGY_8187	LedStrategy;
 	u8			PsrValue;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	struct work_struct		Gpio0LedWorkItem;
 	struct work_struct		SwLed0WorkItem; 
 	struct work_struct		SwLed1WorkItem;	
+#else
+	struct tq_struct		Gpio0LedWorkItem;
+	struct tq_struct		SwLed0WorkItem; 
+	struct tq_struct		SwLed1WorkItem;	
+#endif
 #endif 
 
-#ifdef SW_ANTE_DIVERSITY
-
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)	
-//	struct delayed_work SwAntennaWorkItem;
-//#else
-//	struct work_struct SwAntennaWorkItem;
-//#endif	
-	
 	bool			bAntennaDiversityTimerIssued;
 	short antb;
 	short diversity;
@@ -568,37 +484,35 @@
 	u8					EEPROMDigitalPhy;
 	u32					EEPROMCSMethod;
 	u8					EEPROMGEPRFOffState;
-	// For HW antenna diversity, added by Roger, 2008.01.30.
-	u32			AdMainAntennaRxOkCnt;		// Main antenna Rx OK count. 
-	u32			AdAuxAntennaRxOkCnt;		// Aux antenna Rx OK count. 
-	bool			bHWAdSwitched;				// TRUE if we has switched default antenna by HW evaluation.
+	u32			AdMainAntennaRxOkCnt;		
+	u32			AdAuxAntennaRxOkCnt;		
+	bool			bHWAdSwitched;				
 	u8 EEPROMSwAntennaDiversity;
 	bool EEPROMDefaultAntenna1;
-	u8 RegSwAntennaDiversityMechanism;// 0:default from EEPROM, 1: disable, 2: enable.
+	u8 RegSwAntennaDiversityMechanism;
 	bool bSwAntennaDiverity;
-	u8 RegDefaultAntenna;// 0: default from EEPROM, 1: main, 2: aux. Added by Roger, 2007.11.05.
+	u8 RegDefaultAntenna;
 	bool bDefaultAntenna1;
 	u8 SignalStrength;
 	long Stats_SignalStrength;
-	long LastSignalStrengthInPercent; // In percentange, used for smoothing, e.g. Moving Average.
-	u8	 SignalQuality; // in 0-100 index. 
+	long LastSignalStrengthInPercent; 
+	u8	 SignalQuality; 
 	long Stats_SignalQuality;
-	long RecvSignalPower; // in dBm.
+	long RecvSignalPower; 
 	long Stats_RecvSignalPower;
-	u8	 LastRxPktAntenna;	// +by amy 080312 Antenn which received the lasted packet. 0: Aux, 1:Main. Added by Roger, 2008.01.25.
+	u8	 LastRxPktAntenna;	
 	u32 AdRxOkCnt;
-	long AdRxSignalStrength; // Rx signal strength for Antenna Diversity, which had been smoothing, its valid range is [0,100].	
-	u8 CurrAntennaIndex;			// Index to current Antenna (both Tx and Rx).
-	u8 AdTickCount;				// Times of SwAntennaDiversityTimer happened.
-	u8 AdCheckPeriod;				// # of period SwAntennaDiversityTimer to check Rx signal strength for SW Antenna Diversity. 
-	u8 AdMinCheckPeriod;			// Min value of AdCheckPeriod. 
-	u8 AdMaxCheckPeriod;			// Max value of AdCheckPeriod.  
-	long AdRxSsThreshold;			// Signal strength threshold to switch antenna.
-	long AdMaxRxSsThreshold;			// Max value of AdRxSsThreshold.
-	bool bAdSwitchedChecking;		// TRUE if we shall shall check Rx signal strength for last time switching antenna.
-	long AdRxSsBeforeSwitched;		// Rx signal strength before we swithed antenna.
+	long AdRxSignalStrength; 
+	u8 CurrAntennaIndex;			
+	u8 AdTickCount;				
+	u8 AdCheckPeriod;				
+	u8 AdMinCheckPeriod;			
+	u8 AdMaxCheckPeriod;			
+	long AdRxSsThreshold;			
+	long AdMaxRxSsThreshold;			
+	bool bAdSwitchedChecking;		
+	long AdRxSsBeforeSwitched;		
 	struct timer_list SwAntennaDiversityTimer;
-#endif
 
 }r8180_priv;
 
@@ -630,7 +544,6 @@
 void rtl8180_tx_enable(struct net_device *);
 
 void rtl8180_disassociate(struct net_device *dev);
-//void fix_rx_fifo(struct net_device *dev);
 void rtl8185_set_rf_pins_enable(struct net_device *dev,u32 a);
 
 void rtl8180_set_anaparam(struct net_device *dev,u32 a);
diff -ruN rtl8187l_orig/rtl8187/r8187_led.c rtl8187l/rtl8187/r8187_led.c
--- rtl8187l_orig/rtl8187/r8187_led.c	2011-01-02 18:14:31.047507000 +0100
+++ rtl8187l/rtl8187/r8187_led.c	2009-06-26 09:07:43.841770000 +0200
@@ -17,7 +17,6 @@
  * Jerry chuang <wlanfae@realtek.com>
 ******************************************************************************/
 
-//--------------------------Include File------------------------------------*/
 #include "../ieee80211/ieee80211.h"
 #include "r8180_hw.h"
 #include "r8187.h"
@@ -25,16 +24,6 @@
 #include "r8187_led.h"
 
 
-//
-//
-// Initialization function for Sw Leds controll. 
-// 
-// \param dev      The net device for this driver.
-// \return void.
-//
-// Note: 
-// 
-//
 
 void
 InitSwLeds(
@@ -44,10 +33,8 @@
 
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	u16	usValue;
-//	printk("========>%s()\n", __FUNCTION__);
 
-//	priv->CustomerID = RT_CID_87B_DELL; //by lizhaoming for DELL 2008.6.3
-	priv->CustomerID = RT_CID_DEFAULT; //just set to default now
+	priv->CustomerID = RT_CID_DEFAULT; 
 	priv->bEnableLedCtrl = 1;
 	priv->PsrValue = read_nic_byte(dev, PSR);
 	usValue = eprom_read(dev, EEPROM_SW_REVD_OFFSET >> 1);
@@ -55,8 +42,7 @@
 	DMESG("EEPROM Customer ID: %02X\n", priv->EEPROMCustomerID);
 
 	if(priv->CustomerID == RT_CID_DEFAULT)
-	{ // If we have not yet change priv->CustomerID in register, 
-	  // we initialzie it from that of EEPROM with proper translation, 2006.07.03, by rcnjko.
+	{ 
 		switch(priv->EEPROMCustomerID)
 		{
 		case EEPROM_CID_RSVD0:
@@ -77,7 +63,6 @@
 			break;
 	
 		default:
-			// Invalid value, so, we use default value instead.
 			priv->CustomerID = RT_CID_DEFAULT;
 			break;
 		}
@@ -109,39 +94,31 @@
 				&(priv->Gpio0Led), 
 				LED_PIN_GPIO0, 
 				Gpio0LedBlinkTimerCallback);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+	INIT_WORK(&priv->Gpio0LedWorkItem, (void*)Gpio0LedWorkItemCallback);
+
+	InitLed8187(dev,	&(priv->SwLed0), 	LED_PIN_LED0, SwLed0BlinkTimerCallback);
+	INIT_WORK(&priv->SwLed0WorkItem, 	(void*)SwLed0WorkItemCallback);
+
+	InitLed8187(dev,	&(priv->SwLed1), 	LED_PIN_LED1, SwLed1BlinkTimerCallback);
+	INIT_WORK(&priv->SwLed1WorkItem, 	(void*)SwLed1WorkItemCallback);
+
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 	INIT_WORK(&priv->Gpio0LedWorkItem,(void*)Gpio0LedWorkItemCallback, dev);
 
-	InitLed8187(dev,
-				&(priv->SwLed0), 
-				LED_PIN_LED0, 
-				SwLed0BlinkTimerCallback);
-	INIT_WORK(&priv->SwLed0WorkItem, 
-				(void*)SwLed0WorkItemCallback, dev);
-
-	InitLed8187(dev,
-				&(priv->SwLed1), 
-				LED_PIN_LED1, 
-				SwLed1BlinkTimerCallback);
-	INIT_WORK(&priv->SwLed1WorkItem, 
-				(void*)SwLed1WorkItemCallback, dev);
+	InitLed8187(dev,	&(priv->SwLed0), 	LED_PIN_LED0, SwLed0BlinkTimerCallback);
+	INIT_WORK(&priv->SwLed0WorkItem, 	(void*)SwLed0WorkItemCallback, dev);
+
+	InitLed8187(dev,	&(priv->SwLed1), 	LED_PIN_LED1, SwLed1BlinkTimerCallback);
+	INIT_WORK(&priv->SwLed1WorkItem, 	(void*)SwLed1WorkItemCallback, dev);
 #else
-INIT_WORK(&priv->Gpio0LedWorkItem, 
-				(void*)Gpio0LedWorkItemCallback);
+	tq_init(&priv->Gpio0LedWorkItem,(void*)Gpio0LedWorkItemCallback, dev);
+
+	InitLed8187(dev,	&(priv->SwLed0), 	LED_PIN_LED0, SwLed0BlinkTimerCallback);
+	tq_init(&priv->SwLed0WorkItem, 	(void*)SwLed0WorkItemCallback, dev);
 
-	InitLed8187(dev,
-				&(priv->SwLed0), 
-				LED_PIN_LED0, 
-				SwLed0BlinkTimerCallback);
-	INIT_WORK(&priv->SwLed0WorkItem, 
-				(void*)SwLed0WorkItemCallback);
-
-	InitLed8187(dev,
-				&(priv->SwLed1), 
-				LED_PIN_LED1, 
-				SwLed1BlinkTimerCallback);
-	INIT_WORK(&priv->SwLed1WorkItem, 
-				(void*)SwLed1WorkItemCallback);
+	InitLed8187(dev,	&(priv->SwLed1), 	LED_PIN_LED1, SwLed1BlinkTimerCallback);
+	tq_init(&priv->SwLed1WorkItem, 	(void*)SwLed1WorkItemCallback, dev);
 #endif
 }
 
@@ -152,7 +129,6 @@
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-//	printk("=========>%s In\n", __FUNCTION__);
 	DeInitLed8187(dev, &(priv->Gpio0Led));
 	DeInitLed8187(dev, &(priv->SwLed0));
 	DeInitLed8187(dev, &(priv->SwLed1));
@@ -165,7 +141,6 @@
 	LED_PIN_8187		LedPin,
 	void	* 		BlinkCallBackFunc)
 {
-//	printk("=========>%s In\n", __FUNCTION__);
 	pLed->LedPin = LedPin;
 
 	pLed->bLedOn = 0;
@@ -178,7 +153,6 @@
 	init_timer(&(pLed->BlinkTimer));
 	pLed->BlinkTimer.data = (unsigned long)dev;
 	pLed->BlinkTimer.function = BlinkCallBackFunc;
-	//PlatformInitializeTimer(dev, &(pLed->BlinkTimer), BlinkCallBackFunc);
 }
 
 void
@@ -186,10 +160,7 @@
 	struct net_device *dev, 
 	PLED_8187			pLed)
 {
-	//printk("=========>%s In\n", __FUNCTION__);
-	//PlatformCancelTimer(dev, &(pLed->BlinkTimer));
 	del_timer_sync(&(pLed->BlinkTimer));
-	// We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko.
 	pLed->bLedBlinkInProgress = 0;
 }
 
@@ -200,18 +171,9 @@
 )
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-//	printk("=========>%s In\n", __FUNCTION__);
 	if( priv->bEnableLedCtrl == 0)
 		return;
 
-//	if(	priv->eRFPowerState != eRfOn && 
-//		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX || 
-//		 LedAction == LED_CTL_SITE_SURVEY || 
-//		 LedAction == LED_CTL_LINK || 
-//		 LedAction == LED_CTL_NO_LINK) )
-//	{
-//		return;
-//	}
 
 	switch(priv->LedStrategy)
 	{
@@ -237,11 +199,6 @@
 }
 
 
-//
-//	Description:	
-//		Implement each led action for SW_LED_MODE0.
-//		This is default strategy.
-//
 void
 SwLedControlMode0(
 	struct net_device *dev,
@@ -251,8 +208,6 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	PLED_8187 pLed = &(priv->Gpio0Led);
 
-//	printk("===+++++++++++++++======>%s In\n", __FUNCTION__);
-	// Decide led state
 	switch(LedAction)
 	{
 	case LED_CTL_TX:
@@ -272,7 +227,6 @@
 		if( pLed->bLedBlinkInProgress == 0 )
 		{
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-		//	pLed->BlinkTimes = 10;
 		}
 		else
 		{
@@ -301,7 +255,6 @@
 		break;
 	}
 
-	// Change led state.
 	switch(pLed->CurrLedState)
 	{
 	case LED_ON:
@@ -311,13 +264,9 @@
 		}
 		break;
 
-	case LED_OFF://modified by lizhaoming 2008.6.23
-	//	if( pLed->bLedBlinkInProgress == 0 )
-	//	{
-	//		SwLedOff(dev, pLed);
-	//	}
+	case LED_OFF:
 	
-	if(pLed->bLedBlinkInProgress )/////////lizhaoming
+	if(pLed->bLedBlinkInProgress )
 		{
 			del_timer_sync(&(pLed->BlinkTimer));
 			pLed->bLedBlinkInProgress = false;
@@ -334,9 +283,7 @@
 			else
 				pLed->BlinkingLedState = LED_ON; 
 			
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_NORMAL_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer), jiffies + LED_BLINK_NORMAL_INTERVAL);
 		}
 		break;
 
@@ -344,14 +291,9 @@
 		if( pLed->bLedBlinkInProgress == 0 )
 		{
 			pLed->bLedBlinkInProgress = 1;
-		//	if( pLed->bLedOn )
 				pLed->BlinkingLedState = LED_OFF; 
-		//	else
-		//		pLed->BlinkingLedState = LED_ON;
 			
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_SLOWLY_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer), jiffies + LED_BLINK_SLOWLY_INTERVAL);
 		}
 		break;
 
@@ -368,11 +310,6 @@
 	}
 }
 
-//
-//	Description:	
-//		Implement each led action for SW_LED_MODE1.
-//		For example, this is applied by ALPHA.
-//
 void
 SwLedControlMode1(
 	struct net_device *dev,
@@ -382,7 +319,6 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	PLED_8187 pLed0 = &(priv->SwLed0);
 	PLED_8187 pLed1 = &(priv->SwLed1);
-//	printk("=====++++++++++++++++++++++====>%s In\n", __FUNCTION__);
 
 	switch(LedAction)
 	{
@@ -397,9 +333,7 @@
 			else
 				pLed0->BlinkingLedState = LED_ON; 
 
-			pLed0->BlinkTimer.expires = jiffies + LED_BLINK_NORMAL_INTERVAL;
-			add_timer(&(pLed0->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed0->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			mod_timer(&(pLed0->BlinkTimer),jiffies + LED_BLINK_NORMAL_INTERVAL);
 		}
 		break;
 
@@ -447,9 +381,7 @@
 			else
 				pLed0->BlinkingLedState = LED_ON;
 
-			pLed0->BlinkTimer.expires = jiffies + LED_BLINK_SLOWLY_INTERVAL;
-			add_timer(&(pLed0->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed0->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			mod_timer(&(pLed0->BlinkTimer),jiffies + LED_BLINK_SLOWLY_INTERVAL);
 		}
 		break;
 
@@ -458,12 +390,6 @@
 	}
 }
 
-//
-//	Description:	
-//		Implement each led action for SW_LED_MODE2, 
-//		which is customized for AzWave 8187 minicard.  
-//		2006.04.03, by rcnjko.
-//
 void
 SwLedControlMode2(
 	struct net_device *dev,
@@ -473,8 +399,6 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	PLED_8187 pLed = &(priv->Gpio0Led);
 
-//	printk("====+++++++++++++++++++++=====>%s In\n", __FUNCTION__);
-	// Decide led state
 	switch(LedAction)
 	{
 	case LED_CTL_TX:
@@ -491,9 +415,7 @@
 			else
 				pLed->BlinkingLedState = LED_ON; 
 
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_NORMAL_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_NORMAL_INTERVAL);
 		}
 		break;
 
@@ -502,31 +424,18 @@
 		{
 			pLed->bLedBlinkInProgress = 1;
 
-			//if(	dev->MgntInfo.mAssoc || 
-			//	dev->MgntInfo.mIbss )
-			//{
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 4;
-			//}
-			//else
-			//{
-			//	pLed->CurrLedState = LED_NO_LINK_BLINK;
-			//	pLed->BlinkTimes = 24;
-			//}
 
 			if( pLed->bLedOn )
 			{
 				pLed->BlinkingLedState = LED_OFF;
-				pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_ON_INTERVAL;
-				add_timer(&(pLed->BlinkTimer));
-				//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM2_BLINK_ON_INTERVAL);
+				mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_ON_INTERVAL);
 			}
 			else
 			{
 				pLed->BlinkingLedState = LED_ON; 
-				pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_OFF_INTERVAL;
-				add_timer(&(pLed->BlinkTimer));
-				//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM2_BLINK_OFF_INTERVAL);
+				mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_OFF_INTERVAL);
 			}
 		}
 		else
@@ -534,15 +443,6 @@
 			if(pLed->CurrLedState != LED_NO_LINK_BLINK)
 			{
 				pLed->CurrLedState = LED_SCAN_BLINK;
-				//if(	dev->MgntInfo.mAssoc || 
-				//	dev->MgntInfo.mIbss )
-				//{
-				//	pLed->CurrLedState = LED_SCAN_BLINK;
-				//}
-				//else
-				//{
-				//	pLed->CurrLedState = LED_NO_LINK_BLINK;
-				//}
 			}
 		}
 		break;
@@ -558,16 +458,12 @@
 			if( pLed->bLedOn )
 			{
 				pLed->BlinkingLedState = LED_OFF; 
-				pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_ON_INTERVAL;
-				add_timer(&(pLed->BlinkTimer));
-				//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM2_BLINK_ON_INTERVAL);
+				mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_ON_INTERVAL);
 			}
 			else
 			{
 				pLed->BlinkingLedState = LED_ON; 
-				pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_OFF_INTERVAL;
-				add_timer(&(pLed->BlinkTimer));
-				//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM2_BLINK_OFF_INTERVAL);
+				mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_OFF_INTERVAL);
 			}
 		}
 		else
@@ -598,12 +494,6 @@
 }
 
 
-//
-//	Description:	
-//		Implement each led action for SW_LED_MODE3, 
-//		which is customized for Sercomm Printer Server case. 
-//		2006.04.21, by rcnjko.
-//
 void
 SwLedControlMode3(
 	struct net_device *dev,
@@ -613,8 +503,6 @@
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	PLED_8187 pLed = &(priv->Gpio0Led);
 
-//	printk("=====+++++++++++++++++++====>%s In\n", __FUNCTION__);
-	// Decide led state
 	switch(LedAction)
 	{
 	case LED_CTL_TX:
@@ -631,9 +519,7 @@
 			else
 				pLed->BlinkingLedState = LED_ON; 
 
-			pLed->BlinkTimer.expires = jiffies + LED_CM3_BLINK_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM3_BLINK_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM3_BLINK_INTERVAL);
 		}
 		break;
 
@@ -650,9 +536,7 @@
 			else
 				pLed->BlinkingLedState = LED_ON; 
 
-			pLed->BlinkTimer.expires = jiffies + LED_CM3_BLINK_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM3_BLINK_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM3_BLINK_INTERVAL);
 		}
 		break;
 
@@ -692,9 +576,6 @@
 	}
 }
 
-//
-// Callback fuction of the timer, Gpio0Led.BlinkTimer.
-//
 void
 Gpio0LedBlinkTimerCallback(
 	unsigned long		data
@@ -703,15 +584,11 @@
 	struct net_device *dev = (struct net_device *)data;
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-//	printk("=========>%s In\n", __FUNCTION__);
 	PlatformSwLedBlink(dev, &(priv->Gpio0Led));
 }
 
 
 
-//
-// Callback fuction of the timer, SwLed0.BlinkTimer.
-//
 void
 SwLed0BlinkTimerCallback(
 	unsigned long		data
@@ -720,15 +597,11 @@
 	struct net_device *dev = (struct net_device *)data;
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-//	printk("=========>%s In\n", __FUNCTION__);
 	PlatformSwLedBlink(dev, &(priv->SwLed0));
 }
 
 
 
-//
-// Callback fuction of the timer, SwLed1.BlinkTimer.
-//
 void
 SwLed1BlinkTimerCallback(
 	unsigned long		data
@@ -737,7 +610,6 @@
 	struct net_device *dev = (struct net_device *)data;
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-//	printk("=========>%s In\n", __FUNCTION__);
 	PlatformSwLedBlink(dev, &(priv->SwLed1));
 }
 
@@ -749,19 +621,30 @@
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-//	printk("=========>%s In\n", __FUNCTION__);
 	switch(pLed->LedPin)
 	{
 	case LED_PIN_GPIO0:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		schedule_work(&(priv->Gpio0LedWorkItem));
+#else
+		schedule_task(&(priv->Gpio0LedWorkItem));
+#endif		
 		break;
 
 	case LED_PIN_LED0:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		schedule_work(&(priv->SwLed0WorkItem));
+#else
+		schedule_task(&(priv->SwLed0WorkItem));
+#endif	
 		break;
 
 	case LED_PIN_LED1:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)	
 		schedule_work(&(priv->SwLed1WorkItem));
+#else
+		schedule_task(&(priv->SwLed1WorkItem));
+#endif	
 		break;
 
 	default:
@@ -769,27 +652,6 @@
 	}
 }
 
-// 
-// Callback fucntion of the workitem for SW LEDs.
-// 2006.03.01, by rcnjko.
-//
-#if 0
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-void Gpio0LedWorkItemCallback(void *Context)
-{
-	struct struct_work *work = (struct work_struct *)Context;
-	struct r8180_priv *priv = container_of(work, struct r8180_priv,Gpio0LedWorkItem);
-	struct net_device *dev = priv->ieee80211->dev;
-#else
-void
-Gpio0LedWorkItemCallback(
-	void *			Context
-	)
-{
-	struct net_device *dev = (struct net_device *)Context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-#endif
-#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 void Gpio0LedWorkItemCallback(struct work_struct *work)
 {
@@ -803,84 +665,50 @@
 #endif
 	PLED_8187	pLed = &(priv->Gpio0Led); 
 	if (priv == NULL || dev == NULL){
-//	printk("=========>%s In\n", __FUNCTION__);
-	//printk("ft=====================>%s()\n", __FUNCTION__);
 	}
 	
-#if 0 // by lizahoming 2008.6.3
+#if 0 
 	if(priv->LedStrategy == SW_LED_MODE2)
 		SwLedCm2Blink(dev, pLed);
 	else
 		SwLedBlink(dev, pLed);
 #endif
 
-#if 1 // by lizahoming 2008.6.3
+#if 1 
 	switch(priv->LedStrategy)
 	{
 	case SW_LED_MODE2:
 		SwLedCm2Blink(dev, pLed);
 		break;
-	//case SW_LED_MODE4:
-	//	SwLedCm4Blink(dev, pLed);
-	//	break;		
 	default:
 		SwLedBlink(dev, pLed);
 		break;
 	}
 #endif
 
-	//LeaveCallbackOfRtWorkItem( &(usbdevice->Gpio0LedWorkItem) );
 }
-#if 0
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-void SwLed0WorkItemCallback(void *	Context)
-{
-	struct struct_work *work = (struct work_struct *)Context;
-	struct r8180_priv *priv = container_of(work, struct r8180_priv, SwLed0WorkItem);
-	struct net_device *dev = priv->dev;
-#else
-void  SwLed0WorkItemCallback(void *	Context)
-{
-	struct net_device *dev = (struct net_device *)Context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-#endif
-#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 void SwLed0WorkItemCallback(struct work_struct *work)
 {
-	//struct r8180_priv *priv = container_of(work, struct r8180_priv, SwLed0WorkItem);
-	//struct net_device *dev = priv->dev;
 #else
 void  SwLed0WorkItemCallback(struct net_device *dev)
 {
-	//struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
-	//SwLedBlink(dev, &(priv->SwLed0));
-//	printk("=========>%s In\n", __FUNCTION__);
 
-	//LeaveCallbackOfRtWorkItem( &(usbdevice->SwLed0WorkItem) );
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 void SwLed1WorkItemCallback(struct work_struct *work)
 {
-	//struct r8180_priv *priv = container_of(work, struct r8180_priv, SwLed1WorkItem);
-	//struct net_device *dev = priv->dev;
 #else
 void
 SwLed1WorkItemCallback(struct net_device *dev)
 {
-	//struct r8180_priv *priv = ieee80211_priv(dev);
 #endif
-	//SwLedBlink(dev, &(priv->SwLed1));
 
-	//LeaveCallbackOfRtWorkItem( &(usbdevice->SwLed1WorkItem) );
 }
 
-//
-//	Implementation of LED blinking behavior.
-//	It toggle off LED and schedule corresponding timer if necessary.
-//
 void
 SwLedBlink(
 	struct net_device *dev, 
@@ -889,21 +717,15 @@
 {
 	u8 bStopBlinking = 0;
 
-//	printk("=========>%s In\n", __FUNCTION__);
-	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == LED_ON ) 
 	{
 		SwLedOn(dev, pLed);
-//		printk("Blinktimes (%d): turn on\n", pLed->BlinkTimes);
 	}	
 	else 
 	{
 		SwLedOff(dev, pLed);
-//		printk("Blinktimes (%d): turn off\n", pLed->BlinkTimes);
 	}
 
-	// Determine if we shall change LED state again.
-//by lizhaoming for LED BLINK SLOWLY
 	if(pLed->CurrLedState == LED_BLINK_SLOWLY)
 	{
 		bStopBlinking = 0;
@@ -940,46 +762,34 @@
 	}
 	else
 	{
-		// Assign LED state to toggle.
 		if( pLed->BlinkingLedState == LED_ON ) 
 			pLed->BlinkingLedState = LED_OFF;
 		else 
 			pLed->BlinkingLedState = LED_ON;
 
-		// Schedule a timer to toggle LED state. 
 		switch( pLed->CurrLedState )
 		{
 		case LED_BLINK_NORMAL:
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_NORMAL_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));		
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_NORMAL_INTERVAL);
 			break;
 
 		case LED_BLINK_SLOWLY:
 			if( pLed->bLedOn == 1 ) 
 			{
-			//printk("LED_BLINK_SLOWLY:turn off\n");
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_SLOWLY_INTERVAL+50;//for pcie mini card spec page 33, 250ms
-			add_timer(&(pLed->BlinkTimer));			
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_SLOWLY_INTERVAL+50);
 			pLed->BlinkingLedState = LED_OFF;			
 			} else {
-			//printk("LED_BLINK_SLOWLY:turn on\n");
-			pLed->BlinkTimer.expires = jiffies + 5000;//for pcie mini card spec page 33, 5s
-			add_timer(&(pLed->BlinkTimer));
+			mod_timer(&(pLed->BlinkTimer),jiffies + 5000);
 			pLed->BlinkingLedState = LED_ON;			
 			}	
 			break;
 
 		case LED_BLINK_CM3:
-			pLed->BlinkTimer.expires = jiffies + LED_CM3_BLINK_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));			
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM3_BLINK_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM3_BLINK_INTERVAL);
 			break;
 
 		default:
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_SLOWLY_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));			
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_SLOWLY_INTERVAL);
 			break;
 		}
 	}
@@ -987,9 +797,6 @@
 
 
 
-//
-//	Implementation of LED blinking behavior for SwLedControlMode2. 
-//
 void
 SwLedCm2Blink(
 	struct net_device *dev, 
@@ -997,40 +804,29 @@
 	)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//PMGNT_INFO priv = &(dev->MgntInfo);
 	u8 bStopBlinking = 0;
 
-	//printk("========+++++++++++++=>%s In\n", __FUNCTION__);
-	//To avoid LED blinking when rf is off, add by lizhaoming 2008.6.2
 	if((priv->eRFPowerState == eRfOff) && (priv->RfOffReason>RF_CHANGE_BY_IPS))
 	{
 		SwLedOff(dev, pLed);
 
-		pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_ON_INTERVAL;
-		add_timer(&(pLed->BlinkTimer));
-		//PlatformSetTimer(Adapter, &(pLed->BlinkTimer), LED_CM2_BLINK_ON_INTERVAL);
-		//printk(" Hw/Soft Radio Off, turn off Led\n");
+		mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_ON_INTERVAL);
 		return;
 	}
 	
-	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == LED_ON ) 
 	{
 		SwLedOn(dev, pLed);
-		//DMESG("Blinktimes (%d): turn on\n", pLed->BlinkTimes);
 	}	
 	else 
 	{
 		SwLedOff(dev, pLed);
-		//DMESG("Blinktimes (%d): turn off\n", pLed->BlinkTimes);
 	}
 
-	//Add by lizhaoming for avoid BlinkTimers <0, 2008.6.2
 	if(pLed->BlinkTimes > 0)
-	{//by lizhaoming 2008.6.2		
-	// Determine if we shall change LED state again.
+	{
 	pLed->BlinkTimes--;
-	}//by lizhaoming 2008.6.2	
+	}
 		
 	switch(pLed->CurrLedState)
 	{
@@ -1040,29 +836,6 @@
 			bStopBlinking = 1;
 		}
 		break;
-// CM2 scan blink and no link blind now not be supported 
-//	case LED_SCAN_BLINK:
-//		if( (priv->mAssoc || priv->mIbss) &&  // Linked.
-//			(!priv->bScanInProgress) && // Not in scan stage.
-//			(pLed->BlinkTimes % 2 == 0)) // Even
-//		{
-//			bStopBlinking = 1;
-//		}
-//		break;
-//
-//	case LED_NO_LINK_BLINK:
-//		//Revised miniCard Ad-hoc mode "Slow Blink" by Isaiah 2006-08-03	
-//		//if( (priv->mAssoc || priv->mIbss) ) // Linked.
-//		if( priv->mAssoc) 
-//		{
-//			bStopBlinking = 1;
-//		}
-//		else if(priv->mIbss && priv->bMediaConnect )
-//		{
-//			bStopBlinking = 1;
-//		}
-//		break;
-//
 	default:
 		bStopBlinking = 1;
 		break;
@@ -1070,64 +843,37 @@
 
 	if(bStopBlinking)
 	{
-//
-//		if( priv->eRFPowerState != eRfOn )
-//		{
-//			SwLedOff(dev, pLed);
-//		}
-//		else if( priv->bMediaConnect == 1 && pLed->bLedOn == 0)
-//		{
-//			SwLedOn(dev, pLed);
-//		}
-//		else if( priv->bMediaConnect == 0 &&  pLed->bLedOn == 1)
-//		{
-//			SwLedOff(dev, pLed);
-//		}
-//
 		pLed->BlinkTimes = 0;
 		pLed->bLedBlinkInProgress = 0;	
 	}
 	else
 	{
-		// Assign LED state to toggle.
 		if( pLed->BlinkingLedState == LED_ON ) 
 			pLed->BlinkingLedState = LED_OFF;
 		else 
 			pLed->BlinkingLedState = LED_ON;
 
-		// Schedule a timer to toggle LED state. 
 		switch( pLed->CurrLedState )
 		{
 		case LED_BLINK_NORMAL:
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_NORMAL_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));			
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_NORMAL_INTERVAL);
 			break;
 
 		case LED_BLINK_SLOWLY:
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_SLOWLY_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));			
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_SLOWLY_INTERVAL);
 			break;
 
 		case LED_SCAN_BLINK:
 		case LED_NO_LINK_BLINK:
 			if( pLed->bLedOn ) {
-				pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_ON_INTERVAL;
-				add_timer(&(pLed->BlinkTimer));				
-				//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM2_BLINK_ON_INTERVAL);
+				mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_ON_INTERVAL);
 			} else {
-				pLed->BlinkTimer.expires = jiffies + LED_CM2_BLINK_OFF_INTERVAL;
-				add_timer(&(pLed->BlinkTimer));		
-				//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_CM2_BLINK_OFF_INTERVAL);
+				mod_timer(&(pLed->BlinkTimer),jiffies + LED_CM2_BLINK_OFF_INTERVAL);
 			}
 			break;
 
 		default:
-			//RT_ASSERT(0, ("SwLedCm2Blink(): unexpected state!\n"));
-			pLed->BlinkTimer.expires = jiffies + LED_BLINK_SLOWLY_INTERVAL;
-			add_timer(&(pLed->BlinkTimer));
-			//PlatformSetTimer(dev, &(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			mod_timer(&(pLed->BlinkTimer),jiffies + LED_BLINK_SLOWLY_INTERVAL);
 			break;
 		}
 	}
@@ -1140,13 +886,12 @@
 )
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//printk("%s()\n", __func__);
 
 	switch(pLed->LedPin)
 	{
 	case LED_PIN_GPIO0:
 		write_nic_byte(dev,0xFF91,0x01);
-		write_nic_byte(dev,0xFF90,0x00);	// write 0 : LED on
+		write_nic_byte(dev,0xFF90,0x00);	
 		break;
 
 	case LED_PIN_LED0:
@@ -1173,13 +918,12 @@
 )
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//printk("%s()\n", __func__);
 
 	switch(pLed->LedPin)
 	{
 	case LED_PIN_GPIO0:
 		write_nic_byte(dev,0xFF91,0x01);
-		write_nic_byte(dev,0xFF90,0x01);	// write 1 : LED off
+		write_nic_byte(dev,0xFF90,0x01);	
 		break;
 
 	case LED_PIN_LED0:
diff -ruN rtl8187l_orig/rtl8187/r8187_led.h rtl8187l/rtl8187/r8187_led.h
--- rtl8187l_orig/rtl8187/r8187_led.h	2011-01-02 18:14:31.047507000 +0100
+++ rtl8187l/rtl8187/r8187_led.h	2009-06-26 09:07:43.841770000 +0200
@@ -24,11 +24,6 @@
 #include <linux/timer.h>
 
 
-//--------------------------Define -------------------------------------------*/
-//
-// 0x7E-0x7F is reserved for SW customization. 2006.04.21, by rcnjko.
-//
-// BIT[0-7] is for CustomerID where value 0x00 and 0xFF is reserved for Realtek.
 #define EEPROM_SW_REVD_OFFSET		0x7E
 
 #define EEPROM_CID_MASK			0x00FF
@@ -38,22 +33,17 @@
 #define EEPROM_CID_SERCOMM_PS	0x02
 #define EEPROM_CID_HW_LED			0x03
 
-#define LED_BLINK_NORMAL_INTERVAL	100 //50	//100
+#define LED_BLINK_NORMAL_INTERVAL	100 
 #define LED_BLINK_SLOWLY_INTERVAL	200
 
-// Customized for AzWave, 2006.04.03, by rcnjko.
 #define LED_CM2_BLINK_ON_INTERVAL		250
 #define LED_CM2_BLINK_OFF_INTERVAL	4750
-//
 
-// Customized for Sercomm Printer Server case, 2006.04.21, by rcnjko.
 #define LED_CM3_BLINK_INTERVAL			1500
 
 
-//--------------------------Define MACRO--------------------------------------*/
 
 
-//------------------------------Define Struct---------------------------------*/
 typedef	enum _LED_STATE_8187{
 	LED_UNKNOWN = 0,
 	LED_ON = 1,
@@ -61,9 +51,9 @@
 	LED_BLINK_NORMAL = 3,
 	LED_BLINK_SLOWLY = 4,
 	LED_POWER_ON_BLINK = 5,
-	LED_SCAN_BLINK = 6, 	// LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
-	LED_NO_LINK_BLINK = 7,	// LED is blinking during no link state.
-	LED_BLINK_CM3 = 8, 		// Customzied for Sercomm Printer Server case
+	LED_SCAN_BLINK = 6, 	
+	LED_NO_LINK_BLINK = 7,	
+	LED_BLINK_CM3 = 8, 		
 }LED_STATE_8187;
 
 typedef enum _RT_CID_TYPE {
@@ -74,11 +64,11 @@
 } RT_CID_TYPE;
 
 typedef	enum _LED_STRATEGY_8187{
-	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
-	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
-	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
-	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
-	HW_LED, 		// HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
+	SW_LED_MODE0, 
+	SW_LED_MODE1, 
+	SW_LED_MODE2, 
+	SW_LED_MODE3, 
+	HW_LED, 		
 }LED_STRATEGY_8187, *PLED_STRATEGY_8187;
 
 typedef enum _LED_PIN_8187{
@@ -87,35 +77,23 @@
 	LED_PIN_LED1
 }LED_PIN_8187;
 
-//by lizhaoming for LED 2008.6.23 into ieee80211.h
-//typedef enum _LED_CTL_MODE {
-//	LED_CTL_POWER_ON,
-//	LED_CTL_POWER_OFF,
-//	LED_CTL_LINK,
-//	LED_CTL_NO_LINK,
-//	LED_CTL_TX,
-//	LED_CTL_RX,
-//	LED_CTL_SITE_SURVEY,
-//} LED_CTL_MODE;
 
 typedef struct _LED_8187{
-	LED_PIN_8187		LedPin;	// Identify how to implement this SW led.
+	LED_PIN_8187		LedPin;	
 
-	LED_STATE_8187		CurrLedState; // Current LED state.
-	u8				bLedOn; // TRUE if LED is ON, FALSE if LED is OFF.
+	LED_STATE_8187		CurrLedState; 
+	u8				bLedOn; 
 
-	u8				bLedBlinkInProgress; // TRUE if it is blinking, FALSE o.w..
-	u32				BlinkTimes; // Number of times to toggle led state for blinking.
-	LED_STATE_8187		BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
-	struct timer_list		BlinkTimer;  // Timer object for led blinking.
+	u8				bLedBlinkInProgress; 
+	u32				BlinkTimes; 
+	LED_STATE_8187		BlinkingLedState; 
+	struct timer_list		BlinkTimer;  
 } LED_8187, *PLED_8187;
 
 
 
-//------------------------Export global variable------------------------------*/
 
 
-//------------------------------Funciton declaration--------------------------*/
 void
 InitSwLeds(
 	struct net_device *dev
diff -ruN rtl8187l_orig/rtl8187/readme rtl8187l/rtl8187/readme
--- rtl8187l_orig/rtl8187/readme	2011-01-02 18:14:31.047507000 +0100
+++ rtl8187l/rtl8187/readme	1970-01-01 01:00:00.000000000 +0100
@@ -1,124 +0,0 @@
-rtl8187 Linux kernel driver
-Released under the terms of GNU General Public Licence (GPL)
-Copyright(c) Andrea Merello - 2004,2005
-
-Portions of this driver are based on other projects, please see the notes
-in the source files for detail.
-A special thanks go to Realtek corp for their support and to David Young
-------------------------------------------------------------------------------
-
-This is an attempt to write somethig that can make rtl8187 usb dongle wifi card
-on Linux using only opensource stuff. 
-The rtl8225 radio is supported.
-
-It's in early development stage so don't expect too much from it 
-(also use it at your own risk!)
-This should be considered just a fragment of code.. using it on your(any) 
-system is at your own risk! Please note that I never supported the idea to 
-use it in any way, so i cannot be considered responsible in any way for 
-anything deriving by it usage.
-
-Anyway for now we have monitor mode and managed mode
-basically working! This isn't necessary stable, but seems to work.. 
-
-This driver is still under development and very far from perfect. It should work on x86,
-Other archs are untested..
-
-To compile the driver simply run make.
-
-The driver contains also the ieee80211.h and ieee80211_crypt.h from the ieee stack.
-Note that for some reasons this stack is NOT the same that will be included in newer
-2.6 kernel. I will try to port to this stack as soon as it will have enought features
-to support 8187 cards. 
-Please note that you will have to make sure the two .h files are the same of the ieee
-stack.
-In other words when you download from the CVS this driver and the ieee80211 stack a good
-idea is to copy the ieee80211.h and ieee80211_crypt.h from the ieee directory to the drv
-directory
-
-Warning during compile are OK
-
-To wake up the nic run:
-
-   ifconfig <ifacename> up 
-
-(where <ifacename> is your network device for wlan card).
-
-Please note that the default interface name is wlanX.
-
-Please note thet this will take several seconds.. 
-
-If you would like to set the interface name to something else you may use the 
-'devname=' module parameter. For example:
-
-   insmod r8187.ko ifname=eth%d 
-
-will set the interface name of this device to something like eth0.
-
-Once the nic is up it can be put in a monitor mode by running:
-
-   iwconfig <ifacename> mode monitor
-
-and channel number may be changed by running:
-
-   iwconfig <ifacename> channel XX
-
-
-In monitor mode a choice may be made via iwpriv if the nic should pass packets 
-with bad crc or drop them.
-
-To put the nic in managed mode run:
-
-   iwconfig <ifacename> mode managed
-
-In managed mode there is support for
-
-   iwlist scan
-
-that should report the currently available networks.
-Please note that in managed mode channels cannot be changed manually.
-
-To associate with a network
-   
-   iwconfig <ifacename> essid XXXXX
-
-where XXXXX is the network essid (name) reported by 'iwlist scan'. Please
-note that essid is case sensitive.
-
-If your network is not broadcasting the ESSID, then you need to specify *also*
-the AP MAC address 
-
-   iwconfig <ifacename> ap XX:XX:XX:XX:XX:XX
-
-The driver accepts another boolean parameter: hwseqnum
-If set to 1 it lets the card HW take care of the sequence number of the TXed 
-frames. Altought in managed mode I can't see an important reason to use HW to 
-do that, when we'll start to TX beacons in master (AP) and ad-hoc modes most 
-probably it will be extremely useful (since most probably we will use two HW 
-queues).
-
-I'm unsure if it will work correctly on all NICs.. reports are *VERY, VERY* apreciated.. 
-
- 
- WEP
- ===
-
-WEP encryption should work. For now it's done by host, not by the nic. Key can be set with:
-Key can be set with
-   
-   iwconfig <ifacename> key 12345...
-
-WEP is supported via software thanks to the ipw stack.
-
-Shared and open authentication are supported
-
- IWPRIV
- ======
-
-This driver supports some private handlers:
--badcrc: let you choose to kill or to pass to the upper layer frames with bad crc in monitor mode
--activescan: if 0 the driver will avoid to send probe requests, sanning will be only on beacon basis
-
-
-If you have some question/comments please feel free to write me.
-
